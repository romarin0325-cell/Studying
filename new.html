
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Turn RPG: Legend Edition v9.5</title>
<style>
    /* =========================================
       Global Layout
       ========================================= */
    body { 
        background-color: #121212; 
        color: #e0e0e0; 
        font-family: 'Suit', sans-serif; 
        margin: 0; padding: 0; 
        display: flex; flex-direction: column; 
        height: 100vh; height: 100dvh; 
        overflow: hidden; 
        user-select: none; 
    }

    .header { padding: 10px; text-align: center; background: #1f1f1f; border-bottom: 1px solid #333; font-size: 0.95rem; color: #bbb; font-weight: bold; flex-shrink: 0; }
    
    .container { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        padding: 8px; 
        overflow: hidden; 
        gap: 8px;
    }

    /* ìƒë‹¨ ìƒíƒœì°½ */
    .status-panel { 
        background: #222; padding: 8px 12px; border-radius: 8px; border: 1px solid #333; display: flex; flex-direction: column; gap: 4px; flex-shrink: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .status-top { display: flex; justify-content: space-between; align-items: center; }
    .char-info { font-size: 1.0rem; font-weight: bold; color: #fff; }
    .stat-bars { width: 55%; }
    .bar-box { background: #444; height: 14px; border-radius: 8px; margin: 3px 0; position: relative; overflow: hidden; }
    .bar-fill { height: 100%; transition: width 0.3s ease; }
    .hp-bar { background: #d32f2f; }
    .mp-bar { background: #1976d2; }
    .bar-text { position: absolute; width: 100%; text-align: center; top: 0; font-size: 10px; line-height: 14px; color: #fff; text-shadow: 1px 1px 1px #000; }
    .stat-detail { font-size: 0.7rem; color: #bbb; display: flex; justify-content: space-between; background: #2a2a2a; padding: 5px; border-radius: 4px; }
    .artifact-box { font-size: 0.7rem; color: #ffd700; white-space: nowrap; overflow-x: auto; padding: 4px; background: #2a2a2a; border-radius: 4px; border: 1px dashed #555; }

    /* =========================================
       ë¹„ì£¼ì–¼ ìŠ¤í…Œì´ì§€
       ========================================= */
    .visual-stage {
        flex: 0 0 auto; 
        position: relative;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 6px;
        min-height: 150px; 
        background-image: linear-gradient(to bottom, #2a2a2a, #121212);
    }

    .actor-box {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        transition: all 0.3s ease;
    }
    .actor-box.player { left: 15px; }
    .actor-box.enemy { right: 15px; opacity: 0; }

    .portrait {
        width: 54px; height: 72px; /* 3:4 ë¹„ìœ¨ */
        border-radius: 8px;
        background: #000;
        border: 2px solid #555;
        overflow: hidden;
        box-shadow: 0 4px 10px rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        font-size: 1.8rem;
    }
    .portrait img { width: 100%; height: 100%; object-fit: cover; }

    .mini-stat {
        position: absolute;
        width: 140px; 
        background: rgba(30, 30, 30, 0.85);
        padding: 6px 10px;
        border-radius: 6px;
        text-align: center;
        border: 1px solid #444;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        z-index: 5;
        transition: all 0.3s ease;
    }

    .player-stat { top: 15px; left: 42%; transform: translateX(-50%); }
    .enemy-stat { bottom: 15px; left: 58%; transform: translateX(-50%); opacity: 0; }

    .actor-name { font-size: 0.8rem; color: #fff; font-weight: bold; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .mini-hp-bg { width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; border: 1px solid #222; }
    .mini-hp-fill { height: 100%; background: #ef5350; transition: width 0.3s; }
    
    .visual-stage.town-mode .actor-box.player { left: 50%; transform: translate(-50%, -50%) scale(1.1); }
    .visual-stage.town-mode .actor-box.enemy { display: none; }
    .visual-stage.town-mode .player-stat { top: auto; bottom: 20px; left: 50%; }
    .visual-stage.town-mode .enemy-stat { display: none; }
    
    .visual-stage.battle-mode .actor-box.enemy { opacity: 1; }
    .visual-stage.battle-mode .enemy-stat { opacity: 1; }

    .shake { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 
        10%, 90% { transform: translate3d(-1px, -50%, 0); } 
        20%, 80% { transform: translate3d(1px, -50%, 0); } 
        30%, 50%, 70% { transform: translate3d(-2px, -50%, 0); } 
        40%, 60% { transform: translate3d(2px, -50%, 0); } 
    }

    /* ë¡œê·¸ì°½ */
    .log-container { height: 70px; background: #1a1a1a; border: 1px solid #333; border-radius: 5px; padding: 8px; overflow-y: auto; font-size: 0.8rem; flex-shrink: 0; box-shadow: inset 0 0 10px #000; margin-bottom: 6px; }
    .log-line { margin-bottom: 3px; border-bottom: 1px solid #252525; padding-bottom: 1px; line-height: 1.25; }
    .log-turn { color: #fbc02d; font-weight: bold; margin-top: 8px; border-top: 1px solid #444; padding-top: 4px; text-align: center; }
    .dmg { color: #ff5252; } .heal { color: #69f0ae; } .info { color: #4fc3f7; } .rose { color: #f06292; } .fire { color: #ffab91; } .holy { color: #fff59d; } .star { color: #e1f5fe; text-shadow: 0 0 3px #0288d1; }

    /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ */
    #game-controls { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        min-height: 0; 
        overflow: hidden; 
    }
    
    #battle-menu {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .controls { 
        flex: 1; 
        display: grid; 
        grid-template-columns: repeat(2, 1fr); 
        gap: 6px; 
        padding: 2px 2px 10px 2px;
        overflow-y: auto; 
        min-height: 0;
    }
    .controls.menu-mode { grid-template-columns: 1fr; }
    
    button { background: #333; border: 1px solid #555; color: #eee; padding: 12px; border-radius: 8px; font-size: 0.9rem; cursor: pointer; transition: all 0.1s; touch-action: manipulation; min-height: 52px; }
    button:active { background: #555; transform: scale(0.98); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-atk { background: linear-gradient(135deg, #4a148c, #7b1fa2); border-color: #8e24aa; }
    .btn-skill { background: linear-gradient(135deg, #0d47a1, #1976d2); border-color: #2196f3; }
    .btn-def { background: linear-gradient(135deg, #1b5e20, #388e3c); border-color: #4caf50; }
    .btn-ult { background: linear-gradient(135deg, #b71c1c, #d32f2f); border-color: #f44336; grid-column: span 2; font-weight: bold; border: 1px solid #ffcdd2; }
    .skill-sub { display: block; font-size: 0.7rem; color: #ccc; margin-top: 1px; }
    
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
    .modal.active { display: flex; }
    .modal-content { background: #222; padding: 20px; border-radius: 12px; border: 1px solid #444; width: 85%; max-width: 400px; text-align: center; max-height: 85vh; overflow-y: auto; }
    .char-select-btn { width: 100%; margin: 6px 0; padding: 16px; text-align: left; background: #333; }
</style>
</head>
<body>

<div class="header">Turn RPG: Legend Edition v9.5</div>

<div class="container">
    <div class="status-panel">
        <div class="status-top">
            <div class="char-info">
                <div id="char-name">ìºë¦­í„°</div>
                <div style="font-size:0.8rem; color:#aaa;" id="char-lvl">Lv.1</div>
            </div>
            <div class="stat-bars">
                <div class="bar-box"><div id="hp-bar" class="bar-fill hp-bar" style="width:100%"></div><span id="hp-text" class="bar-text">0/0</span></div>
                <div class="bar-box"><div id="mp-bar" class="bar-fill mp-bar" style="width:50%"></div><span id="mp-text" class="bar-text">0/0</span></div>
            </div>
        </div>
        <div class="stat-detail">
            <span>âš”ï¸ ATK: <span id="ui-atk" style="color:#ef9a9a">0</span></span>
            <span>ğŸ”® MATK: <span id="ui-matk" style="color:#90caf9">0</span></span>
            <span>ğŸ›¡ï¸ DEF: <span id="ui-def" style="color:#a5d6a7">0</span></span>
            <span>ğŸ”° MDEF: <span id="ui-mdef" style="color:#ce93d8">0</span></span>
        </div>
        <div id="artifact-list" class="artifact-box">ìœ ë¬¼: ì—†ìŒ</div>
        <div id="extra-ui" style="display:none; font-size:0.8rem; margin-top:4px; text-align:center;"></div>
    </div>

    <div id="main-stage" class="visual-stage town-mode">
        <div id="player-actor" class="actor-box player">
            <div class="portrait" id="player-img">ğŸ§™â€â™‚ï¸</div> 
        </div>
        <div id="enemy-actor" class="actor-box enemy">
            <div class="portrait" id="enemy-img">ğŸ’€</div>
        </div>
        <div class="mini-stat player-stat">
            <div class="actor-name" id="vis-p-name">Player</div>
            <div class="mini-hp-bg"><div id="vis-p-hp" class="mini-hp-fill" style="width:100%"></div></div>
        </div>
        <div class="mini-stat enemy-stat">
            <div class="actor-name" id="vis-e-name">Monster</div>
            <div class="mini-hp-bg"><div id="vis-e-hp" class="mini-hp-fill" style="width:100%"></div></div>
        </div>
    </div>

    <div id="game-controls">
        <div id="town-menu" class="controls menu-mode" style="display:none;">
            <div style="text-align:center; margin-bottom:10px; color:#ffd700;">
                í‰í™”ë¡œìš´ ë§ˆì„ (ê³¨ë“œ: <span id="ui-gold" style="font-weight:bold;">0</span> G)
            </div>
            <button onclick="enterDungeon(1)">ğŸŸ¢ ì†ì‚­ì´ëŠ” ë™êµ´ (Lv.1~3)</button>
            <button onclick="enterDungeon(2)">ğŸŸ¡ ê²€ì€ ì•ˆê°œ ìˆ² (Lv.4~7)</button>
            <button onclick="enterDungeon(3)">ğŸ”´ ìŠí˜€ì§„ ê³ ì„± (Lv.8~10)</button>
            <button onclick="enterEvent()">ğŸŸ£ í˜¼ëˆì˜ í‹ˆ (Lv.11~16)</button>
            <button onclick="enterDungeon(5)" style="background: linear-gradient(135deg, #4fc3f7, #0288d1); border-color:#29b6f6; color:#fff;">â„ï¸ ì˜ê²ì˜ ë¹™í•˜ (Lv.17~20)</button>
            <button onclick="enterDungeon(6)" style="background: linear-gradient(135deg, #cfd8dc, #546e7a); border-color:#90a4ae; color:#263238; font-weight:bold;">â˜ï¸ ì²œìƒì˜ ê³„ë‹¨ (Lv.21~25)</button>

            <!-- Event Dungeons -->
            <button id="btn-event-dessert" class="btn-event-dungeon" onclick="enterEventDungeon('dessert')" style="display:none; background: linear-gradient(135deg, #f8bbd0, #ec407a); border-color:#e91e63; color:#fff;">ğŸ° ë””ì €íŠ¸ í‚¹ë¤</button>
            <button id="btn-event-magic" class="btn-event-dungeon" onclick="enterEventDungeon('magic')" style="display:none; background: linear-gradient(135deg, #7e57c2, #512da8); border-color:#673ab7; color:#fff;">ğŸ° ë§ˆë„ ì œêµ­</button>
            <button id="btn-event-dragon" class="btn-event-dungeon" onclick="enterEventDungeon('dragon')" style="display:none; background: linear-gradient(135deg, #ffab91, #d84315); border-color:#bf360c; color:#fff;">ğŸ² ìš©ì˜ ë‘¥ì§€</button>
            <button id="btn-event-ruins" class="btn-event-dungeon" onclick="enterEventDungeon('ruins')" style="display:none; background: linear-gradient(135deg, #8d6e63, #5d4037); border-color:#4e342e; color:#fff;">ğŸº ê³ ëŒ€ ìœ ì </button>
            <button id="btn-event-time" class="btn-event-dungeon" onclick="enterEventDungeon('time')" style="display:none; background: linear-gradient(135deg, #b39ddb, #673ab7); border-color:#512da8; color:#fff;">ğŸ•°ï¸ ì‹œê°„ì˜ ë„ì„œê´€</button>

            <!-- Hidden Dungeon -->
            <button id="btn-hidden-dungeon" onclick="enterHiddenDungeon()" style="display:none; background: linear-gradient(135deg, #212121, #000000); border-color:#424242; color:#fff;">ğŸ‘ï¸ ë¹›ê³¼ ì €ì£¼ì˜ íšŒë‘ (Hidden)</button>

            <button onclick="openShop()" style="background:#424242;">ğŸ›’ ìƒì  / ìŠ¤í‚¬ ê´€ë¦¬</button>
            <button onclick="openSettings()" style="background:#37474f; border-color:#455a64; color:#b0bec5;">âš™ï¸ ê²Œì„ ì„¤ì •</button>
        </div>

        <div id="battle-menu" style="display:none; width:100%;">
            <div id="log-box" class="log-container"></div>
            <div id="action-btns" class="controls"></div>
        </div>
    </div>
</div>

<div id="shop-modal" class="modal">
    <div class="modal-content">
        <h2 style="color:#fff; border-bottom:1px solid #555; padding-bottom:10px;">ì •ë¹„ì†Œ</h2>
        <div style="margin-bottom:15px; color:#ffd700; font-size:1.1rem;">ê³¨ë“œ: <span id="shop-gold">0</span> G</div>
        <h4 style="text-align:left; color:#81d4fa;">ëŠ¥ë ¥ì¹˜ ê°•í™”</h4>
        <button onclick="upgradeMana()" style="width:100%; margin-bottom:5px;">ë§ˆë‚˜ íš¨ìœ¨ ê°•í™” <span id="mana-cost" class="skill-sub"></span></button>
        <button onclick="healFull()" style="width:100%; margin-bottom:15px;">ì „ì²´ íšŒë³µ <span class="skill-sub">ë¹„ìš©: 50 G</span></button>
        <h4 style="text-align:left; color:#ffcc80;">ì¥ë¹„ ê°•í™”</h4>
        <button onclick="buyEquip('weapon')" style="width:100%; margin-bottom:5px;">ë¬´ê¸° ê°•í™” <span id="weapon-cost" class="skill-sub"></span></button>
        <button onclick="buyEquip('armor')" style="width:100%; margin-bottom:15px;">ë°©ì–´êµ¬ ê°•í™” <span id="armor-cost" class="skill-sub"></span></button>
        <h4 style="text-align:left; color:#a5d6a7;">ìŠ¤í‚¬ ìŠµë“</h4>
        <div id="skill-shop-list" style="display:grid; grid-template-columns:1fr; gap:6px; margin-bottom:15px;"></div>

        <button onclick="resetAllArtifacts()" style="width:100%; margin-bottom:5px; background:#3e2723; border-color:#5d4037;">
            ğŸ•°ï¸ ì‹œê°„ì˜ ì—­í–‰ (20,000 G)
            <span class="skill-sub" style="color:#bcaaa4">ëª¨ë“  ìœ ë¬¼ ë¦¬ì…‹ (ê¸°ë³¸ í™•ë¥ )</span>
        </button>

        <button onclick="resetAllArtifacts(true)" style="width:100%; margin-bottom:5px; background:linear-gradient(135deg, #7b1fa2, #e040fb); border-color:#d500f9;">
             ğŸ”® ê³ ê·€í•œ ì‹œê°„ì˜ ì—­í–‰ (100,000 G)
             <span class="skill-sub" style="color:#e1bee7">ëª¨ë“  ìœ ë¬¼ ë¦¬ì…‹ (ì—í”½/ì „ì„¤ í™•ë¥  3ë°°)</span>
        </button>
        <button onclick="closeShop()" style="background:#555; margin-top:10px;">ë‚˜ê°€ê¸°</button>
    </div>
</div>

<div id="char-modal" class="modal active">
    <div class="modal-content">
        <div class="title-text" style="font-size:1.2rem; margin-bottom:15px;">ìš´ëª… ì„ íƒ</div>
        <button class="char-select-btn" onclick="selectChar('luna')">
            <span style="color:#b39ddb; font-size:1.1rem; font-weight:bold;">ğŸŒ™ ë£¨ë‚˜ (ì•”ì‚´ì)</span>
            <span class="skill-sub">íšŒí”¼ / ì¹˜ëª…íƒ€ / ìœ ë¦¬ëŒ€í¬</span>
        </button>
        <button class="char-select-btn" onclick="selectChar('zeke')">
            <span style="color:#ef9a9a; font-size:1.1rem; font-weight:bold;">ğŸ”¥ ì§€í¬ (ê¸°ì‚¬ë‹¨ì¥)</span>
            <span class="skill-sub">ê·¼ì„± / ë°˜ê²© / í•˜ì´ë¸Œë¦¬ë“œ íƒ±ì»¤</span>
        </button>
        <button class="char-select-btn" onclick="selectChar('jasmine')">
            <span style="color:#fff59d; font-size:1.1rem; font-weight:bold;">â˜€ï¸ ììŠ¤ë¯¼ (ë§ˆë²•ì‚¬)</span>
            <span class="skill-sub">ë§ˆë‚˜ / ìš´ì˜ / ì»¨íŠ¸ë¡¤</span>
        </button>
        <button class="char-select-btn" onclick="selectChar('queen')">
            <span style="color:#f48fb1; font-size:1.1rem; font-weight:bold;">ğŸŒ¹ ì—¬ì™• (ë§ˆë²•ê²€ì‚¬)</span>
            <span class="skill-sub">ìŠ¤íƒ / ì§€ì†ë”œ / ìš´ì˜</span>
        </button>
        <button class="char-select-btn" onclick="selectChar('rumi')">
            <span style="color:#81d4fa; font-size:1.1rem; font-weight:bold;">âœ¨ ë£¨ë¯¸ (ëŒ€í˜„ì)</span>
            <span class="skill-sub">í˜•íƒœ ë³€í™˜ / í•˜ì´ë¸Œë¦¬ë“œ / ê¿ˆì˜ ê²°ì •</span>
        </button>
    </div>
</div>

<div id="alert-modal" class="modal">
    <div class="modal-content" style="width:70%;">
        <div id="alert-msg" style="color:#fff; margin-bottom:20px;">ì•Œë¦¼</div>
        <button onclick="document.getElementById('alert-modal').classList.remove('active')" style="width:100%; padding:10px; background:#444;">í™•ì¸</button>
    </div>
</div>

<div id="settings-modal" class="modal">
    <div class="modal-content">
        <h2 style="color:#fff; border-bottom:1px solid #555; padding-bottom:10px;">ê²Œì„ ì„¤ì •</h2>

        <button onclick="saveGame()" style="width:100%; margin-bottom:15px; background:#1b5e20; border-color:#2e7d32; color:#a5d6a7;">
            ğŸ’¾ í˜„ì¬ ìƒíƒœ ë³´ì¡´
            <span class="skill-sub" style="color:#81c784">í˜„ì¬ ì§„í–‰ìƒí™©ì„ ì €ì¥í•©ë‹ˆë‹¤</span>
        </button>

        <button onclick="openResetModal()" style="width:100%; margin-bottom:15px; background:#b71c1c; border-color:#d32f2f; color:#ffcdd2;">
            â˜ ï¸ ê²Œì„ ì´ˆê¸°í™” (Rebirth)
            <span class="skill-sub" style="color:#e57373">ì¬ì‹œì‘ ë˜ëŠ” ì™„ì „ ì´ˆê¸°í™”</span>
        </button>

        <button onclick="document.getElementById('settings-modal').classList.remove('active')" style="width:100%; background:#555;">ë‹«ê¸°</button>
    </div>
</div>

<div id="reset-modal" class="modal">
    <div class="modal-content">
        <div class="title-text" style="font-size:1.2rem; margin-bottom:15px; color:#ef5350;">ì´ˆê¸°í™” ì˜µì…˜</div>

        <button id="btn-soft-reset" onclick="triggerReset('soft')" style="width:100%; margin-bottom:10px; background:#1b5e20;">
            <div style="font-weight:bold; font-size:1.0rem;">ğŸ”„ í˜„ì¬ íšŒì°¨ ì¬ì‹œì‘</div>
            <div style="font-size:0.75rem; color:#a5d6a7;">ìœ ë¬¼ í•´ê¸ˆ / ì  ê°•í™” ìƒíƒœ / íšŒì°¨ ìœ ì§€</div>
        </button>

        <button onclick="triggerReset('hard')" style="width:100%; margin-bottom:10px; background:#b71c1c;">
            <div style="font-weight:bold; font-size:1.0rem;">â˜ ï¸ ì™„ì „ ì´ˆê¸°í™”</div>
            <div style="font-size:0.75rem; color:#ef9a9a;">ëª¨ë“  ê¸°ë¡ ì‚­ì œ (íšŒì°¨ / ìœ ë¬¼ í•´ê¸ˆ í¬í•¨)</div>
        </button>

        <button onclick="document.getElementById('reset-modal').classList.remove('active')" style="width:100%; background:#444;">ì·¨ì†Œ</button>
    </div>
</div>

<div id="load-modal" class="modal">
    <div class="modal-content">
        <div class="title-text" style="font-size:1.2rem; margin-bottom:15px; color:#4fc3f7;">ì €ì¥ëœ ë°ì´í„° ë°œê²¬</div>
        <div style="font-size:0.9rem; color:#ccc; margin-bottom:20px;">
            ì´ì „ì— ì €ì¥ëœ ê²Œì„ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.<br>
            ì´ì–´í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
        </div>

        <button onclick="loadGame()" style="width:100%; margin-bottom:10px; background:#0277bd;">
            <div style="font-weight:bold; font-size:1.0rem;">ğŸ“‚ ì´ì–´í•˜ê¸°</div>
            <div style="font-size:0.75rem; color:#81d4fa;" id="load-desc">Lv.? / ?</div>
        </button>

        <button onclick="startNewGameProcess()" style="width:100%; background:#b71c1c;">
            <div style="font-weight:bold; font-size:1.0rem;">âœ¨ ìƒˆë¡œ ì‹œì‘</div>
            <div style="font-size:0.75rem; color:#ef9a9a;">ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤</div>
        </button>
    </div>
</div>

<!-- data.js: characters, skills, artifacts, enemies -->
<script src="data.js"></script>

<script>
/* =========================================
   2. ê²Œì„ ë¡œì§ (Game Logic)
   ========================================= */
let player = {};
let gameState = { gold: 10000, learnedSkills: [], manaLevel: 0, equipWeapon: 0, equipArmor: 0, currentEventDungeon: null };
let currentEnemy = null;
let turnCount = 0;
let buffs = { player: {}, enemy: {} };
let roseStack = 0; 

function myAlert(msg) {
    document.getElementById('alert-msg').innerText = msg;
    document.getElementById('alert-modal').classList.add('active');
}

function viewPatchNotes() {
    document.getElementById('patch-modal').classList.add('active');
}

function log(msg, type='info') {
    const box = document.getElementById('log-box');
    const div = document.createElement('div');
    div.className = `log-line ${type}`;
    div.innerHTML = msg;
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
}

function selectChar(charKey) {
    const data = CHAR_DATA[charKey];
    if(!data) return myAlert("ë°ì´í„° ì˜¤ë¥˜");
    player = JSON.parse(JSON.stringify(data));
    player.charKey = charKey;
    player.baseStats = { hp: data.hp, mp: data.mp, atk: data.atk, matk: data.matk, def: data.def, mdef: data.mdef };
    player.artifacts = [];
    player.level = 1;
    player.exp = 0;
    
    // ëŒ€í˜„ì ê³ ìœ  ìì›
    if(charKey === 'rumi') {
        player.dreamCrystals = 5;
    }
    
    gameState.gold = 10000;
    gameState.learnedSkills = ['basic']; // ê¸°ë³¸ ê³µê²© ìŠµë“
    
    if(charKey === 'queen') {
        gameState.learnedSkills.push('thornwhip');
        gameState.learnedSkills.push('roseseed');
    }
    if(charKey === 'zeke') {
        gameState.learnedSkills.push('heavy');
    }
    if(charKey === 'rumi') {
        gameState.learnedSkills.push('pangpang');
        gameState.learnedSkills.push('starbarrier'); // ë£¨ë¯¸: ìŠ¤íƒ€ ë°°ë¦¬ì–´ ì¶”ê°€ ìŠµë“
    }

    gameState.manaLevel = 0;
    gameState.equipWeapon = 0;
    gameState.equipArmor = 0;

    for(let k in player.skills) {
        if(player.skills[k].price === 0 && k !== 'basic' && k !== 'starbarrier' && !gameState.learnedSkills.includes(k)) {
            if(!gameState.learnedSkills.includes(k)) gameState.learnedSkills.push(k);
        }
    }

    recalcAllStats(); 
    player.hp = player.maxHp;
    player.mp = player.maxMp;

    document.getElementById('char-modal').classList.remove('active');
    document.getElementById('town-menu').style.display = 'grid'; 
    updateTownUI(); // ì´ë²¤íŠ¸ ë˜ì „ ë²„íŠ¼ ê°±ì‹ 
    updateInfo();
}

function updateTownUI() {
    // ì´ë²¤íŠ¸ ë˜ì „ ë²„íŠ¼ë“¤ ìˆ¨ê¸°ê¸°
    const eventBtns = document.querySelectorAll('.btn-event-dungeon');
    eventBtns.forEach(btn => btn.style.display = 'none');

    // í˜„ì¬ í• ë‹¹ëœ ì´ë²¤íŠ¸ ë˜ì „ë§Œ ë³´ì´ê¸°
    if(gameState.currentEventDungeon) {
        const targetBtn = document.getElementById(`btn-event-${gameState.currentEventDungeon}`);
        if(targetBtn) targetBtn.style.display = 'block';
    }

    // íˆë“  ë˜ì „ í•´ê¸ˆ í™•ì¸
    if(checkHiddenUnlock()) {
        document.getElementById('btn-hidden-dungeon').style.display = 'block';
    } else {
        document.getElementById('btn-hidden-dungeon').style.display = 'none';
    }
}

function checkHiddenUnlock() {
    const required = ['hestia', 'dream_choco', 'blue_moon', 'dragon_scale', 'pharaoh', 'dark_pendant'];
    const unlocks = getBossArtifactUnlocks();
    // ëª¨ë“  í•„ìˆ˜ ì „ì„¤ ìœ ë¬¼ì´ unlock ë˜ì–´ìˆëŠ”ì§€ í™•ì¸
    return required.every(id => unlocks.includes(id));
}

function confirmResetGame() {
    const modal = document.getElementById('reset-modal');
    modal.classList.add('active');

    const softBtn = document.getElementById('btn-soft-reset');
    if(gameState.clearedCreator) {
        softBtn.innerHTML = `
            <div style="font-weight:bold; font-size:1.0rem;">ğŸ”„ ê²Œì„ ì¬ì‹œì‘ (ë‹¤ìŒ íšŒì°¨)</div>
            <div style="font-size:0.75rem; color:#a5d6a7;">ì  ê°•í™”(+10%) / ë ˆë²¨ í™•ì¥(+1) / ìœ ë¬¼ í•´ê¸ˆ ìœ ì§€</div>
            <div style="font-size:0.7rem; color:#81c784; margin-top:2px;">(ì°½ì¡°ì‹  í´ë¦¬ì–´ ë³´ìƒ ì ìš©)</div>
        `;
    } else {
        softBtn.innerHTML = `
            <div style="font-weight:bold; font-size:1.0rem;">ğŸ”„ í˜„ì¬ íšŒì°¨ ì¬ì‹œì‘</div>
            <div style="font-size:0.75rem; color:#a5d6a7;">ìœ ë¬¼ í•´ê¸ˆ / ì  ê°•í™” ìƒíƒœ / íšŒì°¨ ìœ ì§€</div>
            <div style="font-size:0.7rem; color:#81c784; margin-top:2px;">(ì§„í–‰ ë¶ˆê°€ ì‹œ ì¶”ì²œ)</div>
        `;
    }
}

function triggerReset(mode) {
    if(mode === 'hard') {
        if(!confirm("ì •ë§ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n- íšŒì°¨(ë‚œì´ë„) ì´ˆê¸°í™” (1íšŒì°¨ë¡œ ë³µê·€)\n- ìœ ë¬¼ í•´ê¸ˆ ê¸°ë¡ ì‚­ì œ\n- ì°½ì¡°ì‹  í´ë¦¬ì–´ ê¸°ë¡ ì‚­ì œ\n\nì™„ì „íˆ ì²˜ìŒ ìƒíƒœë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.")) return;

        localStorage.removeItem('turnRpgCycle');
        localStorage.removeItem('turnRpgClears');
        localStorage.removeItem('turnRpgBossDrops'); // ë³´ìŠ¤ ìœ ë¬¼ í•´ê¸ˆ ì´ˆê¸°í™”
    } else {
        let msg = "í˜„ì¬ íšŒì°¨ë¥¼ ì¬ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n- ìºë¦­í„°/ê³¨ë“œ/ë³´ìœ ìœ ë¬¼ ì´ˆê¸°í™”\n- íšŒì°¨(ì  ê°•í™”) ë° ìœ ë¬¼ í•´ê¸ˆ ìƒíƒœëŠ” ìœ ì§€ë©ë‹ˆë‹¤.";
        if(gameState.clearedCreator) {
            msg = "ê²Œì„ì„ ì¬ì‹œì‘í•˜ê³  ë‹¤ìŒ íšŒì°¨ë¡œ ë„˜ì–´ê°€ì‹œê² ìŠµë‹ˆê¹Œ?\n\n- ì ì˜ ëŠ¥ë ¥ì¹˜ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.\n- ìµœëŒ€ ë ˆë²¨ì´ 1 ì¦ê°€í•©ë‹ˆë‹¤.\n- ìºë¦­í„°/ê³¨ë“œ/ë³´ìœ ìœ ë¬¼ì€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.";
        }
        if(!confirm(msg)) return;

        // ì°½ì¡°ì‹  í´ë¦¬ì–´ ìƒíƒœë¼ë©´ ì—¬ê¸°ì„œ íšŒì°¨ ì¦ê°€
        if(gameState.clearedCreator) {
            incrementCycle();
        }
    }

    document.getElementById('reset-modal').classList.remove('active');
    resetGameProcess();
}

function resetGameProcess() {
    // 1. ì´ˆê¸°í™”
    gameState.gold = 10000;
    gameState.clearedCreator = false; // [FIX] íšŒì°¨ ì¦ê°€ ì¤‘ë³µ ë°©ì§€
    roseStack = 0;
    buffs = { player: {}, enemy: {} };
    player = {};

    // 2. ì´ë²¤íŠ¸ ë˜ì „ ì„¤ì • (íšŒì°¨ë³„ 1ê°œ, ì¤‘ë³µ X, 6íšŒì°¨ë¶€í„° ë“±ì¥ X)
    setupEventDungeon();

    // 3. NG+ ìœ ë¬¼ í’€ ì„¸íŒ…
    initArtifactsWithNGPlus();

    // 4. UI ë¦¬ì…‹ ë° ìºë¦­í„° ì„ íƒì°½ ì—´ê¸°
    document.getElementById('town-menu').style.display = 'none';
    document.getElementById('battle-menu').style.display = 'none';
    document.getElementById('shop-modal').classList.remove('active');

    // í™”ë©´ ìš”ì†Œ ë¦¬ì…‹
    document.getElementById('vis-p-hp').style.width = '100%';
    document.getElementById('hp-bar').style.width = '100%';
    document.getElementById('mp-bar').style.width = '50%';
    document.getElementById('log-box').innerHTML = "";
    document.getElementById('main-stage').classList.remove('battle-mode');
    document.getElementById('main-stage').classList.add('town-mode');

    // ìºë¦­í„° ì„ íƒ ëª¨ë‹¬ ì—´ê¸°
    document.getElementById('char-modal').classList.add('active');
    myAlert("ê²Œì„ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ìƒˆë¡œìš´ ìš´ëª…ì´ ì‹œì‘ë©ë‹ˆë‹¤)");
}

function setupEventDungeon() {
    let cycle = getCycleCount();
    // 6íšŒì°¨(ì¸ë±ìŠ¤ 5)ë¶€í„°ëŠ” ë“±ì¥í•˜ì§€ ì•ŠìŒ
    if(cycle >= 5) {
        gameState.currentEventDungeon = null;
        return;
    }

    let usedEvents = JSON.parse(localStorage.getItem('turnRpgUsedEvents') || '[]');
    const ALL_EVENTS = ['dessert', 'magic', 'dragon', 'ruins', 'time'];

    // í˜„ì¬ íšŒì°¨ì— ì´ë¯¸ í• ë‹¹ëœ ì´ë²¤íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸ (ì¬ì‹œì‘ ì‹œ ìœ ì§€)
    // í•˜ì§€ë§Œ usedEventsëŠ” ë¬¸ìì—´ ë°°ì—´ì´ë¯€ë¡œ, ìˆœì„œëŒ€ë¡œ í• ë‹¹ë˜ì—ˆë‹¤ê³  ê°€ì •í•˜ê±°ë‚˜,
    // cycle ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§¤í•‘í•´ì•¼ í•¨.
    // ë‹¨ìˆœí•˜ê²Œ: usedEventsì˜ ê¸¸ì´ëŠ” í˜„ì¬ ì§„í–‰í•œ íšŒì°¨ ìˆ˜ì™€ ê°™ì•„ì•¼ í•¨ (0íšŒì°¨ -> 1ê°œ í• ë‹¹)
    // ë§Œì•½ usedEvents.length > cycle ì´ë©´ ì´ë¯¸ í• ë‹¹ëœ ê²ƒ.
    // ë§Œì•½ usedEvents.length <= cycle ì´ë©´ ìƒˆë¡œ í• ë‹¹í•´ì•¼ í•¨.

    // [ë³´ì •] í•˜ë“œ ë¦¬ì…‹ ì‹œ usedEventsë„ ì´ˆê¸°í™”í•´ì•¼ í•¨ (triggerReset('hard')ì—ì„œ ì²˜ë¦¬ í•„ìš”)

    if(usedEvents.length > cycle) {
        // ì´ë¯¸ í• ë‹¹ë¨
        gameState.currentEventDungeon = usedEvents[cycle];
    } else {
        // ìƒˆë¡œ í• ë‹¹
        let available = ALL_EVENTS.filter(e => !usedEvents.includes(e));
        if(available.length > 0) {
            let pick = available[Math.floor(Math.random() * available.length)];
            usedEvents.push(pick);
            localStorage.setItem('turnRpgUsedEvents', JSON.stringify(usedEvents));
            gameState.currentEventDungeon = pick;
        } else {
            gameState.currentEventDungeon = null; // ë‚¨ì€ ê²Œ ì—†ìŒ
        }
    }
}

function initArtifactsWithNGPlus() {
    // ê¸°ë³¸ ìœ ë¬¼ ëª©ë¡ìœ¼ë¡œ ë³µêµ¬
    ARTIFACTS = JSON.parse(JSON.stringify(BASE_ARTIFACTS));

    // í´ë¦¬ì–´ ê¸°ë¡ í™•ì¸
    const clears = getClearHistory(); // ['zeke', 'luna', ...]

    // 1. ê³µí†µ ìœ ë¬¼ ì¶”ê°€ (100% í™•ë¥ )
    if(clears.length > 0) {
        clears.forEach(char => {
            if(NEW_ARTIFACTS[char]) {
                // ì¤‘ë³µ ë°©ì§€ ì²´í¬ (í˜¹ì‹œ ëª¨ë¥´ë‹ˆ)
                if(!ARTIFACTS.find(a => a.id === NEW_ARTIFACTS[char].id)) {
                    ARTIFACTS.push(NEW_ARTIFACTS[char]);
                }
            }
        });

        // 2. ì „ì„¤ ìœ ë¬¼ ê°•í™” (í´ë¦¬ì–´ ì‹œ 100% í™•ë¥ ë¡œ ê°•í™”)
        clears.forEach(char => {
            upgradeLegendaryArtifact(char);
        });
    }

    // 3. ë³´ìŠ¤ ë“œë ìœ ë¬¼ í•´ê¸ˆ ëª©ë¡ ì¶”ê°€ (ë¦¬ë¡¤ í’€ì— ì¶”ê°€) - í´ë¦¬ì–´ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ ì ìš©
    let bossUnlocks = getBossArtifactUnlocks();
    bossUnlocks.forEach(id => {
        // BOSS_DROP_ARTIFACTSì—ì„œ ì°¾ì•„ì„œ ì¶”ê°€
        let drop = null;
        for(let k in BOSS_DROP_ARTIFACTS) {
            if(BOSS_DROP_ARTIFACTS[k].id === id) drop = BOSS_DROP_ARTIFACTS[k];
        }
        if(drop && !ARTIFACTS.find(a => a.id === drop.id)) {
            ARTIFACTS.push(drop);
        }
    });
}

function getBossArtifactUnlocks() {
    let unlocks = localStorage.getItem('turnRpgBossDrops');
    return unlocks ? JSON.parse(unlocks) : [];
}

function unlockBossArtifact(id) {
    let unlocks = getBossArtifactUnlocks();
    if(!unlocks.includes(id)) {
        unlocks.push(id);
        localStorage.setItem('turnRpgBossDrops', JSON.stringify(unlocks));
    }
}

function upgradeLegendaryArtifact(char) {
    // ì§€í¬ -> í™©ê¸ˆì˜íƒœì–‘
    if(char === 'zeke') {
        let art = ARTIFACTS.find(a => a.id === 'golden_sun');
        if(art) {
            art.name = "ì§„: í™©ê¸ˆì˜ íƒœì–‘";
            art.desc = "ê³µ/ë§ˆê³µ +50%, ë§ˆë²•ë°©ì–´ -30%";
            art.val = 0.50; // recalcAllStatsì—ì„œ ë³„ë„ ì²˜ë¦¬ í•„ìš”í•˜ì§€ë§Œ valë„ ì—…ë°ì´íŠ¸
            art.effect = 'golden_sun_legend'; // íš¨ê³¼ ID ë³€ê²½
            art.rarity = 'legend';
        }
    }
    // ë£¨ë‚˜ -> ë²¨ì œë·”íŠ¸
    if(char === 'luna') {
        let art = ARTIFACTS.find(a => a.id === 'beelzebub');
        if(art) {
            art.name = "ì§„: ë§ˆì‹ ê¸° ë²¨ì œë·”íŠ¸";
            art.desc = "ê³µê²© +60% / ì¹˜ëª…í”¼í•´ +70%, ë°©ì–´ -30%";
            art.val = 0.60;
            art.effect = 'beelzebub_legend';
            art.rarity = 'legend';
        }
    }
    // ììŠ¤ë¯¼ -> ì•„ì´ë¦¬ìŠ¤
    if(char === 'jasmine') {
        let art = ARTIFACTS.find(a => a.id === 'iris');
        if(art) {
            art.name = "ì§„: ì‹ ê¸° ì•„ì´ë¦¬ìŠ¤";
            art.desc = "ë§ˆê³µ/ë§ˆë°© +70%";
            art.val = 0.70;
            art.effect = 'iris_legend';
            art.rarity = 'legend';
        }
    }
    // ì—¬ì™• -> ë¡œì—´í¬ë¼ìš´
    if(char === 'queen') {
        let art = ARTIFACTS.find(a => a.id === 'royal_crown');
        if(art) {
            art.name = "ì§„: ë¡œì—´ í¬ë¼ìš´";
            art.desc = "ì˜¬ìŠ¤íƒ¯ +30% (ì—¬ì™•: ì‹œì‘ì‹œ ì¥ë¯¸+10)";
            art.val = 0.30;
            art.effect = 'royal_crown_legend';
            art.rarity = 'legend';
        }
    }
    // ë£¨ë¯¸ -> ìˆ˜í˜¸ì²œì‚¬ì˜ ê¹ƒí„¸
    if(char === 'rumi') {
        let art = ARTIFACTS.find(a => a.id === 'guardian_angel');
        if(art) {
            art.name = "ì§„: ìˆ˜í˜¸ì²œì‚¬ì˜ ê¹ƒí„¸";
            art.desc = "ì‚¬ë§ ì‹œ 1íšŒ ë¶€í™œ (HP 100%)";
            art.val = 1.0;
            art.effect = 'guardian_angel_legend';
            art.rarity = 'legend';
        }
    }
}

function getClearHistory() {
    let history = localStorage.getItem('turnRpgClears');
    return history ? JSON.parse(history) : [];
}

function getCycleCount() {
    let cycle = localStorage.getItem('turnRpgCycle');
    return cycle ? parseInt(cycle) : 0;
}

function incrementCycle() {
    let cycle = getCycleCount();
    localStorage.setItem('turnRpgCycle', cycle + 1);
}

function getMaxLevel() {
    return 25 + getCycleCount();
}

function saveClear(charKey) {
    let history = getClearHistory();
    if(!history.includes(charKey)) {
        history.push(charKey);
        localStorage.setItem('turnRpgClears', JSON.stringify(history));
    }
}

function recalcAllStats() {
    if(!player || !player.baseStats) return;

    let growth = 1.0 + (player.level - 1) * 0.1;
    
    // Base Calculation
    let baseMaxHp = Math.floor(player.baseStats.hp * growth);
    let baseMaxMp = player.fixedMp ? player.baseStats.mp : Math.floor(player.baseStats.mp * growth);
    let baseAtk = Math.floor(player.baseStats.atk * growth);
    let baseMatk = Math.floor(player.baseStats.matk * growth);
    let baseDef = Math.floor(player.baseStats.def * growth);
    let baseMdef = Math.floor(player.baseStats.mdef * growth);

    // Equipments
    for(let i=0; i<gameState.equipWeapon; i++) {
        let s = EQUIP_STATS[player.charKey].weapon[i];
        baseAtk += s.atk;
        baseMatk += s.matk;
    }
    for(let i=0; i<gameState.equipArmor; i++) {
        let s = EQUIP_STATS[player.charKey].armor[i];
        baseDef += s.def;
        baseMdef += s.mdef;
    }

    player.baseCrit = CHAR_DATA[player.charKey].baseCrit;
    player.baseEva = CHAR_DATA[player.charKey].baseEva;
    player.baseCritDmg = CHAR_DATA[player.charKey].baseCritDmg;

    // ëŒ€í˜„ì íˆë“  ê¸°ë¯¹
    if(player.charKey === 'rumi') {
        player.baseCrit += (player.level - 1) * 0.01;
    }
    // ë£¨ë‚˜ íˆë“  íŒ¨ì‹œë¸Œ
    if(player.charKey === 'luna') {
        player.baseCritDmg += (player.level - 1) * 0.01;
    }

    // Additive Modifiers
    let hpPer = 0.0, mpPer = 0.0, atkPer = 0.0, matkPer = 0.0, defPer = 0.0, mdefPer = 0.0;

    // Artifacts
    player.artifacts.forEach(art => {
        if(art.effect === 'stat_hp') hpPer += art.val;
        if(art.effect === 'stat_mp') mpPer += art.val;
        if(art.effect === 'stat_atk') atkPer += art.val;
        if(art.effect === 'stat_matk') matkPer += art.val;
        if(art.effect === 'stat_def') defPer += art.val;
        if(art.effect === 'stat_mdef') mdefPer += art.val;
        
        if(art.effect === 'stat_crit') player.baseCrit += art.val;
        if(art.effect === 'stat_eva') player.baseEva += art.val;

        if(art.effect === 'stat_def_mdef') { defPer += art.val; mdefPer += art.val; }
        if(art.effect === 'crit_critdmg') { player.baseCrit += 0.1; player.baseCritDmg += 0.3; }
        if(art.effect === 'dark_pendant') { player.baseCrit += 0.1; player.baseCritDmg += 1.0; }
        if(art.effect === 'matk_mp') { matkPer += art.val; mpPer += art.val; }
        if(art.effect === 'atk_matk') { atkPer += art.val; matkPer += art.val; }
        if(art.effect === 'atk_hp') { atkPer += art.val; hpPer += art.val; }
        
        if(art.effect === 'dragon_heart') { hpPer += 0.4; atkPer += 0.2; }
        if(art.effect === 'ancient_book') { mpPer += 0.4; matkPer += 0.2; }

        if(art.effect === 'golden_sun') { atkPer += 0.30; matkPer += 0.30; mdefPer -= 0.2; }
        if(art.effect === 'golden_sun_legend') { atkPer += 0.50; matkPer += 0.50; mdefPer -= 0.3; }

        if(art.effect === 'beelzebub') { atkPer += 0.5; defPer -= 0.3; player.baseCritDmg += 0.5; }
        if(art.effect === 'beelzebub_legend') { atkPer += 0.6; defPer -= 0.3; player.baseCritDmg += 0.7; }

        if(art.effect === 'iris') { matkPer += 0.5; mdefPer += 0.5; }
        if(art.effect === 'iris_legend') { matkPer += 0.7; mdefPer += 0.7; }

        if(art.effect === 'all_stat') { hpPer+=0.2; mpPer+=0.2; atkPer+=0.2; matkPer+=0.2; defPer+=0.2; mdefPer+=0.2; }
        if(art.effect === 'royal_crown_legend') { hpPer+=0.3; mpPer+=0.3; atkPer+=0.3; matkPer+=0.3; defPer+=0.3; mdefPer+=0.3; }

        if(art.effect === 'blood_pact') { hpPer -= 0.2; atkPer += 0.2; matkPer += 0.2; }
        if(art.effect === 'reckless') { defPer -= 0.3; player.baseCritDmg += art.val; }

        // New Boss Artifacts
        if(art.effect === 'hestia') {
            hpPer += 1.0; mpPer += 1.0; atkPer += 1.0; matkPer += 1.0; defPer += 1.0; mdefPer += 1.0;
        }
        if(art.effect === 'dream_choco') {
            atkPer += 0.6; matkPer += 0.6;
        }
        if(art.effect === 'blue_moon') {
            mpPer += 0.2;
        }
        if(art.effect === 'heart_ice') {
             // Will be applied in dynamic section if HP < 50%
        }
    });

    // Buffs (Battle) - ì´ì œ í•©ì—°ì‚°ìœ¼ë¡œ ê³„ì‚° ë° ìƒíƒœì°½ ë°˜ì˜
    if(buffs && buffs.player) {
        if(buffs.player.demonEyeTurns > 0) {
            atkPer += 1.0;
            matkPer += 1.0;
        }
        if(buffs.player.royalBloomTurns > 0) { atkPer += 0.5; matkPer += 0.5; }

        // Sage Forms
        if(buffs.player.sageForm === 'star') { defPer += 0.5; mdefPer += 0.5; }
        else if(buffs.player.sageForm === 'moon') { matkPer += 0.5; atkPer -= 0.5; }
        else if(buffs.player.sageForm === 'sun') { atkPer += 1.0; defPer -= 0.5; mdefPer -= 0.5; }

        if(buffs.player.milkshakeTurns > 0) { defPer += 0.3; mdefPer += 0.3; }

        // Other Buffs
        if(buffs.player.goddessTurns > 0) { atkPer += 1.0; matkPer += 1.0; defPer += 1.0; mdefPer += 1.0; }
        if(buffs.player.goddessBlessing) { atkPer += 0.5; matkPer += 0.5; }
        if(buffs.player.undyingPowerTurns > 0) { atkPer += 1.0; }
        if(buffs.player.divineTurns > 0) { defPer += 0.3; mdefPer += 0.3; }
        if(buffs.player.castleDef100) { defPer += 1.0; }
    }

    // Apply Multipliers
    let finalMaxHp = Math.floor(baseMaxHp * (1 + hpPer));
    let finalMaxMp = Math.floor(baseMaxMp * (1 + mpPer));

    // Dynamic checks dependent on HP (Boss Artifacts & Passives)
    if(player.hp) {
         let ratio = player.hp / finalMaxHp;

         // Zeke Passive
         if(player.charKey === 'zeke') {
             if(ratio < 0.25) { atkPer += 0.3; defPer += 0.3; }
             else if(ratio < 0.5) { atkPer += 0.15; defPer += 0.15; }
         }

         // Heart of Ice (Ice Heart)
         if(ratio < 0.5 && hasArtifact('heart_ice')) {
             defPer += 1.0;
             mdefPer += 1.0;
         }
    }

    let finalAtk = Math.floor(baseAtk * (1 + atkPer));
    let finalMatk = Math.floor(baseMatk * (1 + matkPer));

    // ë©”ë””í…Œì´ì…˜ ë§ˆê³µ 50% ê°ì†Œ ë°˜ì˜ (UI í‘œê¸°ìš©)
    if(buffs && buffs.player && buffs.player.medi) {
        finalMatk = Math.floor(finalMatk * 0.5);
    }

    let finalDef = Math.floor(baseDef * (1 + defPer));
    let finalMdef = Math.floor(baseMdef * (1 + mdefPer));

    // ë°©ì–´ë ¥ì´ 0 ë¯¸ë§Œìœ¼ë¡œ ë‚´ë ¤ê°€ì§€ ì•Šë„ë¡ ë³´ì • (ë²¨ì œë·”íŠ¸ ë“±)
    finalDef = Math.max(0, finalDef);
    finalMdef = Math.max(0, finalMdef);

    if(buffs && buffs.player && buffs.player.defZero) {
        finalDef = 0;
    }

    player.maxHp = finalMaxHp;
    player.maxMp = finalMaxMp;
    player.atk = finalAtk;
    player.matk = finalMatk;
    player.def = finalDef;
    player.mdef = finalMdef;
    
    player.hp = Math.min(player.hp, player.maxHp);
    player.mp = Math.min(player.mp, player.maxMp);
}

function updateInfo() {
    if(!player || !player.name) return;
    document.getElementById('char-name').innerText = player.name;
    document.getElementById('char-lvl').innerText = `Lv.${player.level} / ${getMaxLevel()}`;
    document.getElementById('ui-gold').innerText = gameState.gold;
    document.getElementById('ui-atk').innerText = player.atk;
    document.getElementById('ui-def').innerText = player.def;
    document.getElementById('ui-matk').innerText = player.matk;
    document.getElementById('ui-mdef').innerText = player.mdef;

    let hpPer = player.maxHp ? (player.hp / player.maxHp) * 100 : 0;
    let mpPer = player.maxMp ? (player.mp / player.maxMp) * 100 : 0;
    document.getElementById('hp-bar').style.width = `${Math.max(0, hpPer)}%`;
    document.getElementById('mp-bar').style.width = `${Math.max(0, mpPer)}%`;
    document.getElementById('hp-text').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
    document.getElementById('mp-text').innerText = `${Math.floor(player.mp)}/${player.maxMp}`;

    document.getElementById('vis-p-name').innerText = player.name;
    document.getElementById('vis-p-hp').style.width = `${Math.max(0, hpPer)}%`;
    const pImgBox = document.getElementById('player-img');
    const emojis = { 'luna':'ğŸŒ™', 'zeke':'ğŸ›¡ï¸', 'jasmine':'â˜€ï¸', 'queen':'ğŸŒ¹', 'rumi':'âœ¨' };
    pImgBox.innerHTML = `<img src="${player.charKey}.png" onerror="this.style.display='none'; this.parentNode.innerText='${emojis[player.charKey]}'">`;

    const artBox = document.getElementById('artifact-list');
    if(player.artifacts.length > 0) {
        let artNames = player.artifacts.map(a => {
            let color = '#ffd700';
            if(a.rarity === 'epic') color = '#e040fb';
            if(a.rarity === 'legend') color = '#ff5252';
            return `<span onclick="myAlert('[${a.name}]\\n${a.desc}')" style="cursor:pointer; text-decoration:underline; margin-right:5px; color:${color}">${a.name}</span>`;
        }).join(" ");
        artBox.innerHTML = `ìœ ë¬¼(í„°ì¹˜): ${artNames}`;
    } else {
        artBox.innerText = "ìœ ë¬¼: ì—†ìŒ";
    }

    const extraUI = document.getElementById('extra-ui');
    if(player.charKey === 'queen') {
        extraUI.style.display = 'block';
        extraUI.style.color = '#f06292';
        extraUI.innerText = `ğŸŒ¹ ì¥ë¯¸ ìŠ¤íƒ: ${roseStack} (ìµœëŒ€ 15)`;
    } else if(player.charKey === 'zeke') {
        extraUI.style.display = 'block';
        extraUI.style.color = '#fff59d';
        let stack = buffs.player.divineStack || 0;
        let enchantText = buffs.player.enchantTurns > 0 ? ` | ğŸ”¥ ì¸ì±ˆíŠ¸: ${buffs.player.enchantTurns}í„´` : "";
        extraUI.innerText = `ğŸ›¡ï¸ ë””ë°”ì¸ ìŠ¤íƒ: ${stack}${enchantText}`;
    } else if(player.charKey === 'rumi') {
        extraUI.style.display = 'block';
        extraUI.style.color = '#81d4fa';
        let formName = "ì—†ìŒ";
        if(buffs.player && buffs.player.sageForm === 'star') formName = "â­ ë³„";
        if(buffs.player && buffs.player.sageForm === 'moon') formName = "ğŸŒ™ ë‹¬";
        if(buffs.player && buffs.player.sageForm === 'sun') formName = "â˜€ï¸ íƒœì–‘";
        let milkshakeText = buffs.player.milkshakeTurns > 0 ? ` | ğŸ¥¤ì‰ì´í¬: ${buffs.player.milkshakeTurns}í„´` : "";
        extraUI.innerText = `ğŸ’ ê¿ˆì˜ ê²°ì •: ${player.dreamCrystals} | í˜•íƒœ: ${formName}${milkshakeText}`;
    } else if(player.charKey === 'luna') {
        extraUI.style.display = 'block';
        extraUI.style.color = '#b39ddb';
        let darkStack = buffs.enemy && buffs.enemy.darkness ? buffs.enemy.darkness : 0;
        extraUI.innerText = `ğŸ’€ ì•”í‘ ìŠ¤íƒ: ${darkStack} (ìµœëŒ€ 5)`;
    } else if(player.charKey === 'jasmine') {
        extraUI.style.display = 'block';
        extraUI.style.color = '#fff59d';
        let stack = buffs.player.absoluteStack || 0;
        extraUI.innerText = `â˜€ï¸ ì•±ì†”ë£¨íŠ¸ ìŠ¤íƒ: ${stack} (ìµœëŒ€ 5)`;
    } else {
        extraUI.style.display = 'none';
    }
}

function openShop() {
    if(!player || !player.name) return myAlert("ìºë¦­í„° ì„ íƒ í•„ìš”");
    document.getElementById('shop-modal').classList.add('active');
    document.getElementById('shop-gold').innerText = gameState.gold;

    const manaCosts = [1000, 2000, 3000, 4000];
    let costText = gameState.manaLevel >= 4 ? "MAX" : `${manaCosts[gameState.manaLevel]} G`;
    document.getElementById('mana-cost').innerText = costText;

    const nextW = gameState.equipWeapon;
    const nextA = gameState.equipArmor;

    let wText = "MAX";
    if(nextW < 7) {
        let stats = EQUIP_STATS[player.charKey].weapon[nextW];
        wText = `${EQUIP_COSTS[nextW]} G (ATK+${stats.atk}/MATK+${stats.matk})`;
    }
    document.getElementById('weapon-cost').innerText = wText;

    let aText = "MAX";
    if(nextA < 7) {
        let stats = EQUIP_STATS[player.charKey].armor[nextA];
        aText = `${EQUIP_COSTS[nextA]} G (DEF+${stats.def}/MDEF+${stats.mdef})`;
    }
    document.getElementById('armor-cost').innerText = aText;

    const list = document.getElementById('skill-shop-list');
    list.innerHTML = "";

    for(let key in player.skills) {
        if (key === 'basic') continue;
        const sk = player.skills[key];
        const learned = gameState.learnedSkills.includes(key);
        const btn = document.createElement('button');

        let typeStr = "";
        if(sk.type === 'phy') typeStr = "<span style='color:#ef9a9a; font-size:0.7rem;'>[ë¬¼ë¦¬]</span> ";
        if(sk.type === 'mag') typeStr = "<span style='color:#90caf9; font-size:0.7rem;'>[ë§ˆë²•]</span> ";

        btn.innerHTML = `<span style="color:${learned ? '#4caf50':'#fff'}">${typeStr}${sk.name}</span>
                         <span style="font-size:0.7rem; display:block;">${sk.desc}</span>
                         <span style="font-size:0.7rem; color:#ffd700;">${learned ? 'ìŠµë“ì™„ë£Œ' : sk.price + ' G'}</span>`;

        if(!learned) {
            btn.onclick = () => buySkill(key, sk.price);
        } else {
            btn.disabled = true;
            btn.style.opacity = 0.7;
        }
        list.appendChild(btn);
    }
}

function closeShop() {
    document.getElementById('shop-modal').classList.remove('active');
    updateInfo();
}

function upgradeMana() {
    if(gameState.manaLevel >= 4) return;
    const costs = [1000, 2000, 3000, 4000];
    const cost = costs[gameState.manaLevel];
    if(gameState.gold >= cost) {
        gameState.gold -= cost;
        gameState.manaLevel++;
        const regenMap = { 'ë£¨ë‚˜':[10,13,16,20], 'ì§€í¬':[10,13,16,20], 'ììŠ¤ë¯¼':[15,20,25,30], 'ì—¬ì™•':[12,14,16,20], 'ë£¨ë¯¸':[10,15,20,25] };
        const arr = regenMap[player.name];
        player.mpRegen = arr[gameState.manaLevel-1] || arr[arr.length-1];
        openShop();
    }
}

function buyEquip(type) {
    if(!player) return;
    let currentTier = type === 'weapon' ? gameState.equipWeapon : gameState.equipArmor;
    if(currentTier >= 7) return;
    let cost = EQUIP_COSTS[currentTier];
    if(gameState.gold >= cost) {
        gameState.gold -= cost;
        if(type === 'weapon') gameState.equipWeapon++;
        else gameState.equipArmor++;
        recalcAllStats(); 
        openShop();
    }
}

function buySkill(key, price) {
    if(gameState.learnedSkills.includes(key)) return;
    if(gameState.gold >= price) {
        gameState.gold -= price;
        gameState.learnedSkills.push(key);
        openShop();
    } else {
        myAlert("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
    }
}

function healFull() {
    if(gameState.gold >= 50) {
        gameState.gold -= 50;
        player.hp = player.maxHp;
        player.mp = player.maxMp;
        openShop();
    }
}

function resetAllArtifacts(highQuality=false) {
    if(player.artifacts.length === 0) return myAlert("ì´ˆê¸°í™”í•  ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.");
    let cost = highQuality ? 100000 : 20000;
    if(gameState.gold < cost) return myAlert(`ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. (í•„ìš”: ${cost} G)`);

    let msg = highQuality
        ? `[ê³ ê·€í•œ ì‹œê°„ì˜ ì—­í–‰] ë³´ìœ í•œ ëª¨ë“  ìœ ë¬¼ì„ ë¦¬ì…‹í•˜ê³  ë‹¤ì‹œ ë½‘ìŠµë‹ˆë‹¤.\n(ì—í”½/ì „ì„¤ í™•ë¥  3ë°°)\në¹„ìš©: ${cost} G\n\nì •ë§ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
        : `[ì£¼ì˜] ë³´ìœ í•œ ëª¨ë“  ìœ ë¬¼ì„ íŒŒê´´í•˜ê³  ë‹¤ì‹œ ë½‘ìŠµë‹ˆë‹¤.\në¹„ìš©: ${cost} G\n\nì •ë§ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;

    if(confirm(msg)) {
        gameState.gold -= cost;
        let count = player.artifacts.length;
        player.artifacts = []; 
        for(let i=0; i<count; i++) rollArtifact(true, highQuality);
        recalcAllStats();
        updateInfo();
        if(highQuality) openShop(); // Refresh shop gold display
        myAlert(`ì‹œê°„ì„ ë˜ëŒë ¸ìŠµë‹ˆë‹¤!\nìƒˆë¡œìš´ ìœ ë¬¼ ${count}ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤.`);
    }
}

function rollArtifact(silent=false, highQuality=false) {
    // 1. NG+ ë° ë³´ìŠ¤ í•´ê¸ˆ ìœ ë¬¼ì„ í¬í•¨í•œ ì „ì²´ ARTIFACTS ëª©ë¡ ê°±ì‹ 
    // (ë³´ìŠ¤ ë“œë ìœ ë¬¼ì´ í•´ê¸ˆë˜ì—ˆëŠ”ë° ARTIFACTSì— ì—†ëŠ” ê²½ìš°ë¥¼ ë°©ì§€)
    let bossUnlocks = getBossArtifactUnlocks();
    bossUnlocks.forEach(id => {
         let drop = null;
         for(let k in BOSS_DROP_ARTIFACTS) {
             if(BOSS_DROP_ARTIFACTS[k].id === id) drop = BOSS_DROP_ARTIFACTS[k];
         }
         if(drop && !ARTIFACTS.find(a => a.id === drop.id)) {
             ARTIFACTS.push(drop);
         }
    });

    let available = ARTIFACTS.filter(a => !hasArtifact(a.id));
    if(available.length === 0) return;

    let pick;
    if(highQuality) {
        // Weighted random for High Quality
        let weighted = [];
        available.forEach(a => {
            let w = 1;
            if(a.rarity === 'epic') w = 3;
            if(a.rarity === 'legend') w = 3;
            for(let i=0; i<w; i++) weighted.push(a);
        });
        pick = weighted[Math.floor(Math.random() * weighted.length)];
    } else {
        // Uniform random
        pick = available[Math.floor(Math.random() * available.length)];
    }

    player.artifacts.push(pick);
    if(!silent) {
        if(pick.rarity === 'epic') {
            log(`<b style="color:#e040fb; font-size:1.1rem;">[ëŒ€ë°•!] ì—í”½ ìœ ë¬¼ ë°œê²¬! [${pick.name}]</b>`, 'rose');
            myAlert(`ì¶•í•˜í•©ë‹ˆë‹¤!\nì „ì„¤ì ì¸ ìœ ë¬¼ [${pick.name}]ì„(ë¥¼) ì†ì— ë„£ì—ˆìŠµë‹ˆë‹¤!`);
        } else if(pick.rarity === 'legend') {
             log(`<b style="color:#ff5252; font-size:1.1rem;">[ì „ì„¤!] ì‹ í™”ê¸‰ ìœ ë¬¼ ë°œê²¬! [${pick.name}]</b>`, 'dmg');
             myAlert(`ë¯¿ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!\nì‹ í™” ì† ìœ ë¬¼ [${pick.name}]ì„(ë¥¼) ì†ì— ë„£ì—ˆìŠµë‹ˆë‹¤!`);
        } else {
            log(`<span style="color:#ffd700">ìœ ë¬¼ íšë“! [${pick.name}]: ${pick.desc}</span>`, 'info');
        }
    }
    recalcAllStats();
}

function checkLevelUp() {
    let baseReq = 100 * player.level * (1 + player.level * 0.1);
    let nextExp = player.level >= 20 ? baseReq * 3 : baseReq;
    const maxLvl = getMaxLevel();

    if(player.exp >= nextExp && player.level < maxLvl) {
        player.level++;
        player.exp = 0;
        recalcAllStats(); 
        log(`ë ˆë²¨ ì—…! Lv.${player.level}`, 'heal');
        if([5, 10, 15, 20, 25].includes(player.level)) {
            rollArtifact();
        }
    }
}

function enterDungeon(tier) {
    const candidates = ENEMIES.filter(e => e.tier === tier);
    if(candidates.length === 0) return myAlert("ëª¬ìŠ¤í„° ë°ì´í„° ì˜¤ë¥˜");
    startBattle(candidates[Math.floor(Math.random() * candidates.length)]);
}

function enterEvent() {
    const candidates = ENEMIES.filter(e => e.tier === 4);
    if(candidates.length === 0) return myAlert("ì´ë²¤íŠ¸ ë³´ìŠ¤ ì˜¤ë¥˜");
    startBattle(candidates[Math.floor(Math.random() * candidates.length)]);
}

function enterEventDungeon(type) {
    const candidates = ENEMIES.filter(e => e.tier === type);
    if(candidates.length === 0) return myAlert("ë˜ì „ ë°ì´í„° ì˜¤ë¥˜");
    startBattle(candidates[Math.floor(Math.random() * candidates.length)]);
}

function enterHiddenDungeon() {
    // Hidden dungeon starts with Iris Light
    const boss = ENEMIES.find(e => e.ai === 'iris_light');
    if(!boss) return myAlert("íˆë“  ë³´ìŠ¤ ë°ì´í„° ì˜¤ë¥˜");
    startBattle(boss);
}

function updateBattleUI() {
    updateInfo(); 
    if (currentEnemy) {
        let hpPer = (currentEnemy.hp / currentEnemy.maxHp) * 100;
        document.getElementById('vis-e-hp').style.width = `${Math.max(0, hpPer)}%`;
    }
}

function startBattle(mobData) {
    if(!player || !player.name) return myAlert("ìºë¦­í„° ì„ íƒ í•„ìš”");
    
    document.getElementById('town-menu').style.display = 'none';
    document.getElementById('battle-menu').style.display = 'flex';
    
    const stage = document.getElementById('main-stage');
    stage.classList.remove('town-mode');
    stage.classList.add('battle-mode'); 

    currentEnemy = JSON.parse(JSON.stringify(mobData));

    // ë‹¤íšŒì°¨ ìŠ¤íƒ¯ ë³´ì • (ìµœëŒ€ 6íšŒì°¨/5ì‚¬ì´í´ ê¹Œì§€ë§Œ ì¦ê°€)
    let cycle = getCycleCount();
    if(cycle > 0) {
        let cappedCycle = Math.min(cycle, 5);
        let mult = 1 + (cappedCycle * 0.1);
        currentEnemy.hp = Math.floor(currentEnemy.hp * mult);
        currentEnemy.atk = Math.floor(currentEnemy.atk * mult);
        currentEnemy.matk = Math.floor(currentEnemy.matk * mult);
        currentEnemy.def = Math.floor(currentEnemy.def * mult);
        currentEnemy.mdef = Math.floor(currentEnemy.mdef * mult);
    }

    currentEnemy.maxHp = currentEnemy.hp || 1;

    // íˆë“  ë³´ìŠ¤ ì´ˆê¸°í™” (Tag Team ë°ì´í„° ì¤€ë¹„)
    if(mobData.tier === 'hidden') {
         const light = ENEMIES.find(e => e.ai === 'iris_light');
         const curse = ENEMIES.find(e => e.ai === 'iris_curse');

         // ë³´ì • ì ìš©ëœ ìŠ¤íƒ¯ ê³„ì‚°ì„ ìœ„í•´ ì„ì‹œ ê°ì²´ ìƒì„±
         let lightStat = { atk: light.atk, matk: light.matk, def: light.def, mdef: light.mdef };
         let curseStat = { atk: curse.atk, matk: curse.matk, def: curse.def, mdef: curse.mdef };

         let cycle = getCycleCount();
         if(cycle > 0) {
             let cappedCycle = Math.min(cycle, 5);
             let mult = 1 + (cappedCycle * 0.1);
             lightStat.atk = Math.floor(lightStat.atk * mult);
             lightStat.matk = Math.floor(lightStat.matk * mult);
             lightStat.def = Math.floor(lightStat.def * mult);
             lightStat.mdef = Math.floor(lightStat.mdef * mult);

             curseStat.atk = Math.floor(curseStat.atk * mult);
             curseStat.matk = Math.floor(curseStat.matk * mult);
             curseStat.def = Math.floor(curseStat.def * mult);
             curseStat.mdef = Math.floor(curseStat.mdef * mult);
         }

         gameState.hiddenBossReserve = {
             maxHp: currentEnemy.maxHp,
             iris_light: currentEnemy.maxHp,
             iris_curse: currentEnemy.maxHp,
             scaledStats: {
                 light: lightStat,
                 curse: curseStat
             }
         };
         gameState.hiddenBossDead = false;
         log(`<b style="color:#ffd700">ë¹›ê³¼ ì–´ë‘ ì˜ íšŒë‘ì— ì…ì¥í–ˆìŠµë‹ˆë‹¤. (í˜ì´ì¦ˆ ë³€í™˜ ë³´ìŠ¤)</b>`, 'info');
    }

    document.getElementById('vis-e-name').innerText = currentEnemy.name;
    const eImgBox = document.getElementById('enemy-img');
    
    let imgSrc = currentEnemy.img ? currentEnemy.img : `${currentEnemy.name}.png`;
    eImgBox.innerHTML = `<img src="${imgSrc}" onerror="this.style.display='none'; this.parentNode.innerText='ğŸ’€'">`;

    document.getElementById('log-box').innerHTML = "";

    let startMp = player.maxMp ? Math.floor(player.maxMp / 2) : 0;
    if(hasArtifact('start_mp')) startMp += 30;
    if(hasArtifact('blue_moon')) startMp += 100;
    
    player.mp = Math.min(player.maxMp, startMp);
    turnCount = 1;
    // ë£¨ë¯¸ ì‹ ê·œ ìŠ¤í‚¬ ê´€ë ¨ ë²„í”„ ì´ˆê¸°í™” ì¶”ê°€ (chargingMilkyway, milkshakeTurns)
    buffs = { player: { castleStack: 0, dodgeCount: 0, absoluteStack: 0, divineStack: 0, moonUltStack: 0, chargingMilkyway: false, milkshakeTurns: 0 }, enemy: {} };
    roseStack = 0; 

    if(hasArtifact('demon_eye')) {
        buffs.player.demonEyeTurns = 5;
        log("[ë§ˆì•ˆ] ë°œë™! 5í„´ê°„ ê³µê²©ë ¥/ë§ˆë²•ê³µê²©ë ¥ ëŒ€í­ ì¦ê°€.", 'rose');
    }
    
    if(player.charKey === 'rumi') {
        player.dreamCrystals = 5;
        // ì „íˆ¬ ì‹œì‘ì‹œ í˜•íƒœ ì´ˆê¸°í™”
        delete buffs.player.sageForm;
    }

    if(player.charKey === 'queen') {
        if(hasArtifact('royal_crown')) {
            roseStack = 5;
            log("ë¡œì—´ í¬ë¼ìš´ì˜ íš¨ê³¼ë¡œ ì¥ë¯¸ 5ì†¡ì´ë¥¼ ê°€ì§€ê³  ì‹œì‘í•©ë‹ˆë‹¤!", 'rose');
        }
        if(hasArtifact('royal_crown_legend')) {
            roseStack = 10;
            log("ì „ì„¤ì˜ ë¡œì—´ í¬ë¼ìš´ íš¨ê³¼ë¡œ ì¥ë¯¸ 10ì†¡ì´ë¥¼ ê°€ì§€ê³  ì‹œì‘í•©ë‹ˆë‹¤!", 'rose');
        }
    }

    // ëŒ€í˜„ì ìŠ¤íƒ¯ ì¬ê³„ì‚° (í˜•íƒœ ì´ˆê¸°í™” ë°˜ì˜)
    recalcAllStats();

    updateBattleUI();
    createBattleButtons();
    log(`<b>${currentEnemy.name}</b>(ì´)ê°€ ë‚˜íƒ€ë‚¬ë‹¤!`, 'info');
}

function createBattleButtons() {
    const box = document.getElementById('action-btns');
    box.innerHTML = "";
    gameState.learnedSkills = gameState.learnedSkills || ['basic'];
    gameState.learnedSkills.forEach(key => {
        const sk = player.skills[key];
        if(!sk) return;
        const btn = document.createElement('button');
        let cls = 'btn-skill';
        if(sk.type === 'phy' || sk.type === 'mag') cls = 'btn-atk';
        if(sk.type === 'sup') cls = 'btn-def';
        if(sk.isUlt) cls = 'btn-ult';
        btn.className = cls;
        btn.innerHTML = `${sk.name}<span class="skill-sub">MP ${sk.cost}</span>`;
        btn.onclick = () => executeTurn(key);
        box.appendChild(btn);
    });
}
function executeTurn(skillKey) {
    if(!player || !currentEnemy) return;

    if(buffs.player.stun) {
        log("í–‰ë™ ë¶ˆê°€ ìƒíƒœì…ë‹ˆë‹¤!", 'dmg');
        if(!enemyTurn()) return loseBattle();
        endTurnPhase();
        return;
    }

    const skill = player.skills[skillKey];
    
    // ëŒ€í˜„ì í˜•íƒœ ë³€í™˜ ë¹„ìš© ë° ê²°ì • ì²´í¬
    if(skill.effect.startsWith('form_change_')) {
        if(skill.effect !== 'form_change_sun' && player.dreamCrystals < 1) { 
             if(player.dreamCrystals < 1) { log("ê¿ˆì˜ ê²°ì •ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!", 'info'); return; }
        }
        if(skill.effect === 'form_change_sun' && player.dreamCrystals < 1) { log("ê¿ˆì˜ ê²°ì •ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!", 'info'); return; }
        
        // ë¹„ìš© ì†Œëª¨
        if(skill.effect !== 'form_change_sun') player.dreamCrystals--; 
        if(skill.effect === 'form_change_sun') player.dreamCrystals--; 
    }

    // ì°¨ì§• ìŠ¤í‚¬ ì²˜ë¦¬
    if(skill.effect === 'charge_divine' || skill.effect === 'charge_milkyway') {
        let chargingFlag = skill.effect === 'charge_divine' ? 'charging' : 'chargingMilkyway';
        let chargeMsg = skill.effect === 'charge_divine' ? "í˜ì„ ëª¨ìœ¼ë©° ë°©ì–´ íƒœì„¸ë¥¼ ì·¨í•©ë‹ˆë‹¤." : "ë³„ë“¤ì˜ í˜ì„ ëª¨ìœ¼ê¸° ì‹œì‘í•©ë‹ˆë‹¤. (ì°¨ì§€/ë°©ì–´íƒœì„¸)";
        let chargeColor = skill.effect === 'charge_divine' ? 'holy' : 'star';

        if(!buffs.player[chargingFlag]) {
            if(player.mp < skill.cost) { log("ë§ˆë‚˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", 'info'); return; }
            player.mp -= skill.cost;
            buffs.player[chargingFlag] = true;
            buffs.player.guard = true; 
            log(`${skill.name}! ${chargeMsg}`, chargeColor);
            if(!enemyTurn()) return loseBattle();
            endTurnPhase();
            return;
        } else {
            delete buffs.player[chargingFlag];
            delete buffs.player.guard;
        }
    } else {
        if(player.mp < skill.cost) { log("ë§ˆë‚˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", 'info'); return; }
        player.mp -= skill.cost;
    }

    log(`<div class="log-turn">=== Turn ${turnCount} ===</div>`);

    let playerDefending = false;
    
    if(skill.effect === 'milkshake_heal') {
        let healAmount = Math.floor(player.maxHp * 0.3);
        player.hp = Math.min(player.maxHp, player.hp + healAmount);
        log(`ìŠ¤íƒ€íŒŒìš°ë” ë°€í¬ì‰ì´í¬! HP <span class="heal">${healAmount}</span> íšŒë³µ.`, 'heal');
    }

    // [FIX] ì„œí¬íŠ¸ ìŠ¤í‚¬ ì ìš© ì¡°ê±´ì— 'sage_moon_veil'ê³¼ 'sage_meteor' ì¶”ê°€
    // [FIX 9.4] 'reset_buff' (ì—¬ì‹  ê°•ë¦¼) ì¶”ê°€í•˜ì—¬ ê³µê²© í•¨ìˆ˜ í˜¸ì¶œí•˜ë„ë¡ ìœ ë„ (ìŠ¤í‚¬ íƒ€ì…ì´ supì´ë¼ì„œ applyPlayerSupport í˜¸ì¶œ í›„ playerDefending=true ë¨)
    // í•˜ì§€ë§Œ reset_buffëŠ” applyPlayerSupportì— ì—†ìœ¼ë¯€ë¡œ ì•„ë¬´ ì¼ë„ ì•ˆ í•¨.
    // playerDefending=true ë•Œë¬¸ì— ì•„ë˜ ê³µê²© ë¡œì§ ì§„ì… ëª»í•¨.
    // ê·¸ë˜ì„œ ì˜ˆì™¸ ë¦¬ìŠ¤íŠ¸ì— reset_buff ì¶”ê°€.
    if(skill.type === 'sup' || skill.effect === 'perfect_eva' || skill.effect === 'guard_70' || skill.effect === 'null_mag' || skill.effect === 'null_phy' || 
       skill.effect === 'evasion_50' || skill.effect === 'eva_buff' || skill.effect === 'crit_buff' || skill.effect === 'passive_boost' || 
       skill.effect.startsWith('form_change_') || skill.effect === 'sage_barrier' || skill.effect === 'milkshake_heal' ||
       skill.effect === 'sage_moon_veil' || skill.effect === 'sage_meteor' || skill.effect === 'royal_bloom' || skill.effect === 'reset_buff') { // <-- reset_buff ì¶”ê°€
        
        applyPlayerSupport(skill);
        
        if(skill.effect === 'stun_rose_3') {
             if(roseStack >= 3) {
                 roseStack -= 3;
                 buffs.enemy.stun = true;
                 log("ì¥ë¯¸ 3ê°œë¥¼ ì†Œëª¨í•˜ì—¬ ì ì„ ì••ë„í•©ë‹ˆë‹¤!", 'rose');
             } else {
                 log("ì¥ë¯¸ ìŠ¤íƒì´ ë¶€ì¡±í•˜ì—¬ ë°œë™ ì‹¤íŒ¨!", 'info');
             }
        }
        playerDefending = true;
    }

    if(buffs.enemy.counter && turnCount > buffs.enemy.counterTurn + 1) delete buffs.enemy.counter;

    let enemyAlive = true;
    
    // [FIX] ê³µê²© ìŠ¤í‚¬ ì¡°ê±´ì— 'sage_moon_veil'ê³¼ 'sage_meteor' ì˜ˆì™¸ ì¶”ê°€ (playerDefendingì´ trueì—¬ë„ ê³µê²© ì‹¤í–‰)
    // [FIX 9.4] reset_buff ì¶”ê°€ (ì´ë˜ì•¼ playerAttack í˜¸ì¶œë¨)
    if(!playerDefending || skill.effect === 'perfect_eva' || skill.effect === 'rose_2_self_stun' || 
       skill.effect === 'evasion_50' || skill.effect === 'eva_buff' || skill.effect === 'crit_buff' ||
       skill.effect === 'form_change_sun' || skill.effect === 'sage_dream_ult' ||
       skill.effect === 'sage_moon_veil' || skill.effect === 'sage_meteor' || skill.effect === 'reset_buff') { // <-- reset_buff ì¶”ê°€
        
        if(skill.effect === 'sage_dream_ult' || !skill.effect.startsWith('form_change_')) {
            document.getElementById('player-actor').classList.add('shake');
            setTimeout(()=> document.getElementById('player-actor').classList.remove('shake'), 250);
            enemyAlive = playerAttack(skill);
        }
    }

    let playerAlive = true;
    if(enemyAlive) {
        if(buffs.enemy.stun) {
            log(`${currentEnemy.name}ì€(ëŠ”) ê¸°ì ˆí•˜ì—¬ ì›€ì§ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`, 'info');
            delete buffs.enemy.stun;
        } else {
            document.getElementById('enemy-actor').classList.add('shake');
            setTimeout(()=> document.getElementById('enemy-actor').classList.remove('shake'), 250);
            
            playerAlive = enemyTurn();
        }
    }
    
    if(playerAlive && enemyAlive) endTurnPhase();
    else if(!enemyAlive) winBattle();
    else loseBattle();
}

function applyPlayerSupport(skill) {
    if(skill.effect === 'guard_70') buffs.player.guard_70 = true;
    if(skill.effect === 'null_mag') buffs.player.nullMag = true;
    if(skill.effect === 'null_phy') buffs.player.nullPhy = true;
    
    if(skill.effect === 'sage_barrier') {
        buffs.player.sageBarrier = true;
        let form = buffs.player.sageForm;
        log(`ìŠ¤íƒ€ ë°°ë¦¬ì–´! í”¼í•´ ${form==='star'?70:50}% ê°ì†Œ.`, 'star');
    }

    if(skill.effect.startsWith('form_change_')) {
        let type = skill.effect.split('_')[2]; 
        buffs.player.sageForm = type;
        buffs.player.formTurns = 3;
        recalcAllStats(); 
        let names = {'star':'ë³„', 'moon':'ë‹¬', 'sun':'íƒœì–‘'};
        log(`[${names[type]}ì˜ í˜•íƒœ]ë¡œ ë³€í™˜í–ˆìŠµë‹ˆë‹¤!`, 'star');
    }

    if(skill.effect === 'milkshake_heal') {
        if(buffs.player.sageForm === 'star') {
            buffs.player.milkshakeTurns = 10;
            log("ë³„ì˜ í˜•íƒœ ì¶”ê°€ íš¨ê³¼! 10í„´ê°„ ë°©ì–´ë ¥/ë§ˆë²•ë°©ì–´ë ¥ì´ 30% ì¦ê°€í•©ë‹ˆë‹¤.", 'star');
            recalcAllStats(); 
        }
    }

    if(skill.effect === 'evasion_50') {
        buffs.player.eva = (buffs.player.eva || 0) + 0.5;
        log("ì œë…¸ì‚¬ì´ë“œ ìŠ¤íƒ­! ì”ìƒìœ¼ë¡œ íšŒí”¼ìœ¨ì´ ê¸‰ì¦í•©ë‹ˆë‹¤.", 'info');
    }
    if(skill.effect === 'next_eva') buffs.player.nextEva = 0.5;

    if(skill.effect === 'perfect_eva') buffs.player.eva = (buffs.player.eva || 0) + 10.0; 
    
    if(skill.effect === 'eva_buff') {
        let val = skill.name === 'ë² ì¼ ì˜¤ë¸Œ ë‹¤í¬ë‹ˆìŠ¤' ? 0.4 : 0.2;
        buffs.player.veilVal = val;
        buffs.player.veilTurns = 3;
        buffs.player.eva = (buffs.player.eva || 0) + val; 
        log("íšŒí”¼ìœ¨ì´ ì¦ê°€í–ˆìŠµë‹ˆë‹¤.", 'info');
    }

    // [FIX] ë¬¸ë¼ì´íŠ¸ ë² ì¼
    if(skill.effect === 'sage_moon_veil') {
        if(buffs.player.sageForm === 'moon') {
             buffs.player.veilVal = 0.4;
             buffs.player.veilTurns = 3;
             buffs.player.eva = (buffs.player.eva || 0) + 0.4;
             log("ë‹¬ë¹›ì˜ ê°€í˜¸ë¡œ íšŒí”¼ìœ¨ì´ ëŒ€í­ ì¦ê°€í•©ë‹ˆë‹¤!", 'star');
        } else {
             log("ë¬¸ë¼ì´íŠ¸ ë² ì¼ ë°œë™ (ë‹¬ì˜ í˜•íƒœê°€ ì•„ë‹ˆì–´ì„œ ì¶”ê°€íš¨ê³¼ ì—†ìŒ).", 'info');
        }
    }
    
    // [FIX] ë©”í…Œì˜¤ ìŠ¤ë§¤ì‹œ
    if(skill.effect === 'sage_meteor') {
        if(buffs.player.sageForm === 'sun') {
            buffs.player.critBuff = true;
            buffs.player.critBuffTurns = 3;
            log("íƒœì–‘ì˜ í˜ìœ¼ë¡œ ì¹˜ëª…íƒ€ìœ¨ì´ ê¸‰ì¦í•©ë‹ˆë‹¤!", 'star');
        }
    }

    if(skill.effect === 'crit_buff') {
        buffs.player.critBuff = true;
        buffs.player.critBuffTurns = 3;
        log("ì¹˜ëª…íƒ€ìœ¨ì´ ì¦ê°€í–ˆìŠµë‹ˆë‹¤!", 'rose');
    }
    
    if(skill.effect === 'instinct') {
        buffs.player.instinctTurns = 5;
        buffs.player.instinctVal = 0.25;
        buffs.player.eva = (buffs.player.eva || 0) + 0.25; 
        log("ë³¸ëŠ¥ ë°œë™! íšŒí”¼ì™€ í”¼í•´ëŸ‰ì´ ì¦ê°€í•©ë‹ˆë‹¤.", 'info');
    }

    if(skill.effect === 'adrenaline') {
        buffs.player.adrenalineTurns = 4;
        log("ì•„ë“œë ˆë‚ ë¦° í­ë°œ! ì¹˜ëª…íƒ€ í”¼í•´ê°€ ì¦ê°€í•©ë‹ˆë‹¤.", 'rose');
    }
    if(skill.effect === 'immortal') {
        buffs.player.immortal = true;
        log("ì´ë²ˆ í„´ ì£½ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'fire');
    }
    if(skill.effect === 'divine_buff') {
        buffs.player.divineTurns = 4;
        log("ë””ë°”ì¸ ì•„ë¨¸ ì „ê°œ!", 'holy');
    }
    if(skill.effect === 'enchant_buff') {
        buffs.player.enchantTurns = 5;
        log("ë¬´ê¸°ì— í™”ì—¼ì„ ë‘˜ë €ìŠµë‹ˆë‹¤!", 'fire');
    }
    if(skill.effect === 'reflect') {
        buffs.player.sanctuaryTurns = 4;
        log("ë§ˆë²• ë°˜ì‚¬ ë³´í˜¸ë§‰ ìƒì„±!", 'holy');
    }
    if(skill.effect === 'medi') {
        buffs.player.medi = true;
        buffs.player.mediTurns = 3;
        log("ëª…ìƒ ì‹œì‘. ë§ˆë‚˜ íšŒë³µ ì¦ê°€.", 'heal');
    }
    if(skill.effect === 'dmg_red_50') buffs.player.dmgRed50 = true;
    if(skill.effect === 'passive_boost') {
        buffs.player.gardenTurns = 3;
        log("ì—¬ì™•ì˜ ì •ì›ì´ í¼ì³ì§‘ë‹ˆë‹¤. íŒ¨ì‹œë¸Œ íš¨ê³¼ 2ë°°!", 'rose');
    }
    if(skill.effect === 'add_rose_3') {
        roseStack = Math.min(15, roseStack + 3);
        log("ì¥ë¯¸ 3ì†¡ì´ê°€ í”¼ì–´ë‚¬ìŠµë‹ˆë‹¤.", 'rose');
    }

    if(skill.effect === 'royal_bloom') {
        buffs.player.royalBloomTurns = 3;
        // roseStack = 0; // ì¦‰ì‹œ ì†Œë©¸í•˜ì§€ ì•ŠìŒ
        log("Royal Bloom! ì¥ë¯¸ê°€ ë§Œê°œí•˜ì—¬ í˜ì„ ê°œë°©í•©ë‹ˆë‹¤! (3í„´ê°„ ê³µ/ë§ˆê³µ 50% ì¦ê°€, ì¢…ë£Œ ì‹œ ì‹œë“¦)", 'rose');
    }

    // UI ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ìŠ¤íƒ¯ ì¬ê³„ì‚° í˜¸ì¶œ (ë²„í”„ ì ìš© ì§í›„)
    recalcAllStats();
}

function winBattle() {
    log(`<b style="color:#ffd700">ì „íˆ¬ ìŠ¹ë¦¬!</b>`, 'info');
    player.exp += currentEnemy.exp;
    gameState.gold += currentEnemy.gold;
    log(`ê²½í—˜ì¹˜ +${currentEnemy.exp}, ê³¨ë“œ +${currentEnemy.gold} G`);
    
    // Boss Drop Logic (Unlock System)
    if(BOSS_DROP_ARTIFACTS) {
        let drop = null;
        // ë³´ìŠ¤ ë“œë í™•ë¥  ì²´í¬ (ì‹ ê·œ ë³´ìŠ¤ 100% í•´ê¸ˆ)
        if(currentEnemy.name === "ë§ˆì‹ " && Math.random() < 0.1) drop = BOSS_DROP_ARTIFACTS.mashin;
        else if(currentEnemy.name === "í˜¹í•œì˜ ë§ˆë…€" && Math.random() < 0.1) drop = BOSS_DROP_ARTIFACTS.witch;
        else if(currentEnemy.name === "ì°½ì¡°ì‹  ì•„ìŠ¤í…Œì•„" && getCycleCount() >= 4) drop = BOSS_DROP_ARTIFACTS.goddess;
        else if(currentEnemy.name === "í‘¸ë”© í”„ë¦°ì„¸ìŠ¤") drop = BOSS_DROP_ARTIFACTS.pudding;
        else if(currentEnemy.name === "ì¸ì¡° ë§ˆì‹ ") drop = BOSS_DROP_ARTIFACTS.artificial;
        else if(currentEnemy.name === "ê³¨ë“œ ë“œë˜ê³¤") drop = BOSS_DROP_ARTIFACTS.gold_dragon;
        else if(currentEnemy.name === "ê³ ëŒ€ì‹  íŒŒë¼ì˜¤") drop = BOSS_DROP_ARTIFACTS.pharaoh;
        else if(currentEnemy.name === "ì‹œê°„ì˜ ì§€ë°°ì") drop = BOSS_DROP_ARTIFACTS.time_ruler;

        if(drop) {
             let unlocks = getBossArtifactUnlocks();
             if(!unlocks.includes(drop.id)) {
                 unlockBossArtifact(drop.id);
                 let color = drop.rarity === 'legend' ? '#ff5252' : '#e040fb';
                 log(`<b style="color:${color}; font-size:1.1rem;">[ë³´ìŠ¤ ìœ ë¬¼ í•´ê¸ˆ!] ${drop.name}</b>`, 'rose');
                 myAlert(`ì¶•í•˜í•©ë‹ˆë‹¤!\n[${drop.name}]ì´(ê°€) í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ì œë¶€í„° ìƒì  ë¦¬ì…‹ì´ë‚˜ ìœ ë¬¼ ë½‘ê¸°ì—ì„œ ë“±ì¥í•©ë‹ˆë‹¤.`);
             }
        }
    }

    if(currentEnemy.name === "ì°½ì¡°ì‹  ì•„ìŠ¤í…Œì•„") {
        saveClear(player.charKey);
        gameState.clearedCreator = true; // í”Œë˜ê·¸ ì„¤ì •
        alert("ì¶•í•˜í•©ë‹ˆë‹¤! ì°½ì¡°ì‹ ì„ ë¬¼ë¦¬ì¹˜ê³  ì „ì„¤ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!\n\në§ˆì„ ë©”ë‰´ì˜ [ê²Œì„ ì¬ì‹œì‘]ì„ í†µí•´ ë‹¤ìŒ íšŒì°¨(ì  ê°•í™”+ë ˆë²¨í™•ì¥)ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    checkLevelUp();
    
    setTimeout(() => {
        document.getElementById('battle-menu').style.display = 'none';
        document.getElementById('town-menu').style.display = 'grid'; 
        
        const stage = document.getElementById('main-stage');
        stage.classList.remove('battle-mode');
        stage.classList.add('town-mode'); 

        updateInfo();
    }, 1500);
}

function loseBattle() {
    log(`<b style="color:#ff5252">ì „íˆ¬ íŒ¨ë°°...</b>`, 'dmg');
    player.hp = 1;
    setTimeout(() => {
        document.getElementById('battle-menu').style.display = 'none';
        document.getElementById('town-menu').style.display = 'grid'; 
        
        const stage = document.getElementById('main-stage');
        stage.classList.remove('battle-mode');
        stage.classList.add('town-mode');

        updateInfo();
    }, 1500);
}

function hasArtifact(key) {
    return player.artifacts && player.artifacts.some(a => a.id === key || a.effect === key);
}

function playerAttack(skill) {
    if(currentEnemy.name === "ë§ˆì‹ ") {
        if(turnCount % 2 !== 0 && skill.type === 'phy') { log("ë§ˆì‹ ì€ í™€ìˆ˜ í„´ì— ë¬¼ë¦¬ ê³µê²©ì— ë©´ì—­ì…ë‹ˆë‹¤!", 'info'); return true; }
        if(turnCount % 2 === 0 && skill.type === 'mag') { log("ë§ˆì‹ ì€ ì§ìˆ˜ í„´ì— ë§ˆë²• ê³µê²©ì— ë©´ì—­ì…ë‹ˆë‹¤!", 'info'); return true; }
    }

    if(currentEnemy.ai === 'artificial_god') {
        if(skill.type === 'phy') buffs.enemy.nextPhysDef = true;
        if(skill.type === 'mag') buffs.enemy.nextMagDef = true;
    }

    if(buffs.enemy.counter && skill.type === 'phy') {
        let counterDmg = Math.floor(currentEnemy.atk * 2.0);
        player.hp -= counterDmg;
        log(`${currentEnemy.name}ì˜ ì¹´ìš´í„°! <span class="dmg">${counterDmg}</span>ì˜ í”¼í•´ë¥¼ ì…ê³  ë°˜ê²©ë‹¹í–ˆìŠµë‹ˆë‹¤!`, 'dmg');
        return true; 
    }

    if(skill.effect === 'miss_chance' && Math.random() < 0.3) { log(`${skill.name}ì´(ê°€) ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤!`, 'info'); return true; }

    let multiplier = skill.power;
    
    if(skill.name === 'ë” í™€ë¦¬' && buffs.player.goddessTurns) {
        multiplier += 2.0;
        log("ì—¬ì‹  ê°•ë¦¼ì˜ í˜ìœ¼ë¡œ ì¶”ê°€íƒ€ê°€ ë°œìƒí•©ë‹ˆë‹¤!", 'holy');
    }

    if(skill.effect === 'stack_dmg') {
        multiplier += (buffs.player.absoluteStack || 0);
        buffs.player.absoluteStack = Math.min(5.0, (buffs.player.absoluteStack || 0) + 1.0);
    }
    
    if(skill.effect === 'rose_finisher') {
        multiplier += (roseStack * 0.4);
        multiplier = Math.min(11.0, multiplier); 
        roseStack = 0;
        log("í”¼ë‚ ë ˆ! ëª¨ë“  ì¥ë¯¸ê°€ í­ë°œí•©ë‹ˆë‹¤!", 'rose');
    }

    if(skill.effect === 'hp_reverse') {
        let lostRatio = (player.maxHp - player.hp) / player.maxHp;
        multiplier = 3.0 + (lostRatio * 6.0);
    }
    if(skill.effect === 'hp_reverse_mid') {
        let lostRatio = (player.maxHp - player.hp) / player.maxHp;
        multiplier = 1.2 + (lostRatio * 2.2);
    }
    
    if(skill.effect === 'stack_ult_new') {
        buffs.player.castleStack = Math.min(5, (buffs.player.castleStack || 0) + 1);
        multiplier = buffs.player.castleStack * 1.8;
        buffs.player.castleDef100 = true; 
    }
    if(skill.effect === 'charge_divine') {
        let stack = buffs.player.divineStack || 0;
        multiplier += (stack * 0.3);
        buffs.player.divineStack = 0;
        log(`ë””ë°”ì¸ ë¸”ë ˆì´ë“œ! ${stack}ìŠ¤íƒ í­ë°œ!`, 'holy');
    }

    if(skill.effect === 'sage_silent' && buffs.player.sageForm === 'moon') multiplier += 0.4;
    if(skill.effect === 'sage_god_hand' && buffs.player.sageForm === 'sun') multiplier += 0.8;

    if(skill.effect === 'sage_dream_ult') {
        multiplier = 4.0; 
        let activeForm = buffs.player.sageForm;
        
        if(activeForm) {
            delete buffs.player.sageForm;
            delete buffs.player.formTurns;
            recalcAllStats(); 
        }

        if(activeForm === 'star') {
            buffs.enemy.stun = true;
            log("[ë³„ì˜ ê¿ˆ] ì ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤!", 'star');
        } else if(activeForm === 'moon') {
            buffs.player.moonUltStack = (buffs.player.moonUltStack || 0) + 1;
            let bonus = buffs.player.moonUltStack * 3.5;
            multiplier = bonus;
            log(`[ë‹¬ì˜ ê¿ˆ] ëˆ„ì ëœ ì¹´ìš´íŠ¸(${buffs.player.moonUltStack})ë¡œ ìœ„ë ¥ í­ë°œ! (+${bonus.toFixed(1)}ë°°)`, 'star');
        } else if(activeForm === 'sun') {
            let crystals = player.dreamCrystals || 0;
            let bonus = crystals * 1.5;
            multiplier += bonus;
            log(`[íƒœì–‘ì˜ ê¿ˆ] ë‚¨ì€ ê²°ì •(${crystals})ë§Œí¼ ìœ„ë ¥ ì¦ê°€! (+${bonus.toFixed(1)}ë°°)`, 'star');
        } else {
            multiplier = 2.5;
            log("í˜•íƒœ ì—†ì´ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ ìœ„ë ¥ìœ¼ë¡œ ë°œë™í•©ë‹ˆë‹¤.", 'info');
        }
    }

    let isPhy = skill.type === 'phy';
    let atkVal = isPhy ? player.atk : player.matk;
    
    if(skill.effect === 'sage_hybrid_mana' || skill.effect === 'charge_milkyway') {
        atkVal = (player.atk + player.matk); 
        if(skill.effect === 'sage_hybrid_mana') atkVal /= 2; 

        if(skill.effect === 'charge_milkyway') {
            log("ì€í•˜ìˆ˜ì˜ í˜ì´ ê°œë°©ë©ë‹ˆë‹¤!", 'star');
        }
    }

    // Final Damage Artifacts (Additive)
    let finalDmgAdd = 0.0;
    if(hasArtifact('high_risk_dmg')) finalDmgAdd += 0.3;
    if(hasArtifact('high_risk_dmg_ex')) finalDmgAdd += 1.0;
    if(hasArtifact('pharaoh')) finalDmgAdd += 1.0;

    if(finalDmgAdd > 0) multiplier *= (1.0 + finalDmgAdd);
    
    // if(buffs.player.medi && !isPhy) atkVal *= 0.5; // recalcAllStatsë¡œ ì´ë™ë¨

    // if(buffs.player.goddessTurns) atkVal *= 2.0; // recalcAllStatsë¡œ ì´ë™
    
    // if(buffs.player.goddessBlessing) atkVal *= 1.5; // recalcAllStatsë¡œ ì´ë™
    // if(buffs.player.royalBloomTurns) atkVal *= 1.5; // recalcAllStatsë¡œ ì´ë™ë¨

    if(buffs.player.undyingPowerTurns) {
        // atkVal *= 2.0; // recalcAllStatsë¡œ ì´ë™
        log("ì£½ìŒì„ ê·¹ë³µí•œ í˜ìœ¼ë¡œ ê³µê²©ë ¥ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤!", 'fire');
    }

    let critChance = player.baseCrit;
    if(buffs.player.critBuff) {
    critChance += (player.charKey === 'rumi') ? 0.40 : 0.25;}
    if(skill.effect === 'guarantee_crit') critChance = 1.0;
    if(skill.name === 'ì–´ìŒ”ì‹  ë„¤ì¼') critChance += (buffs.enemy.darkness || 0) * 0.3;
    
    // [FIX] ë©”í…Œì˜¤ ìŠ¤ë§¤ì‹œ ë²„í”„ ë¡œì§ ì œê±° (applyPlayerSupportë¡œ ì´ë™ë¨)
    // if(skill.effect === 'sage_meteor' && buffs.player.sageForm === 'sun') { ... }

    let isCrit = Math.random() < critChance;
    if(isCrit) {
        let critDmg = player.baseCritDmg;
        if(buffs.player.adrenalineTurns) critDmg += 1.0;
        if(hasArtifact('reckless')) critDmg += 0.5;
        atkVal *= critDmg;
    }

    // ì§€í¬ íŒ¨ì‹œë¸ŒëŠ” ì´ì œ recalcAllStatsì—ì„œ ê¸°ë³¸ statì— ë°˜ì˜ë¨.
    // if(player.name === 'ì§€í¬') {
    //     if(player.hp < player.maxHp * 0.25) atkVal *= 1.3;
    //     else if(player.hp < player.maxHp * 0.5) atkVal *= 1.15;
    // }

    let defVal = isPhy ? currentEnemy.def : currentEnemy.mdef;
    
    // Enemy Def Reduction (Additive)
    let defRed = 0.0;
    if(skill.type === 'phy' && buffs.enemy.darkness) {
        defRed += 0.10 * buffs.enemy.darkness;
    }
    if(isPhy && buffs.enemy.defDownTurns > 0) defRed += 0.2;
    if(!isPhy && buffs.enemy.mdefDownTurns > 0) defRed += 0.2;

    if(isPhy && buffs.enemy.physDefBuff) defRed -= 0.5;
    if(!isPhy && buffs.enemy.magDefBuff) defRed -= 0.5;

    // Cap reduction? 100% means 0 def.
    defRed = Math.min(1.0, defRed);
    defVal *= (1 - defRed);
    defVal = Math.max(0, defVal);

    let dmg = atkVal * multiplier * (100 / (100 + defVal));
    dmg = Math.floor(dmg);
    dmg = Math.max(1, dmg); 

    if(skill.effect === 'hp_cost') player.hp -= player.maxHp * 0.1;
    if(skill.effect === 'hp_cost_20') player.hp -= player.maxHp * 0.2;
    if(skill.effect === 'reset_buff') { 
        let heal = Math.floor(player.maxHp * 0.6);
        player.hp = Math.min(player.maxHp, player.hp + heal);
        buffs.player.goddessTurns = 3;
        log(`ì—¬ì‹  ê°•ë¦¼! HP <span class="heal">${heal}</span> íšŒë³µ, ìƒíƒœ ë¦¬ì…‹ ë° ëŠ¥ë ¥ì¹˜ 2ë°°!`, 'heal');
    }
    
    if(skill.effect === 'darkness') {
        let add = 0;
        if(skill.name === 'í¬ë¡œìŠ¤ ì»·' && isCrit) add = 3; 
        else if(skill.name === 'ì„€ë„ìš° ë³¼') add = 1; 
        else if(skill.name === 'ë‹¤í¬ ë©”í…Œì˜¤') add = 1;
        
        if(add > 0) {
            buffs.enemy.darkness = Math.min(5, (buffs.enemy.darkness || 0) + add);
            log(`ì•”í‘ ìŠ¤íƒì´ ${add} ìŒ“ì˜€ìŠµë‹ˆë‹¤! (í˜„ì¬: ${buffs.enemy.darkness})`, 'info');
        }
    }
    
    if(skill.effect === 'sage_hybrid_mana' && isCrit) {
        player.mp = Math.min(player.maxMp, player.mp + 40);
        log("íŠ¸ìœ™í´ ì¹˜ëª…íƒ€! ë§ˆë‚˜ 40 íšŒë³µ.", 'heal');
    }

    if(skill.effect === 'self_stun' || skill.effect === 'rose_2_self_stun') {
        buffs.player.nextTurnStun = true;
        log("ë¬´ë¦¬í•œ í–‰ë™ìœ¼ë¡œ ë‹¤ìŒ í„´ì— ì›€ì§ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!", 'info');
    }

    if(skill.effect === 'self_def_zero') buffs.player.defZeroNext = true;

    if(skill.effect === 'def_down') buffs.enemy.defDownTurns = 3;
    if(skill.effect === 'mdef_down') buffs.enemy.mdefDownTurns = 3;
    if(skill.effect === 'burn') buffs.enemy.burnTurns = 3;
    
    if(skill.effect === 'add_rose_1') roseStack = Math.min(15, roseStack + 1);
    if(skill.effect === 'rose_2_self_stun') roseStack = Math.min(15, roseStack + 2);
    if(skill.effect === 'crit_rose_6' && isCrit) { roseStack = Math.min(15, roseStack + 6); log("ì¹˜ëª…íƒ€! ì¥ë¯¸ê°€ ê¸‰ê²©íˆ í”¼ì–´ë‚©ë‹ˆë‹¤!", 'rose'); }

    let enchantDmg = 0;
    if(buffs.player.enchantTurns > 0 && isPhy) {
        let eMult = 0.8;
        if(skill.effect === 'fire_combo_new') eMult = 1.6;
        enchantDmg = Math.floor(player.matk * eMult * (100 / (100 + currentEnemy.mdef)));
        enchantDmg = Math.max(1, enchantDmg); 
    }

    currentEnemy.hp -= dmg;
    buffs.enemy.tookDamageThisTurn = true;

    let critMsg = isCrit ? " <b>(ì¹˜ëª…íƒ€!)</b>" : "";
    log(`${skill.name}! ì ì—ê²Œ <span class="dmg">${dmg}${critMsg}</span> í”¼í•´.`);

    if(enchantDmg > 0) {
        currentEnemy.hp -= enchantDmg;
        log(`íŒŒì´ì–´ ì¸ì±ˆíŠ¸ ì¶”ê°€íƒ€! <span class="fire">${enchantDmg}</span> ë§ˆë²• í”¼í•´.`, 'fire');
    }
    
    if(hasArtifact('vampire')) {
        let heal = Math.floor((dmg + enchantDmg) * 0.05);
        player.hp = Math.min(player.maxHp, player.hp + heal);
    }

    if(skill.effect === 'multi_hit' && buffs.player.dodgeCount) {
        let hits = Math.min(4, buffs.player.dodgeCount);
        let extraDmg = dmg * hits;
        extraDmg = Math.max(1, extraDmg); 
        currentEnemy.hp -= extraDmg;
        log(`ëŒ„ì‹± ëŒ€ê±° ì¶”ê°€ ${hits}íƒ€! <span class="dmg">${extraDmg}</span> í”¼í•´.`);
    }

    if(currentEnemy.hp <= 0 && currentEnemy.ai === 'witch' && !currentEnemy.hasRevived) {
        currentEnemy.hp = 3000;
        currentEnemy.hasRevived = true;
        log(`<b style="color:#29b6f6">í˜¹í•œì˜ ë§ˆë…€ê°€ ì–¼ìŒ ì†ì—ì„œ ë˜ì‚´ì•„ë‚©ë‹ˆë‹¤! (HP 3000 íšŒë³µ)</b>`, 'info');
        return true; 
    }

    if(currentEnemy.hp <= 0 && currentEnemy.ai === 'gold_dragon' && !currentEnemy.hasRevived) {
        currentEnemy.hp = 3000;
        currentEnemy.hasRevived = true;
        log(`<b style="color:#ffd700">ê³¨ë“œ ë“œë˜ê³¤ì´ í™©ê¸ˆì˜ í˜ìœ¼ë¡œ ë¶€í™œí•©ë‹ˆë‹¤! (HP 3000 íšŒë³µ)</b>`, 'info');
        return true;
    }

    if(currentEnemy.ai === 'pharaoh' && buffs.enemy.pharaohStance) {
        log(`<b style="color:#8d6e63">íŒŒë¼ì˜¤ê°€ ê³µê²©ì— ë°˜ì‘í•˜ì—¬ ê³ ëŒ€ì˜ ì €ì£¼ë¥¼ ë°œë™í•©ë‹ˆë‹¤! (ê³µ/ë§ˆê³µ +100%)</b>`, 'dmg');
        buffs.enemy.pharaohBuffTurns = 10;
        delete buffs.enemy.pharaohStance;
    }

    // Hidden Boss Death Handling
    if(currentEnemy.hp <= 0 && currentEnemy.tier === 'hidden') {
        if(!gameState.hiddenBossDead) {
            // Check if reserve is alive
            let otherId = currentEnemy.ai === 'iris_light' ? 'iris_curse' : 'iris_light';
            if(gameState.hiddenBossReserve[otherId] > 0) {
                // One dies, but other is alive.
                gameState.hiddenBossDead = true; // Mark one as dead (Berserk trigger next turn)
                currentEnemy.hp = 0;
                log(`<b style="color:#ff5252">${currentEnemy.name}ì´(ê°€) ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤... í•˜ì§€ë§Œ ì•„ì§ ëë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!</b>`, 'info');

                // Swap to survivor immediately
                let nextBoss = ENEMIES.find(e => e.ai === otherId);
                let savedHp = gameState.hiddenBossReserve[otherId];

                currentEnemy = JSON.parse(JSON.stringify(nextBoss));
                currentEnemy.hp = savedHp;
                currentEnemy.maxHp = gameState.hiddenBossReserve.maxHp;

                // Apply scaling
                let s = gameState.hiddenBossReserve.scaledStats[otherId === 'iris_light' ? 'light' : 'curse'];
                currentEnemy.atk = s.atk; currentEnemy.matk = s.matk;
                currentEnemy.def = s.def; currentEnemy.mdef = s.mdef;

                // Berserk Apply Immediately
                currentEnemy.atk *= 2; currentEnemy.matk *= 2;
                buffs.enemy.berserk = true;

                document.getElementById('vis-e-name').innerText = currentEnemy.name;
                const eImgBox = document.getElementById('enemy-img');
                let imgSrc = currentEnemy.img ? currentEnemy.img : `${currentEnemy.name}.png`;
                eImgBox.innerHTML = `<img src="${imgSrc}" onerror="this.style.display='none'; this.parentNode.innerText='ğŸ’€'">`;

                updateBattleUI();
                log(`<b style="color:#ff5252">${currentEnemy.name}ì´(ê°€) ë‚œì…í•˜ì—¬ ê´‘í­í™”í•©ë‹ˆë‹¤!</b>`, 'dmg');
                return true; // Still alive (new boss)
            }
        }
    }

    return currentEnemy.hp > 0;
}

function swapBoss() {
    if(!gameState.hiddenBossReserve || gameState.hiddenBossDead) return;

    log(`<b style="color:#ffd700">=== ë³´ìŠ¤ êµëŒ€ ===</b>`, 'info');

    // 1. í˜„ì¬ ë³´ìŠ¤ ìƒíƒœ ì €ì¥
    let currentData = JSON.parse(JSON.stringify(currentEnemy));
    gameState.hiddenBossReserve[currentData.ai] = currentData.hp;

    // 2. ì˜ˆë¹„ ë³´ìŠ¤ ë¡œë“œ
    let nextBossId = currentEnemy.ai === 'iris_light' ? 'iris_curse' : 'iris_light';
    let nextBoss = ENEMIES.find(e => e.ai === nextBossId);
    if(!nextBoss) return;

    // Deep Copy
    currentEnemy = JSON.parse(JSON.stringify(nextBoss));

    // HP ë³µì›
    let savedHp = gameState.hiddenBossReserve[nextBossId];
    if(savedHp !== undefined) currentEnemy.hp = savedHp;
    else currentEnemy.hp = currentEnemy.maxHp;

    if(gameState.hiddenBossReserve.maxHp) currentEnemy.maxHp = gameState.hiddenBossReserve.maxHp;
    if(gameState.hiddenBossReserve.scaledStats) {
        let s = gameState.hiddenBossReserve.scaledStats;
        if(nextBossId === 'iris_light') {
            currentEnemy.atk = s.light.atk; currentEnemy.matk = s.light.matk;
            currentEnemy.def = s.light.def; currentEnemy.mdef = s.light.mdef;
        } else {
            currentEnemy.atk = s.curse.atk; currentEnemy.matk = s.curse.matk;
            currentEnemy.def = s.curse.def; currentEnemy.mdef = s.curse.mdef;
        }
    }

    // UI Update
    document.getElementById('vis-e-name').innerText = currentEnemy.name;
    const eImgBox = document.getElementById('enemy-img');
    let imgSrc = currentEnemy.img ? currentEnemy.img : `${currentEnemy.name}.png`;
    eImgBox.innerHTML = `<img src="${imgSrc}" onerror="this.style.display='none'; this.parentNode.innerText='ğŸ’€'">`;

    // Reset buffs on swap
    buffs.enemy = {};

    log(`${currentEnemy.name} ë“±ì¥!`, 'info');
    updateBattleUI();
}

function enemyTurn() {
    if(currentEnemy.name === "ì„¸ê³„ìˆ˜") {
        currentEnemy.atk += 5;
        currentEnemy.matk += 5;
    }

    if(buffs.enemy.burnTurns > 0) {
        let burnDmg = Math.floor(player.matk * 0.5);
        burnDmg = Math.max(1, burnDmg);
        currentEnemy.hp -= burnDmg;
        log(`í™”ìƒ í”¼í•´! <span class="dmg">${burnDmg}</span>`, 'info');
        buffs.enemy.burnTurns--;
        if(currentEnemy.hp <= 0) return false;
    }

    if(currentEnemy.ai === 'charge') {
        if(buffs.enemy.charging) {
            delete buffs.enemy.charging;
            log(`${currentEnemy.name}ì˜ ì°¨ì§€ ì–´íƒ ë°œì‚¬!`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 2.5, 'phy');
        }
        if(Math.random() < 0.3) {
            log(`${currentEnemy.name}ì´(ê°€) ê¸°ë¥¼ ëª¨ìœ¼ê¸° ì‹œì‘í•©ë‹ˆë‹¤...`, 'info');
            buffs.enemy.charging = true;
            return true;
        }
    }

    if(currentEnemy.ai === 'cream_maid') {
        if(Math.random() < 0.3) {
            log(`${currentEnemy.name}ì˜ í¬ë¦¼ ìµìŠ¤í”Œë¡œì „!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        } else {
            log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
            return applyEnemyDamage(currentEnemy.atk, 'phy');
        }
    }

    if(currentEnemy.ai === 'candy_boy') {
        let rand = Math.random();
        if(rand < 0.2) {
            log(`${currentEnemy.name}ì˜ ìº”ë”” ìºë…¼!`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 1.5, 'phy');
        } else if(rand < 0.4) {
            log(`${currentEnemy.name}ì˜ í¬ë¦¼ ìµìŠ¤í”Œë¡œì „!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        } else {
            log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
            return applyEnemyDamage(currentEnemy.atk, 'phy');
        }
    }

    if(currentEnemy.ai === 'pudding_princess') {
        // Form Change Logic
        if(turnCount === 1 || turnCount % 3 === 0) {
            let form = Math.random() < 0.5 ? 'milk' : 'choco';

            // Remove old buffs if any
            if(buffs.enemy.form === 'milk') { currentEnemy.atk -= 200; currentEnemy.def -= 500; }
            if(buffs.enemy.form === 'choco') { currentEnemy.matk -= 200; currentEnemy.mdef -= 500; }

            buffs.enemy.form = form;
            if(form === 'milk') {
                currentEnemy.atk += 200; currentEnemy.def += 500;
                log(`<b style="color:#fff59d">[ë°€í¬ í‘¸ë”© í¼] ê³µê²©ë ¥/ë°©ì–´ë ¥ ì¦ê°€!</b>`, 'info');
            } else {
                currentEnemy.matk += 200; currentEnemy.mdef += 500;
                log(`<b style="color:#8d6e63">[ì´ˆì½” í‘¸ë”© í¼] ë§ˆë²•ê³µê²©ë ¥/ë§ˆë²•ë°©ì–´ë ¥ ì¦ê°€!</b>`, 'info');
            }
        }

        let rand = Math.random();
        if(rand < 0.3) {
            log(`${currentEnemy.name}ì˜ í¬ë¦¼ ìµìŠ¤í”Œë¡œì „!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        } else if(rand < 0.4) {
            log(`<b style="color:#ffd700">${currentEnemy.name}ì˜ íŒŒë¼ë‹¤ì´ìŠ¤!</b>`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 4.0, 'mag');
        } else {
            log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
            return applyEnemyDamage(currentEnemy.atk, 'phy');
        }
    }

    if(currentEnemy.ai === 'flame_sage') {
        if(Math.random() < 0.3) {
            log(`${currentEnemy.name}ì˜ ìµìŠ¤í”Œë¡œì „!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 3.0, 'mag');
        }
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'lightning_sage') {
        let rand = Math.random();
        if(rand < 0.2) {
            log(`${currentEnemy.name}ì˜ ì „ê´‘ì„í™”!`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 2.0, 'phy');
        } else if(rand < 0.4) {
            log(`${currentEnemy.name}ì˜ ì¬ë” ë ˆì¸!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 3.0, 'mag');
        }
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'artificial_god') {
        // Defensive Passive handled in playerAttack() via buffs.enemy.nextTurn...
        if(buffs.enemy.nextPhysDef) {
            buffs.enemy.physDefBuff = true;
            delete buffs.enemy.nextPhysDef;
            log(`[ì¸ì¡° ë§ˆì‹ ] ë¬¼ë¦¬ ë°©ì–´ í”„ë¡œí† ì½œ ê°€ë™ (ë¬¼ë¦¬ ë°©ì–´ë ¥ 50% ì¦ê°€)`, 'info');
        } else { delete buffs.enemy.physDefBuff; }

        if(buffs.enemy.nextMagDef) {
            buffs.enemy.magDefBuff = true;
            delete buffs.enemy.nextMagDef;
            log(`[ì¸ì¡° ë§ˆì‹ ] ë§ˆë²• ë°©ì–´ í”„ë¡œí† ì½œ ê°€ë™ (ë§ˆë²• ë°©ì–´ë ¥ 50% ì¦ê°€)`, 'info');
        } else { delete buffs.enemy.magDefBuff; }

        let isLowHp = currentEnemy.hp < currentEnemy.maxHp * 0.5;
        let rand = Math.random();

        if(rand < 0.2) {
            log(`${currentEnemy.name}ì˜ ì „ê´‘ì„í™”!`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 2.0, 'phy');
        } else if(rand < 0.4) {
            if(isLowHp) {
                log(`<b style="color:#ff5252">${currentEnemy.name}ì˜ íŒŒê´´ì˜ í˜•íƒœ!</b>`, 'mag');
                return applyEnemyDamage(currentEnemy.matk * 4.5, 'mag');
            } else {
                log(`${currentEnemy.name}ì˜ ìµìŠ¤í”Œë¡œì „!`, 'mag');
                return applyEnemyDamage(currentEnemy.matk * 3.0, 'mag');
            }
        }
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'red_dragon') {
        let rand = Math.random();
        if(rand < 0.2) {
            log(`${currentEnemy.name}ì˜ ë“œë˜ê³¤ í¬ë¡œ! (ë¬¼ë¦¬)`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 1.5, 'phy');
        } else if(rand < 0.4) {
            log(`${currentEnemy.name}ì˜ ë“œë˜ê³¤ ë¸Œë ˆìŠ¤! (ë§ˆë²•)`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        } else {
            log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
            return applyEnemyDamage(currentEnemy.atk, 'phy');
        }
    }

    if(currentEnemy.ai === 'gold_dragon') {
        buffs.enemy.goldDragonScale = (buffs.enemy.goldDragonScale || 0) + 1;

        if(turnCount % 6 === 0) {
            buffs.enemy.goldDragonScale = 0;
            log(`<b style="color:#ffd700">[ê³¨ë“œ ë“œë˜ê³¤] ë¹„ëŠ˜ì´ ì•½í•´ì§€ë©° ë°©ì–´ë ¥ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!</b>`, 'info');
        } else {
            let boost = buffs.enemy.goldDragonScale * 10;
            log(`[ê³¨ë“œ ë“œë˜ê³¤] ë¹„ëŠ˜ì´ ë‹¨ë‹¨í•´ì§‘ë‹ˆë‹¤. (ë°©ì–´/ë§ˆë°© +${boost}%)`, 'info');
        }

        if(!currentEnemy.baseDef) {
            currentEnemy.baseDef = currentEnemy.def;
            currentEnemy.baseMdef = currentEnemy.mdef;
        }

        let scaleStack = buffs.enemy.goldDragonScale;
        let multiplier = 1.0 + (scaleStack * 0.1);

        // íˆë“  ë³´ìŠ¤ëŠ” ìŠ¤íƒ¯ ë³€ë™ ì—†ìŒ (Dragon scaling shouldn't apply if it was hidden, but this block is inside 'gold_dragon' if check. Wait, I should double check context.)
        // Ah, this block is inside if(currentEnemy.ai === 'gold_dragon').
        // So no change needed here for Hidden boss.
        // My previous merge failed because I tried to insert logic into 'gold_dragon' block thinking it was global enemy turn logic?
        // No, I was trying to locate where to insert logic.
        // The previous merge failure was because of context mismatch in the search block.
        // Let's re-read the code structure.

        currentEnemy.def = Math.floor(currentEnemy.baseDef * multiplier);
        currentEnemy.mdef = Math.floor(currentEnemy.baseMdef * multiplier);

        if((turnCount + 1) % 6 === 0) {
            log(`<b style="color:#ff5252">${currentEnemy.name}ì˜ ë“œë˜ê³¤ í¬ë¡œ! (ê°•ë ¥í•œ ì¼ê²©)</b>`, 'dmg');
            return applyEnemyDamage(currentEnemy.atk * 1.5, 'phy');
        }

        if(Math.random() < 0.3) {
            log(`${currentEnemy.name}ì˜ ë“œë˜ê³¤ ë¸Œë ˆìŠ¤!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        }

        log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'sphinx') {
        let rand = Math.random();
        if(rand < 0.2) {
             log(`${currentEnemy.name}ì˜ ê°•íƒ€!`, 'dmg');
             return applyEnemyDamage(currentEnemy.atk * 1.5, 'phy');
        } else if(rand < 0.4) {
             log(`${currentEnemy.name}ì˜ ìƒŒë“œìŠ¤í†°!`, 'mag');
             return applyEnemyDamage(currentEnemy.matk * 2.0, 'mag');
        }

        log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'pharaoh') {
        // Turn 25: Full Heal
        if(turnCount === 25) {
            log(`<b style="color:#ffd700">[íˆ¬íƒ•ì¹´ë©˜ì˜ ê´€] íŒŒë¼ì˜¤ê°€ ì˜ë©´ì—ì„œ ê¹¨ì–´ë‚˜ ì™„ì „íˆ íšŒë³µí•©ë‹ˆë‹¤!</b>`, 'heal');
            currentEnemy.hp = currentEnemy.maxHp;
            updateBattleUI();
            return true;
        }

        if(turnCount % 7 === 0) {
            log(`<b style="color:#8d6e63">[ê³ ëŒ€ì˜ ì €ì£¼] íŒŒë¼ì˜¤ê°€ ì €ì£¼ë¥¼ ì˜ì°½í•©ë‹ˆë‹¤. (ë‹¤ìŒ í„´ í”¼ê²© ì‹œ ëŠ¥ë ¥ì¹˜ ìƒìŠ¹)</b>`, 'info');
            buffs.enemy.pharaohStance = true;
            buffs.enemy.pharaohStanceTurn = turnCount;
            return true;
        }

        if(buffs.enemy.pharaohBuffTurns > 0) {
             buffs.enemy.pharaohBuffTurns--;
        }

        if(Math.random() < 0.3) {
            log(`${currentEnemy.name}ì˜ ìƒŒë“œìŠ¤í†°!`, 'mag');
            let mult = 1.0;
            if(buffs.enemy.pharaohBuffTurns > 0) mult += 1.0;
            return applyEnemyDamage(currentEnemy.matk * 2.0 * mult, 'mag');
        }

        log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
        let mult = 1.0;
        if(buffs.enemy.pharaohBuffTurns > 0) mult += 1.0;
        return applyEnemyDamage(currentEnemy.atk * mult, 'phy');
    }

    if(currentEnemy.ai === 'silent_librarian') {
         if(Math.random() < 0.3) {
             log(`${currentEnemy.name}ì˜ ì‚¬ì¼ëŸ°íŠ¸!`, 'mag');
             return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
         }
         log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
         return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'night_rabbit') {
        let rand = Math.random();
        if(rand < 0.2) {
             log(`${currentEnemy.name}ì˜ ê¹¡ì´ê¹¡ì´!`, 'phy');
             return applyEnemyDamage(currentEnemy.atk * 1.5, 'phy');
        } else if(rand < 0.4) {
             log(`${currentEnemy.name}ì˜ ì‚¬ì¼ëŸ°íŠ¸!`, 'mag');
             return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        } else {
             log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
             return applyEnemyDamage(currentEnemy.atk, 'phy');
        }
    }

    if(currentEnemy.ai === 'time_ruler') {
         if(buffs.enemy.forecastTurn && turnCount === buffs.enemy.forecastTurn + 5) {
             let type = buffs.enemy.forecastType;
             delete buffs.enemy.forecastTurn;
             delete buffs.enemy.forecastType;

             if(type === 'drain') {
                  log(`<b style="color:#90caf9">ì†Œìš¸ ë“œë ˆì¸! (í”Œë ˆì´ì–´ MP 0)</b>`, 'mag');
                  player.mp = 0;
                  return true;
             }
             if(type === 'darkness') {
                  let dmgMult = buffs.enemy.tookDamageThisTurn ? 4.5 : 1.5;
                  let msg = buffs.enemy.tookDamageThisTurn ? "ì„€ë„ìš° íŠ¸ìœ„ìŠ¤íŠ¸! (ë°˜ê²© í­ë°œ)" : "ì„€ë„ìš° íŠ¸ìœ„ìŠ¤íŠ¸!";
                  log(`<b style="color:#b39ddb">${msg}</b>`, 'mag');
                  return applyEnemyDamage(currentEnemy.matk * dmgMult, 'mag');
             }
             if(type === 'doom') {
                  log(`<b style="color:#ff5252">ì•„í¬ì¹¼ë¦½ìŠ¤! (ì¢…ë§ì˜ ì¼ê²©)</b>`, 'dmg');
                  return applyEnemyDamage(currentEnemy.atk * 5.0, 'phy');
             }
         }

         if(turnCount === 2 || turnCount === 9 || turnCount === 16) {
             let types = ['drain', 'darkness', 'doom'];
             let type = types[Math.floor(Math.random() * types.length)];
             let names = {'drain':'ê³ ê°ˆì˜ ì˜ˆê³ ', 'darkness':'ì–´ë‘ ì˜ ì˜ˆê³ ', 'doom':'ì¢…ë§ì˜ ì˜ˆê³ '};
             let descs = {'drain':'(5í„´ ë’¤ ì†Œìš¸ ë“œë ˆì¸)', 'darkness':'(5í„´ ë’¤ ì„€ë„ìš° íŠ¸ìœ„ìŠ¤íŠ¸)', 'doom':'(5í„´ ë’¤ ì•„í¬ì¹¼ë¦½ìŠ¤)'};

             buffs.enemy.forecastType = type;
             buffs.enemy.forecastTurn = turnCount;
             log(`<b style="color:#ffd700">[${names[type]}] ${descs[type]}</b>`, 'info');
             return true;
         }

         if(Math.random() < 0.3) {
             log(`${currentEnemy.name}ì˜ ì‚¬ì¼ëŸ°íŠ¸!`, 'mag');
             return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
         }
         log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
         return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'witch') {
        let isEnraged = (currentEnemy.hp < currentEnemy.maxHp * 0.25);
        let multiplier = 1.0;
        if(isEnraged) {
            multiplier = 2.0;
            log(`<b style="color:#29b6f6">ë§ˆë…€ê°€ ìƒëª…ì˜ ìœ„í˜‘ì„ ëŠë¼ê³  í­ì£¼í•©ë‹ˆë‹¤! (ê³µê²©ë ¥ 2ë°°)</b>`, 'dmg');
        }

        let rand = Math.random();
        if(rand < 0.1) {
            log(`<b style="color:#4fc3f7">ì ˆëŒ€ì˜ë„! (ëª¨ë“  ê²ƒì„ ì–¼ë ¤ë²„ë¦½ë‹ˆë‹¤!)</b>`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 5.0 * multiplier, 'mag');
        } else if(rand < 0.4) {
            log(`ì•„ì´ìŠ¤ ë¹”!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.0 * multiplier, 'mag');
        } else {
            log(`ë§ˆë…€ì˜ ëƒ‰ê¸° ê³µê²©`, 'phy');
            return applyEnemyDamage(currentEnemy.atk * multiplier, 'phy');
        }
    }

    if(currentEnemy.ai === 'goddess') {
        if(turnCount <= 2) {
            if(turnCount === 1) {
                log(`<b style="color:#ff5252">[ì‹¬íŒì˜ í˜•íƒœ] ì—¬ì‹ ì´ ê±°ëŒ€í•œ í˜ì„ ëª¨ìœ¼ê³  ìˆìŠµë‹ˆë‹¤...</b>`, 'info');
                return true; 
            }
            if(turnCount === 2) {
                log(`<b style="color:#ff5252; font-size:1.1rem;">ì €ì§€ë¨¼íŠ¸!!</b>`, 'dmg');
                return applyEnemyDamage(currentEnemy.matk * 3.5, 'mag');
            }
        }
        
        if(currentEnemy.hp <= currentEnemy.maxHp * 0.5) {
            if(buffs.player.goddessBlessing) {
                delete buffs.player.goddessBlessing;
                log(`<b style="color:#e040fb">[ê²€ì˜ í˜•íƒœ] "ìì• ëŠ” ëë‚¬ë‹¤."</b>`, 'dmg');
                log(`í”Œë ˆì´ì–´ì˜ ì¶•ë³µì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤!`, 'info');
            }

            if(buffs.enemy.charging) {
                delete buffs.enemy.charging;
                log(`<b style="color:#ff5252">ë””ë°”ì¸ ë¸”ë ˆì´ë“œ! (ì°¨ì§€ ë°œë™)</b>`, 'dmg');
                return applyEnemyDamage(currentEnemy.atk * 4.5, 'phy');
            }

            let rand = Math.random();
            if(rand < 0.2) {
                log(`ì—¬ì‹ ì´ ê²€ì„ ë†’ì´ ë“­ë‹ˆë‹¤... (ì°¨ì§€)`, 'info');
                buffs.enemy.charging = true;
                return true;
            } else if(rand < 0.4) {
                log(`í™€ë¦¬ ë ˆì´!`, 'mag');
                return applyEnemyDamage(currentEnemy.matk * 2.0, 'mag');
            } else {
                log(`ì—¬ì‹ ì˜ ê²€ê²©!`, 'dmg');
                return applyEnemyDamage(currentEnemy.atk * 1.0, 'phy');
            }
        }
        
        if(!buffs.player.goddessBlessing) {
            buffs.player.goddessBlessing = true;
            log(`<b style="color:#69f0ae">[ìì• ì˜ í˜•íƒœ] "ë„ˆì˜ í˜ì„ ë³´ì—¬ë³´ì•„ë¼."</b>`, 'heal');
            log(`í”Œë ˆì´ì–´ ê³µê²©ë ¥/ë§ˆë²•ê³µê²©ë ¥ 50% ì¦ê°€!`, 'heal');
        }

        if(turnCount >= 7) {
            log(`<b style="color:#ffd700">ë” í™€ë¦¬! (ê´‘ì—­ ì‹¬íŒ)</b>`, 'holy');
            player.hp -= 550;
            log(`<span class="dmg">550</span>ì˜ ì ˆëŒ€ í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤!`, 'dmg');
            return player.hp > 0;
        }

        log(`ì—¬ì‹ ì˜ ìì• ë¡œìš´ í‰íƒ€`, 'info');
        return applyEnemyDamage(currentEnemy.atk * 1.0, 'phy');
    }

    if(currentEnemy.ai === 'tree' && turnCount === 4) {
        log(`ì„¸ê³„ìˆ˜ì˜ ë¹›! ëª¨ë‘ ì™„ì „ íšŒë³µ.`, 'heal');
        player.hp = player.maxHp;
        currentEnemy.hp = currentEnemy.maxHp;
        updateBattleUI();
        return true;
    }
    if(currentEnemy.ai === 'ghost_king' && turnCount % 5 === 0) {
        log(`ê³ ìŠ¤íŠ¸ í‚¹ ë°˜ê²© íƒœì„¸!`, 'info');
        buffs.enemy.counter = true;
        buffs.enemy.counterTurn = turnCount;
        return true;
    }
    if((currentEnemy.ai === 'mawang' && turnCount % 5 === 0) || (currentEnemy.ai === 'mashin' && turnCount % 7 === 0)) {
        log(`${currentEnemy.name}ì˜ ë°ìŠ¤ í•¸ë“œ!`, 'dmg');
        return applyEnemyDamage(currentEnemy.atk * 3.5, 'phy');
    }

    // Iris AI (Hidden Boss)
    if(currentEnemy.ai === 'iris_light') {
        // Phase Transition Check
        if(Math.random() < 0.2 && !gameState.hiddenBossDead) {
            log(`<b style="color:#b39ddb">[ì°¨ì› ë³€í™˜] ì•„ì´ë¦¬ìŠ¤ê°€ ëª¨ìŠµì„ ë°”ê¿‰ë‹ˆë‹¤!</b>`, 'info');
            swapBoss();
            return true;
        }

        // Pattern
        if(turnCount % 4 === 0) {
            log(`<b style="color:#fff59d">í™€ë¦¬ ë ˆì´! (ê°•ë ¥í•œ ì¼ê²©)</b>`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
        }

        let rand = Math.random();
        if(rand < 0.3) {
            log(`${currentEnemy.name}ì˜ ì„¬ê´‘!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 1.5, 'mag');
        }
        log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(currentEnemy.ai === 'iris_curse') {
        // Phase Transition Check
        if(Math.random() < 0.2 && !gameState.hiddenBossDead) {
            log(`<b style="color:#fff59d">[ì°¨ì› ë³€í™˜] ì•„ì´ë¦¬ìŠ¤ê°€ ëª¨ìŠµì„ ë°”ê¿‰ë‹ˆë‹¤!</b>`, 'info');
            swapBoss();
            return true;
        }

        // Pattern
        if(turnCount % 4 === 0) {
            log(`<b style="color:#b39ddb">ë‹¤í¬ë‹ˆìŠ¤! (ê°•ë ¥í•œ ì¼ê²©)</b>`, 'mag');
            let dmg = applyEnemyDamage(currentEnemy.matk * 2.5, 'mag');
            if(dmg) buffs.enemy.darkness = Math.min(5, (buffs.enemy.darkness || 0) + 1);
            return dmg;
        }

        let rand = Math.random();
        if(rand < 0.3) {
            log(`${currentEnemy.name}ì˜ ì•”í‘íƒ„!`, 'mag');
            return applyEnemyDamage(currentEnemy.matk * 1.5, 'mag');
        }
        log(`${currentEnemy.name}ì˜ ê³µê²©`, 'phy');
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }

    if(Math.random() < 0.3 && currentEnemy.ai !== 'charge') {
        let val = currentEnemy.skillType === 'phy' ? currentEnemy.atk : currentEnemy.matk;
        log(`${currentEnemy.name}ì˜ ${currentEnemy.skillName}!`, 'dmg');
        return applyEnemyDamage(val * currentEnemy.skillPower, currentEnemy.skillType);
    } else {
        log(`${currentEnemy.name}ì˜ ê³µê²©!`, 'dmg');
        return applyEnemyDamage(currentEnemy.atk, 'phy');
    }
}

function applyEnemyDamage(rawDmg, type) {
    let eva = player.baseEva + (buffs.player.eva || 0);
    if(Math.random() < eva) {
        log("ì ì˜ ê³µê²©ì„ íšŒí”¼í–ˆìŠµë‹ˆë‹¤!", 'info');
        if(player.skills['dancing']) buffs.player.dodgeCount = (buffs.player.dodgeCount || 0) + 1;
        return true;
    }

    let def = type === 'mag' ? player.mdef : player.def;
    
    if(buffs.player.defZero) def = 0;
    // else {
        // Buffs are now handled in recalcAllStats (defMult)
        // let defMult = 1.0;
        // if(buffs.player.divineTurns) defMult += 0.3;
        // if(buffs.player.castleDef100) defMult += 1.0;
        
        // if(player.name === 'ì§€í¬') {
        //     if(player.hp < player.maxHp * 0.25) defMult += 0.3;
        //     else if(player.hp < player.maxHp * 0.5) defMult += 0.15;
        // }
        
        // def *= defMult;
    // }

    // if(buffs.player.goddessTurns) def *= 2.0; // Handled in recalcAllStats

    let dmg = rawDmg * (100 / (100 + def));

    if(hasArtifact('high_risk_dmg')) dmg *= 1.2;
    if(hasArtifact('high_risk_dmg_ex')) dmg *= 1.5;

    if(buffs.player.nullMag && type === 'mag') dmg = 0;
    if(buffs.player.nullPhy && type === 'phy') dmg = 0;
    if(buffs.player.guard_70) dmg *= 0.3;
    if(buffs.player.guard) dmg *= 0.3;
    if(buffs.player.dmgRed50) dmg *= 0.5;
    if(buffs.player.instinctTurns) dmg *= 1.2;
    
    if(buffs.player.sageBarrier) {
        let reduction = buffs.player.sageForm === 'star' ? 0.3 : 0.5; 
        dmg *= reduction;
    }

    dmg = Math.floor(dmg);
    dmg = Math.max(1, dmg); 
    
    if(buffs.player.divineTurns > 0 && dmg > 0) {
        buffs.player.divineStack = (buffs.player.divineStack || 0) + 1;
    }

    if(buffs.player.immortal && player.hp - dmg <= 0) {
        player.hp = 1;
        log(`ì–¸ë‹¤ì‰ ë°œë™! ì£½ìŒì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤!`, 'fire');
        if(player.name === 'ì§€í¬') {
            buffs.player.undyingPowerTurns = 2; 
        }
    } else {
        if(player.hp - dmg <= 0 && !buffs.player.revived) {
             if(hasArtifact('guardian_angel')) {
                buffs.player.revived = true;
                player.hp = Math.floor(player.maxHp * 0.5);
                log("<b>ìˆ˜í˜¸ì²œì‚¬ì˜ ê¹ƒí„¸ì´ ë¶€ì„œì§€ë©° ë¶€í™œí–ˆìŠµë‹ˆë‹¤! (HP 50% íšŒë³µ)</b>", 'heal');
             } else if(hasArtifact('guardian_angel_legend')) {
                buffs.player.revived = true;
                player.hp = player.maxHp;
                log("<b>[ì „ì„¤] ìˆ˜í˜¸ì²œì‚¬ì˜ ê¹ƒí„¸ì´ ë¹›ë‚˜ë©° ì™„ì „í•˜ê²Œ ë¶€í™œí–ˆìŠµë‹ˆë‹¤! (HP 100% íšŒë³µ)</b>", 'heal');
             } else {
                player.hp -= dmg;
                log(`<span class="dmg">${dmg}</span> í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤.`, 'dmg');
             }
        } else {
            player.hp -= dmg;
            log(`<span class="dmg">${dmg}</span> í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤.`, 'dmg');
        }
    }

    if(buffs.player.sanctuaryTurns > 0) {
        let refDmg = Math.floor(player.matk * 1.5 * (100 / (100 + currentEnemy.mdef)));
        refDmg = Math.max(1, refDmg);
        currentEnemy.hp -= refDmg;
        log(`ìƒì¸„ì–´ë¦¬ ë°˜ì‚¬! ì ì—ê²Œ ${refDmg} í”¼í•´.`, 'dmg');
    }

    if(hasArtifact('reflect_phy') && type === 'phy') {
        let thornDmg = Math.floor(dmg * 0.1);
        if(thornDmg > 0) {
            currentEnemy.hp -= thornDmg;
            log(`ìœ ë¬¼ ë°˜ì‚¬! ${thornDmg} í”¼í•´.`, 'dmg');
        }
    }

    return player.hp > 0;
}

function endTurnPhase() {
    if(player.charKey === 'queen' && roseStack > 0 && currentEnemy.hp > 0) {
        let roseDmg = Math.floor((player.atk + player.matk) * 0.1 * roseStack);
        let defVal = currentEnemy.def;
        let reduction = 100 / (100 + defVal);
        roseDmg = Math.floor(roseDmg * reduction);
        if(buffs.player.gardenTurns) roseDmg *= 2;
        roseDmg = Math.max(1, roseDmg);
        
        currentEnemy.hp -= roseDmg;
        log(`[íŒ¨ì‹œë¸Œ] ì¥ë¯¸ì˜ ê°€ì‹œê°€ ì ì„ ì°Œë¦…ë‹ˆë‹¤! <span class="rose">${roseDmg}</span> í”¼í•´`, 'rose');
        if(currentEnemy.hp <= 0) { winBattle(); return; }
    }
    
    if(hasArtifact('regen_10')) {
        let regen = Math.floor(player.maxHp * 0.1);
        player.hp = Math.min(player.maxHp, player.hp + regen);
    }

    delete buffs.player.guard; 
    delete buffs.player.guard_70; 
    delete buffs.player.nullMag;
    delete buffs.player.nullPhy;
    delete buffs.player.castleDef100; 
    delete buffs.player.stun; 
    delete buffs.player.immortal;
    delete buffs.player.dmgRed50;
    delete buffs.player.sageBarrier; 
    
    if(buffs.player.defZero) delete buffs.player.defZero;
    if(buffs.player.defZeroNext) { buffs.player.defZero = true; delete buffs.player.defZeroNext; }

    if(buffs.player.nextTurnStun) {
        buffs.player.stun = true;
        delete buffs.player.nextTurnStun;
    }

    if(buffs.player.instinctTurns) { buffs.player.instinctTurns--; if(buffs.player.instinctTurns<=0) { delete buffs.player.instinctVal; } }
    if(buffs.player.adrenalineTurns) { buffs.player.adrenalineTurns--; if(buffs.player.adrenalineTurns<=0) { delete buffs.player.critUp; } }
    if(buffs.player.veilTurns) { buffs.player.veilTurns--; if(buffs.player.veilTurns<=0) { delete buffs.player.veilVal; } }
    if(buffs.player.mediTurns) { buffs.player.mediTurns--; if(buffs.player.mediTurns<=0) { delete buffs.player.medi; } }

    // Pharaoh's Curse Logic: Expire if not triggered next turn
    if(buffs.enemy.pharaohStance && turnCount > buffs.enemy.pharaohStanceTurn) {
        delete buffs.enemy.pharaohStance;
        log("íŒŒë¼ì˜¤ì˜ ì €ì£¼ê°€ ë¹—ë‚˜ê°€ë©° ì†Œë©¸í–ˆìŠµë‹ˆë‹¤.", 'info');
    }

    if(buffs.player.divineTurns) buffs.player.divineTurns--;
    if(buffs.player.vulcanTurns) buffs.player.vulcanTurns--;
    if(buffs.player.sanctuaryTurns) buffs.player.sanctuaryTurns--;
    if(buffs.player.goddessTurns) buffs.player.goddessTurns--;
    if(buffs.player.demonEyeTurns) {
        buffs.player.demonEyeTurns--;
        if(buffs.player.demonEyeTurns <= 0) log("ë§ˆì•ˆì˜ íš¨ê³¼ê°€ ëë‚¬ìŠµë‹ˆë‹¤.", 'info');
    }
    
    // ëŒ€í˜„ì í˜•íƒœ ë° ë²„í”„ í„´ ê°ì†Œ
    if(buffs.player.formTurns) {
        buffs.player.formTurns--;
        if(buffs.player.formTurns <= 0) {
            delete buffs.player.sageForm;
            delete buffs.player.formTurns;
            log("í˜•íƒœ ë³€í™˜ì˜ í˜ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.", 'info');
        }
    }
    if(buffs.player.milkshakeTurns) {
        buffs.player.milkshakeTurns--;
        if(buffs.player.milkshakeTurns <= 0) log("ë°€í¬ì‰ì´í¬ ë²„í”„ê°€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.", 'info');
    }
    // í„´ ì¢…ë£Œì‹œ ìŠ¤íƒ¯ ì¬ê³„ì‚° (í˜•íƒœ/ë²„í”„ ë§Œë£Œ ë°˜ì˜)
    recalcAllStats();

    if(buffs.player.critBuffTurns) { buffs.player.critBuffTurns--; if(buffs.player.critBuffTurns<=0) delete buffs.player.critBuff; }
    if(buffs.player.gardenTurns) buffs.player.gardenTurns--;
    if(buffs.player.royalBloomTurns) {
        buffs.player.royalBloomTurns--;
        if(buffs.player.royalBloomTurns <= 0) {
            roseStack = 0;
            log("Royal Bloom íš¨ê³¼ê°€ ëë‚˜ë©° ì¥ë¯¸ê°€ ì‹œë“¤ì—ˆìŠµë‹ˆë‹¤...", 'rose');
        }
    }

    if(buffs.player.enchantTurns) buffs.player.enchantTurns--;
    if(buffs.player.undyingPowerTurns) { buffs.player.undyingPowerTurns--; if(buffs.player.undyingPowerTurns<=0) log("ì–¸ë‹¤ì‰ í˜ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.", 'info'); }

    if(buffs.enemy.defDownTurns) buffs.enemy.defDownTurns--;
    if(buffs.enemy.mdefDownTurns) buffs.enemy.mdefDownTurns--;
    if(buffs.enemy.tookDamageThisTurn) delete buffs.enemy.tookDamageThisTurn;

    let totalEva = 0;
    if(buffs.player.instinctTurns > 0) totalEva += (buffs.player.instinctVal || 0);
    if(buffs.player.veilTurns > 0) totalEva += (buffs.player.veilVal || 0);
    buffs.player.eva = totalEva;

    if(buffs.player.nextEva) { buffs.player.eva += buffs.player.nextEva; delete buffs.player.nextEva; }

    let regen = player.mpRegen;
    if(buffs.player.medi) regen += 30;
    if(hasArtifact('mana_engine')) regen += 10;
    
    player.mp = Math.min(player.maxMp, player.mp + regen);
    
    updateBattleUI();
    turnCount++;
}

// =========================================
// 3. ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸° (Save & Load)
// =========================================

function saveGame() {
    if(document.getElementById('main-stage').classList.contains('battle-mode')) {
        return myAlert("ì „íˆ¬ ì¤‘ì—ëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
    if(!player || !player.charKey) return myAlert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");

    const saveData = {
        player: player,
        gameState: gameState,
        roseStack: roseStack, // ì—¬ì™• ìŠ¤íƒ
        timestamp: new Date().getTime(),
        dateStr: new Date().toLocaleString()
    };

    localStorage.setItem('turnRpgSaveData', JSON.stringify(saveData));
    myAlert("ê²Œì„ì´ ì•ˆì „í•˜ê²Œ ë³´ì¡´ë˜ì—ˆìŠµë‹ˆë‹¤.\n(ì¬ì‹œì‘ ì‹œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤)");
}

function checkSaveData() {
    const saved = localStorage.getItem('turnRpgSaveData');
    if(saved) {
        try {
            const data = JSON.parse(saved);
            const p = data.player;
            document.getElementById('load-desc').innerText =
                `${data.dateStr}\n${p.name} (Lv.${p.level}) / Gold: ${data.gameState.gold}`;

            // ë¡œë“œ ëª¨ë‹¬ ë„ìš°ê¸° (ìºë¦­í„° ì„ íƒì°½ ë‹«ê³ )
            document.getElementById('char-modal').classList.remove('active');
            document.getElementById('load-modal').classList.add('active');
        } catch(e) {
            console.error("Save file corrupted", e);
            startNewGameProcess();
        }
    } else {
        // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë°”ë¡œ ìºë¦­í„° ì„ íƒ (ê¸°ë³¸ ë™ì‘)
        // startNewGameProcess í˜¸ì¶œ ë¶ˆí•„ìš” (ì´ë¯¸ ì´ˆê¸° HTML ìƒíƒœê°€ ìºë¦­í„° ì„ íƒì°½ì„)
        // ë‹¨, setupEventDungeon ë“± ì´ˆê¸°í™”ëŠ” í•„ìš”
        startNewGameProcess();
    }
}

function loadGame() {
    const saved = localStorage.getItem('turnRpgSaveData');
    if(!saved) return startNewGameProcess();

    try {
        const data = JSON.parse(saved);

        // 1. ë°ì´í„° ë³µì›
        player = data.player;
        gameState = data.gameState;
        roseStack = data.roseStack || 0;

        // 2. ìœ ë¬¼ í’€ ì¬êµ¬ì„± (Unlocked Artifacts ë³µì›)
        // ì €ì¥ëœ ì‹œì ì˜ ìœ ë¬¼ í’€ ìƒíƒœëŠ” ì €ì¥ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, í˜„ì¬ í•´ê¸ˆ ìƒíƒœ ê¸°ì¤€ìœ¼ë¡œ ì¬êµ¬ì„±
        // (ë§Œì•½ "ì‹œê°„ì˜ ì—­í–‰" í›„ ì €ì¥ì„ ì•ˆí–ˆë‹¤ë©´? -> ì €ì¥ëœ ì‹œì  ê¸°ì¤€ìœ¼ë¡œ ë³µì›ë˜ë¯€ë¡œ ë¬¸ì œ ì—†ìŒ)
        initArtifactsWithNGPlus();

        // 3. UI ê°±ì‹ 
        document.getElementById('load-modal').classList.remove('active');
        document.getElementById('char-modal').classList.remove('active'); // í˜¹ì‹œ ì¼œì ¸ìˆë‹¤ë©´

        // ë§ˆì„ ëª¨ë“œë¡œ ë³µê·€
        document.getElementById('battle-menu').style.display = 'none';
        document.getElementById('town-menu').style.display = 'grid';
        document.getElementById('main-stage').classList.remove('battle-mode');
        document.getElementById('main-stage').classList.add('town-mode');

        // ìŠ¤íƒ¯ ì¬ê³„ì‚° ë° UI ì—…ë°ì´íŠ¸
        recalcAllStats();
        updateInfo();
        updateTownUI();

        myAlert("ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");

    } catch(e) {
        myAlert("ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + e);
        startNewGameProcess();
    }
}

function startNewGameProcess() {
    // "ìƒˆë¡œ ì‹œì‘" ë²„íŠ¼ í´ë¦­ ì‹œ -> ì™„ì „í•œ ì´ˆê¸°í™” (Hard Resetê³¼ ë™ì¼í•˜ê²Œ)
    if(!confirm("ìƒˆë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nëª¨ë“  ë°ì´í„°(ìœ ë¬¼ í•´ê¸ˆ í¬í•¨)ê°€ ì´ˆê¸°í™”ë˜ê³  ì²˜ìŒë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.")) return;

    localStorage.removeItem('turnRpgSaveData');
    localStorage.removeItem('turnRpgCycle');
    localStorage.removeItem('turnRpgClears');
    localStorage.removeItem('turnRpgBossDrops');
    localStorage.removeItem('turnRpgUsedEvents');

    document.getElementById('load-modal').classList.remove('active');

    // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
    resetGameProcess();
}

function openSettings() {
    document.getElementById('settings-modal').classList.add('active');
}

function openResetModal() {
    document.getElementById('settings-modal').classList.remove('active');
    confirmResetGame();
}

// ì´ˆê¸°í™”: í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ ë°ì´í„° í™•ì¸
checkSaveData();
</script>
</body>
</html>

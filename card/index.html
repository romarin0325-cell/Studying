<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Card RPG</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<style>
    body { background-color: #121212; color: #e0e0e0; font-family: 'Noto Sans KR', sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; user-select: none; }
    .header { padding: 10px; text-align: center; background: #1f1f1f; border-bottom: 1px solid #333; font-size: 0.95rem; color: #bbb; font-weight: bold; flex-shrink: 0; }
    .container { flex: 1; display: flex; flex-direction: column; padding: 8px; overflow: hidden; gap: 8px; }
    .screen { display: none; flex-direction: column; height: 100%; }
    .screen.active { display: flex; }
    .menu-btn { background: #333; border: 1px solid #555; color: #eee; padding: 15px; border-radius: 8px; font-size: 1rem; cursor: pointer; margin-bottom: 10px; width: 100%; text-align: center; }
    .menu-btn:active { background: #555; transform: scale(0.98); }
    .menu-btn.correct { background: #1b5e20 !important; border-color: #4caf50 !important; }
    .menu-btn.wrong { background: #b71c1c !important; border-color: #ef5350 !important; }
    .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; overflow-y: auto; padding: 5px; padding-bottom: 80px; flex: 1; }
    .card-item { background: #222; border: 2px solid #444; border-radius: 5px; padding: 5px; text-align: center; font-size: 0.8rem; cursor: pointer; position: relative; }
    .card-item.selected { border-color: #ffd700; box-shadow: 0 0 5px #ffd700; }
    @keyframes glow-legend {
      0% { box-shadow: 0 0 5px #ff5252; }
      50% { box-shadow: 0 0 20px #ff5252; }
      100% { box-shadow: 0 0 5px #ff5252; }
    }
    @keyframes glow-epic {
      0% { box-shadow: 0 0 5px #e040fb; }
      50% { box-shadow: 0 0 15px #e040fb; }
      100% { box-shadow: 0 0 5px #e040fb; }
    }
    .card-item.legend { border-color: #ff5252; color: #ff5252; animation: glow-legend 2s infinite; }
    .card-item.epic { border-color: #e040fb; color: #e040fb; animation: glow-epic 2s infinite; }
    .card-item.rare { border-color: #448aff; color: #448aff; }
    .card-item.normal { border-color: #bdbdbd; color: #bdbdbd; }

    .portrait {
        width: 100%; aspect-ratio: 3/4;
        border-radius: 6px;
        background: #000;
        border: 2px solid #555;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        margin-bottom: 3px;
    }
    .portrait img { width: 100%; height: 100%; object-fit: contain; }

    .battle-header { display: flex; justify-content: space-between; padding: 5px; background: #222; border-radius: 5px; font-size: 0.8rem; }
    .field-buffs { height: 20px; font-size: 0.7rem; color: #81d4fa; text-align: center; overflow: hidden; white-space: nowrap; cursor: pointer; }

    .visual-stage {
        flex: 1; position: relative;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 6px;
        display: flex; justify-content: space-around; align-items: center;
        padding: 5px;
        background-image: linear-gradient(to bottom, #2a2a2a, #121212);
        min-height: 200px;
        max-height: 40vh;
    }

    .battle-actor {
        width: 120px;
        text-align: center;
        position: relative;
        transition: all 0.2s;
        display: flex; flex-direction: column; align-items: center;
        cursor: pointer;
    }
    .battle-actor .portrait {
        width: 90px; height: 120px;
        border-color: #999;
    }
    .battle-actor.player .portrait { border-color: #4caf50; }
    .battle-actor.enemy .portrait { border-color: #ff5252; }
    .battle-actor.turn { transform: scale(1.05); z-index: 10; }
    .battle-actor.dead { opacity: 0.3; filter: grayscale(100%); }

    .actor-hp-bar { width: 100%; height: 6px; background: #333; margin-top: 4px; border-radius: 3px; overflow: hidden; }
    .actor-hp-fill { height: 100%; background: #ef5350; width: 100%; transition: width 0.5s; }
    .actor-mp-bar { width: 100%; height: 4px; background: #333; margin-top: 2px; border-radius: 2px; overflow: hidden; }
    .actor-mp-fill { height: 100%; background: #42a5f5; width: 100%; transition: width 0.3s; }
    .actor-buffs { font-size: 0.6rem; color: #ffd700; height: 12px; overflow: hidden; margin-top: 2px; }

    .log-container { height: 150px; background: #1a1a1a; border: 1px solid #333; border-radius: 5px; padding: 5px; overflow-y: auto; font-size: 0.75rem; margin-bottom: 5px; }
    .log-line { margin-bottom: 2px; border-bottom: 1px solid #252525; }
    .log-dmg { color: #ff5252; } .log-heal { color: #69f0ae; } .log-info { color: #4fc3f7; }

    .control-panel { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; height: 110px; margin-bottom: 60px; }
    .skill-btn { background: #333; border: 1px solid #555; color: #fff; border-radius: 5px; font-size: 0.8rem; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 5px; }
    .skill-btn:disabled { opacity: 0.5; background: #222; }
    .skill-btn span { pointer-events: none; }
    .skill-btn.phy { border-color: #9c27b0; color: #e1bee7; }
    .skill-btn.mag { border-color: #2196f3; color: #bbdefb; }
    .skill-btn.sup { border-color: #4caf50; color: #c8e6c9; }

    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
    .modal.active { display: flex; }
    .modal-content {
        background: #222; padding: 20px; border-radius: 12px; border: 1px solid #444;
        width: 320px; max-height: 80vh;
        display: flex; flex-direction: column;
        text-align: center;
        color: #e0e0e0;
    }
    .modal-scroll { flex: 1; overflow-y: auto; margin-bottom: 10px; }

    .deck-slot { width: 100%; height: 50px; background: #333; margin-bottom: 5px; border: 1px dashed #555; display: flex; align-items: center; justify-content: center; cursor: pointer; }
    .deck-slot.filled { border: 1px solid #4caf50; background: #1b5e20; }
</style>
</head>
<body>
<div class="header">Card RPG</div>
<div class="container">
    <div id="screen-title" class="screen active" style="justify-content: center; align-items: center;">
        <h1 style="color:#ffd700;">Card RPG</h1>
        <button class="menu-btn" onclick="RPG.startGame('new')">ìƒˆë¡œí•˜ê¸°</button>
        <button class="menu-btn" onclick="RPG.startGame('load')">ì´ì–´í•˜ê¸°</button>
    </div>
    <div id="screen-menu" class="screen">
        <div style="text-align:center; padding: 10px;">ë³´ìœ  í‹°ì¼“: <span id="ui-tickets" style="color:#ffd700">0</span>ì¥</div>
        <div id="next-enemy-preview" style="text-align:center; padding: 10px; background: #222; border-radius: 5px; margin-bottom: 10px; border: 1px solid #444; color: #ffcc80;">
             ë‹¤ìŒ ìƒëŒ€: ?
        </div>
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <button class="menu-btn" onclick="RPG.openGacha()" style="flex:1;">ì¼ë°˜ ë½‘ê¸° (1ì¥)</button>
            <button class="menu-btn" onclick="RPG.openChallengeGacha()" style="flex:1; border-color:#e040fb; color:#e040fb;">ë„ì „ ë½‘ê¸°</button>
        </div>
        <button class="menu-btn" onclick="RPG.openDeck()">ë± êµ¬ì„±</button>
        <button class="menu-btn" onclick="RPG.openCollection()">ì¹´ë“œ í™•ì¸</button>
        <button class="menu-btn" onclick="RPG.openLibrary()">ë„ì„œê´€</button>
        <button class="menu-btn" onclick="RPG.openChaosBlessing()" style="border-color: #ffd700; color: #ffd700;">ì¶•ë³µì˜ ì œë‹¨</button>
        <button class="menu-btn" onclick="RPG.startBattleInit()" style="background:#b71c1c; border-color:#f44336;">ì „íˆ¬ ì§„ì…</button>
        <button class="menu-btn" onclick="RPG.openSystemMenu()">ë©”ë‰´</button>
    </div>
    <div id="screen-collection" class="screen">
        <div style="display:flex; justify-content:space-between; align-items:center;"><h3>ì¹´ë“œ ëª©ë¡</h3><button onclick="RPG.toMenu()" style="padding:5px;">ë’¤ë¡œ</button></div>
        <div id="collection-grid" class="card-grid"></div>
    </div>
    <div id="screen-deck" class="screen">
        <h3>ë± êµ¬ì„±</h3>
        <div style="margin-bottom:10px;">
            <div id="slot-0" class="deck-slot" onclick="RPG.selectDeckSlot(0)">ì„ ë´‰ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
            <div id="slot-1" class="deck-slot" onclick="RPG.selectDeckSlot(1)">ì¤‘ê²¬ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
            <div id="slot-2" class="deck-slot" onclick="RPG.selectDeckSlot(2)">ëŒ€ì¥ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
        </div>
        <div style="flex:1; overflow-y:auto; border-top:1px solid #333;"><div id="deck-card-list" class="card-grid"></div></div>
        <button class="menu-btn" onclick="RPG.confirmDeck()" style="margin-bottom: 60px;">í™•ì¸</button>
    </div>
    <div id="screen-battle" class="screen">
        <div class="battle-header"><span>Turn: <span id="bt-turn">1</span></span><div id="field-buff-box" class="field-buffs" onclick="RPG.showFieldBuffInfo()"></div></div>
        <div class="visual-stage">
            <div id="player-actor-box" class="battle-actor player" onclick="RPG.showBattleStat('player', RPG.battle.currentPlayerIdx)">
                <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="p-name">Player</div>
                <div class="portrait"><img id="p-img" src="" onerror="this.style.display='none'"></div>
                <div class="actor-hp-bar"><div id="p-hp-bar" class="actor-hp-fill"></div></div>
                <div class="actor-mp-bar"><div id="p-mp-bar" class="actor-mp-fill"></div></div>
                <div id="p-buffs" class="actor-buffs"></div>
            </div>

            <div style="color:#555; font-size:1.5rem; font-weight:bold;">VS</div>

            <div id="enemy-actor-box" class="battle-actor enemy" onclick="RPG.showBattleStat('enemy', 0)">
                <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="e-name">Enemy</div>
                <div class="portrait"><img id="e-img" src="" onerror="this.style.display='none'"></div>
                <div class="actor-hp-bar"><div id="e-hp-bar" class="actor-hp-fill"></div></div>
                <div id="e-buffs" class="actor-buffs"></div>
            </div>
        </div>
        <div id="battle-log" class="log-container"></div>
        <div id="battle-controls" class="control-panel"></div>
    </div>
</div>

<div id="modal-card" class="modal">
    <div class="modal-content">
        <h3 id="md-name">Name</h3>
        <div class="modal-scroll">
            <div class="portrait" style="width:150px; height:200px; margin:0 auto;"><img id="md-img" src="" style="width:100%; height:100%; object-fit:contain;"></div>
            <p id="md-grade" style="font-size:0.8rem; margin:5px 0;">Grade</p>
            <div id="md-stats" style="font-size:0.8rem; text-align:left; background:#333; padding:5px; margin:5px 0;"></div>
            <div id="md-skills" style="font-size:0.8rem; text-align:left;"></div>
        </div>
        <button onclick="RPG.closeModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-info" class="modal" style="z-index: 200;">
    <div class="modal-content" style="height:auto;">
        <h3 id="info-title">ì •ë³´</h3>
        <div id="info-content" class="modal-scroll" style="text-align:left; font-size:0.85rem; line-height:1.4;"></div>
        <button onclick="RPG.closeInfoModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-confirm" class="modal" style="z-index: 210;">
  <div class="modal-content" style="height:auto;">
    <h3 id="confirm-title">í™•ì¸</h3>
    <div id="confirm-msg" style="margin: 10px 0;">...</div>
    <div style="display:flex; gap:10px; margin-top:15px; width:100%;">
       <button id="confirm-yes" class="menu-btn" style="flex:1; margin-bottom:0;">ì˜ˆ</button>
       <button id="confirm-no" class="menu-btn" style="flex:1; margin-bottom:0; background:#555; border-color:#777;">ì•„ë‹ˆì˜¤</button>
    </div>
  </div>
</div>

<div id="modal-gacha" class="modal">
    <div class="modal-content" style="height:auto; min-height:300px;">
        <h2 id="gacha-title">íšë“!</h2>
        <div id="gacha-result"></div>
        <button onclick="RPG.closeGachaModal()" style="margin-top:10px; width:100%; padding:10px;">í™•ì¸</button>
    </div>
</div>

<div id="modal-library" class="modal">
    <div class="modal-content" style="height:auto;">
        <h3>ë„ì„œê´€</h3>
        <button class="menu-btn" onclick="RPG.openMagicClass()">ë£¨ë¯¸ì˜ ë§ˆë²•êµì‹¤</button>
        <button class="menu-btn" onclick="RPG.openWordbook()">ë‹¨ì–´ì¥</button>
        <button onclick="document.getElementById('modal-library').classList.remove('active')" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-magic-class" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 600px; height: 80vh;">
        <h3>ë£¨ë¯¸ì˜ ë§ˆë²•êµì‹¤</h3>
        <div id="lecture-list" class="modal-scroll"></div>
        <button onclick="document.getElementById('modal-magic-class').classList.remove('active')" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-lecture-view" class="modal" style="z-index: 150;">
    <div class="modal-content" style="width: 90%; max-width: 600px; height: 90vh;">
        <h3 id="lecture-title">ê°•ì˜ ì œëª©</h3>
        <div style="display: flex; justify-content: center; margin-bottom: 10px;">
             <div class="portrait" style="width: 100px; height: 130px; border-color: #448aff;">
                 <img src="ë£¨ë¯¸.png" onerror="this.src=''" alt="Rumi">
             </div>
        </div>
        <div id="lecture-content" class="modal-scroll" style="text-align: left; padding: 10px; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap;"></div>
        <button onclick="RPG.closeLectureView()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-wordbook" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 600px; height: 80vh;">
        <h3>ë‹¨ì–´ì¥</h3>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
             <span style="font-size: 0.8rem; color: #aaa;">ë¹¨ê°„ìƒ‰: í‹€ë¦° ë‹¨ì–´</span>
             <label style="font-size: 0.8rem; color: #aaa; margin-left: 10px; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="wordbook-filter-wrong" onchange="RPG.openWordbook()" style="margin-right: 5px;"> í‹€ë¦° ë‹¨ì–´ë§Œ ë³´ê¸°
             </label>
             <button class="menu-btn" onclick="RPG.resetWrongWords()" style="width: auto; padding: 5px 10px; font-size: 0.8rem; margin: 0; background: #555;">ë³µìŠµ ì´ˆê¸°í™”</button>
        </div>
        <div id="wordbook-list" class="modal-scroll" style="text-align: left; padding: 10px;"></div>
        <button onclick="document.getElementById('modal-wordbook').classList.remove('active')" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-quiz" class="modal">
    <div class="modal-content" style="width: 320px;">
        <h3>í€´ì¦ˆ</h3>
        <div id="quiz-question" style="font-size: 1.2rem; margin: 10px 0; font-weight: bold; color: #ffd700;"></div>
        <div id="quiz-desc" style="font-size: 0.9rem; margin-bottom: 10px; color: #aaa; display:none;"></div>
        <div id="quiz-options" style="display: flex; flex-direction: column; gap: 8px; width: 100%;"></div>
        <div id="quiz-feedback" style="margin-top:10px; font-weight:bold; height:20px;"></div>
    </div>
</div>

<div id="modal-chaos" class="modal">
    <div class="modal-content" style="height:auto; min-height: 550px;">
        <h3>í˜¼ëˆì˜ ì¶•ë³µ</h3>
        <p style="font-size:0.8rem; color:#aaa;">ì „íˆ¬ ì‹œ ë¬´ì‘ìœ„ ì¹´ë“œì—ê²Œ ê°•ë ¥í•œ ì¶•ë³µì„ ë‚´ë¦½ë‹ˆë‹¤.<br>(ì „íˆ¬ ì¢…ë£Œ ì‹œ ì‚¬ë¼ì§, ìµœëŒ€ 3íšŒ)</p>
        <div style="margin-bottom:10px; font-weight:bold; color:#ffd700;">
            í˜¼ëˆì˜ ì¶•ë³µ: <span id="chaos-uses">3</span>íšŒ / ëŒ€í˜„ìì˜ ì¶•ë³µ: <span id="sage-uses">3</span>íšŒ
        </div>
        <button class="menu-btn" onclick="RPG.activateChaos('normal')">
            í˜¼ëˆì˜ ì¶•ë³µ (ì¼ë°˜)<br>
            <span style="font-size:0.75rem; font-weight:normal; color:#ccc;">ëœë¤ 2ì¢… ì¹´ë“œ ëŠ¥ë ¥ì¹˜ ëŒ€í­ ìƒìŠ¹</span>
        </button>
        <button class="menu-btn" onclick="RPG.activateChaos('challenge')" style="border-color:#e040fb; color:#e040fb;">
            í˜¼ëˆì˜ ì¶•ë³µ (ë„ì „)<br>
            <span style="font-size:0.75rem; font-weight:normal; color:#e1bee7;">í€´ì¦ˆ ì„±ê³µ ì‹œ ëœë¤ 4ì¢… ì¹´ë“œ ëŠ¥ë ¥ì¹˜ ëŒ€í­ ìƒìŠ¹</span>
        </button>
        <button class="menu-btn" onclick="RPG.activateChaos('great_sage')" style="border-color:#00e676; color:#00e676;">
            ëŒ€í˜„ìì˜ ì¶•ë³µ<br>
            <span style="font-size:0.75rem; font-weight:normal; color:#b9f6ca;">ë¬¸ë²• í€´ì¦ˆ ì„±ê³µ ì‹œ 8ì¢… ì „ì²´ ì¶•ë³µ + í‹°ì¼“ 1ì¥</span>
        </button>
        <button class="menu-btn" onclick="RPG.checkActiveChaosBlessings()" style="border-color:#29b6f6; color:#29b6f6;">
            ì ìš©ëœ ì¶•ë³µ í™•ì¸
        </button>
        <button onclick="document.getElementById('modal-chaos').classList.remove('active')" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-menu" class="modal">
    <div class="modal-content" style="height:auto;">
        <h3>ë©”ë‰´</h3>
        <button class="menu-btn" onclick="RPG.saveGame()">ì €ì¥í•˜ê¸°</button>
        <button class="menu-btn" onclick="RPG.showRecords()">ê¸°ë¡ í™•ì¸</button>
        <button class="menu-btn" onclick="RPG.toTitle()" style="border-color:#f44336; color:#ef5350;">íƒ€ì´í‹€ë¡œ</button>
        <button onclick="document.getElementById('modal-menu').classList.remove('active')" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<script src="data.js"></script>
<script src="vocab_data.js"></script>
<script src="grammar_data.js"></script>
<script>
/**
 * RPG Game Namespace
 * Encapsulates all game logic, state, and UI handling.
 */
const RPG = {
    // Game State (Persistent)
    state: {
        tickets: 20,
        inventory: [],
        deck: [null, null, null],
        enemyScale: 0,
        chaosBlessingUses: 3,
        greatSageBlessingUses: 3,
        chaosBuffs: [], // Array of { id: cardId, multiplier: float } (Merged)
        activeChaosBlessing: [], // Specific buffs from Chaos Blessing
        activeSageBlessing: []   // Specific buffs from Great Sage Blessing
    },

    // Battle State (Transient)
    battle: {
        turn: 1,
        players: [],
        enemy: null,
        fieldBuffs: [],
        currentPlayerIdx: 0,
        phase: 'start', // start, player, enemy, end
        delayedEffects: [],
        activeTraits: [], // List of active deck synergy traits
        isNewTurn: true
    },

    // UI Helper Variables
    selectedSlot: -1,
    tempOnClose: null,
    tempConfirmYes: null,
    tempConfirmNo: null,

    // Constants
    NORMAL_ATTACK: { name: 'ì¼ë°˜ ê³µê²©', type: 'phy', tier: 1, cost: 0, val: 1.0, desc: 'ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©', effects: [] },

    BUFF_NAMES: {
        'darkness': 'ì•”í‘', 'corrosion': 'ë¶€ì‹', 'silence': 'ì¹¨ë¬µ', 'curse': 'ì €ì£¼', 'weak': 'ì•½í™”',
        'burn': 'ì‘ì—´', 'divine': 'ë””ë°”ì¸', 'stun': 'ê¸°ì ˆ', 'evasion': 'íšŒí”¼', 'barrier': 'ë°°ë¦¬ì–´',
        'magic_guard': 'ë§¤ì§ê°€ë“œ', 'guard': 'ê°€ë“œ',
        'defProtocolPhy': 'ë°©ì–´í”„ë¡œí† ì½œ(ë¬¼ë¦¬)', 'defProtocolMag': 'ë°©ì–´í”„ë¡œí† ì½œ(ë§ˆë²•)',
        'sun_bless': 'íƒœì–‘ì˜ì¶•ë³µ', 'moon_bless': 'ë‹¬ì˜ì¶•ë³µ', 'sanctuary': 'ì„±ì—­',
        'goddess_descent': 'ì—¬ì‹ ê°•ë¦¼', 'earth_bless': 'ëŒ€ì§€ì˜ì¶•ë³µ', 'twinkle_party': 'íŠ¸ìœ™í´íŒŒí‹°',
        'star_powder': 'ìŠ¤íƒ€íŒŒìš°ë”'
    },

    // --- Core Functions ---

    log(msg, type='info') {
        const box = document.getElementById('battle-log');
        const div = document.createElement('div');
        div.className = `log-line log-${type}`;
        div.innerHTML = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    },

    startGame(mode) {
        if(mode === 'load') {
            const save = localStorage.getItem('cardRpgSave');
            if(save) {
                 let loaded = JSON.parse(save);
                 this.state = { ...this.state, ...loaded };
                 if(this.state.chaosBlessingUses === undefined) this.state.chaosBlessingUses = 3;
                 if(this.state.greatSageBlessingUses === undefined) this.state.greatSageBlessingUses = 3;
                 if(!this.state.chaosBuffs) this.state.chaosBuffs = [];
                 if(!this.state.activeChaosBlessing) this.state.activeChaosBlessing = [];
                 if(!this.state.activeSageBlessing) this.state.activeSageBlessing = [];

                 // Load persistent wordbook
                 const vocab = localStorage.getItem('cardRpgVocab');
                 if(vocab) this.state.wrongWords = JSON.parse(vocab);

                 this.showAlert("ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ");
            } else { this.showAlert("ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤."); this.initNewGame(); }
        } else {
            // New Game Logic: Check for previous run data to save record
            let prevStage = this.state.enemyScale;

            // If in-memory state is empty (e.g. fresh load), check localStorage
            if (prevStage === 0 && this.state.tickets === 20) {
                const save = localStorage.getItem('cardRpgSave');
                if (save) {
                    try {
                        let loaded = JSON.parse(save);
                        if (loaded.enemyScale) prevStage = loaded.enemyScale;
                    } catch (e) {}
                }
            }

            // Save record if significant progress
            if (prevStage > 0) {
                 // Temporarily set state to previous stage for saveRecord to use
                 let originalScale = this.state.enemyScale;
                 this.state.enemyScale = prevStage;
                 this.saveRecord();
                 this.state.enemyScale = originalScale;
            }

            this.initNewGame();
        }
        this.toMenu();
    },

    initNewGame() {
        this.state = { tickets: 20, inventory: [], deck: [null, null, null], enemyScale: 0, chaosBlessingUses: 3, greatSageBlessingUses: 3, chaosBuffs: [], activeChaosBlessing: [], activeSageBlessing: [], wrongWords: [] };
        // Load persistent wordbook
        const vocab = localStorage.getItem('cardRpgVocab');
        if(vocab) this.state.wrongWords = JSON.parse(vocab);
    },

    saveGame() {
        localStorage.setItem('cardRpgSave', JSON.stringify(this.state));
        localStorage.setItem('cardRpgVocab', JSON.stringify(this.state.wrongWords));
        this.showAlert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
    },

    saveRecord(score = null) {
        let history = JSON.parse(localStorage.getItem('cardRpgRecords') || '[]');
        let currentStage = score !== null ? score : (this.state.enemyScale + 1);

        // Extract existing stages (assuming format "ìµœëŒ€ ìŠ¤í…Œì´ì§€: N")
        let stages = history.map(h => {
             let m = h.match(/ìµœëŒ€ ìŠ¤í…Œì´ì§€: (\d+)/);
             return m ? parseInt(m[1]) : 0;
        });

        // Add current stage
        stages.push(currentStage);

        // Sort descending and keep top 5
        stages.sort((a, b) => b - a);
        stages = stages.slice(0, 5);

        // Reconstruct history strings
        history = stages.map(s => `ìµœëŒ€ ìŠ¤í…Œì´ì§€: ${s}`);
        localStorage.setItem('cardRpgRecords', JSON.stringify(history));
    },

    showRecords() {
        let history = JSON.parse(localStorage.getItem('cardRpgRecords') || '[]');
        if(history.length === 0) return this.showAlert("ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
        let msg = history.map((h, i) => `${i+1}ìœ„. ${h}`).join("<br>");
        this.openInfoModal("ìµœëŒ€ ìŠ¤í…Œì´ì§€ ê¸°ë¡ (Top 5)", msg);
    },

    // --- Screen Navigation ---
    toMenu() {
        this.showScreen('screen-menu');
        document.getElementById('ui-tickets').innerText = this.state.tickets;
        const enemyIdx = this.state.enemyScale % ENEMIES.length;
        const nextName = ENEMIES[enemyIdx].name;
        document.getElementById('next-enemy-preview').innerText = `ë‹¤ìŒ ìƒëŒ€: ${nextName} (Stage ${this.state.enemyScale + 1})`;
    },
    toTitle() {
        // No saveRecord here
        this.showScreen('screen-title');
    },
    showScreen(id) { document.querySelectorAll('.screen').forEach(el => el.classList.remove('active')); document.getElementById(id).classList.add('active'); },

    openSystemMenu() {
        document.getElementById('modal-menu').classList.add('active');
    },

    // --- Chaos Blessing ---
    openChaosBlessing() {
        if(this.state.greatSageBlessingUses === undefined) this.state.greatSageBlessingUses = 3;
        document.getElementById('chaos-uses').innerText = this.state.chaosBlessingUses;
        document.getElementById('sage-uses').innerText = this.state.greatSageBlessingUses;
        document.getElementById('modal-chaos').classList.add('active');
    },
    checkActiveChaosBlessings() {
        if(!this.state.chaosBuffs || this.state.chaosBuffs.length === 0) {
            return this.showAlert("í˜„ì¬ ì ìš©ëœ ì¶•ë³µì´ ì—†ìŠµë‹ˆë‹¤.");
        }
        let msg = "<b>í˜„ì¬ ì ìš©ëœ ì¶•ë³µ</b><br><br>";
        this.state.chaosBuffs.forEach(b => {
             msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier*100)}%`;
             if(b.isSage) msg += ", ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€";
             msg += "<br>";
        });
        msg += "<br>(ì „íˆ¬ ì‹œì‘ ì‹œ í•´ë‹¹ ì¹´ë“œì˜ ì²´ë ¥ì´ ëª¨ë‘ íšŒë³µë©ë‹ˆë‹¤.)";
        this.openInfoModal("ì¶•ë³µ ìƒíƒœ", msg);
    },
    activateChaos(type) {
        if(type === 'great_sage') {
            if(this.state.greatSageBlessingUses <= 0) {
                return this.showAlert("ëŒ€í˜„ìì˜ ì¶•ë³µ ê¸°íšŒë¥¼ ëª¨ë‘ ì†Œì§„í–ˆìŠµë‹ˆë‹¤. (ìƒˆë¡œí•˜ê¸° ì‹œ ë¦¬ì…‹)");
            }
            document.getElementById('modal-chaos').classList.remove('active');

            // Pick random quiz
            // Get all quizzes from all lectures
            let allQuizzes = [];
            GRAMMAR_DATA.forEach(lec => {
                allQuizzes = allQuizzes.concat(lec.quizzes);
            });
            let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

            this.showConfirm(`ì´ ë¬¸ì œëŠ” ${q.lecture_id}ê°•ì˜ ë‚´ìš©ì´ì•¼. ê°•ì˜ë¥¼ í™•ì¸í•˜ê³  í’€ë˜?`,
                () => { // Yes
                    this.showLecture(q.lecture_id, () => {
                        this.startGrammarQuiz(q);
                    });
                },
                () => { // No
                    this.startGrammarQuiz(q);
                }
            );
            return;
        }

        if(this.state.chaosBlessingUses <= 0) {
            return this.showAlert("ì´ë²ˆ ì „íˆ¬ êµ¬ê°„ì˜ ì¶•ë³µ ê¸°íšŒë¥¼ ëª¨ë‘ ì†Œì§„í–ˆìŠµë‹ˆë‹¤.");
        }
        document.getElementById('modal-chaos').classList.remove('active');

        if(type === 'normal') {
            this.applyChaosBlessing(2);
        } else if (type === 'challenge') {
            this.startChaosQuiz((success) => {
                if(success) {
                    this.applyChaosBlessing(4);
                } else {
                    this.state.chaosBlessingUses--;
                    document.getElementById('chaos-uses').innerText = this.state.chaosBlessingUses;
                    this.showAlert("í€´ì¦ˆ ì‹¤íŒ¨... ê¸°íšŒê°€ 1íšŒ ì°¨ê°ë˜ì—ˆìŠµë‹ˆë‹¤.");
                }
            });
        }
    },

    startGrammarQuiz(q, successCallback = null, failCallback = null) {
        // Shuffle options
        // q.options is array of strings. q.answer is correct string.
        let opts = [...q.options];
        opts.sort(() => Math.random() - 0.5);

        const modal = document.getElementById('modal-quiz');
        const qDiv = document.getElementById('quiz-question');
        const descDiv = document.getElementById('quiz-desc');
        const oDiv = document.getElementById('quiz-options');
        const fDiv = document.getElementById('quiz-feedback');

        // Remove hints in parentheses from description (desc)
        let cleanDesc = q.desc.replace(/\s*\(.*?\)/g, "").trim();
        // Keep parentheses in question text (interpretation)

        qDiv.innerText = q.question;
        descDiv.innerText = cleanDesc;
        descDiv.style.display = 'block';

        oDiv.innerHTML = "";
        fDiv.innerText = "";

        opts.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = "menu-btn";
            btn.style.padding = "10px";
            btn.style.fontSize = "0.9rem";
            btn.innerText = opt;
            btn.onclick = () => {
                Array.from(oDiv.children).forEach(c => c.onclick = null);
                if(opt === q.answer) {
                    btn.classList.add('correct');
                    fDiv.innerText = "ì •ë‹µ!"; fDiv.style.color = "#4caf50";
                    setTimeout(() => {
                        modal.classList.remove('active');
                        if (successCallback) successCallback();
                        else this.applyGreatSageBlessing();
                    }, 1000);
                } else {
                    btn.classList.add('wrong');
                     // Highlight correct
                    Array.from(oDiv.children).forEach(c => {
                         if(c.innerText === q.answer) c.classList.add('correct');
                    });
                    fDiv.innerText = "ì˜¤ë‹µ..."; fDiv.style.color = "#ef5350";

                    if (failCallback) {
                        setTimeout(() => {
                            modal.classList.remove('active');
                            failCallback();
                        }, 1500);
                    } else {
                        this.state.greatSageBlessingUses--;
                        setTimeout(() => {
                            modal.classList.remove('active');
                            this.showAlert(`í‹€ë ¸ì–´... ë‚¨ì€ ê¸°íšŒ: ${this.state.greatSageBlessingUses}íšŒ`);
                        }, 1500);
                    }
                }
            };
            oDiv.appendChild(btn);
        });

        modal.classList.add('active');
    },

    updateMergedBlessings() {
        this.state.chaosBuffs = [];

        const addBuffs = (list) => {
            list.forEach(nb => {
                let existing = this.state.chaosBuffs.find(b => b.id === nb.id);
                if(existing) {
                    existing.multiplier += nb.multiplier;
                } else {
                    this.state.chaosBuffs.push({ ...nb });
                }
            });
        };

        if(this.state.activeChaosBlessing) addBuffs(this.state.activeChaosBlessing);
        if(this.state.activeSageBlessing) addBuffs(this.state.activeSageBlessing);
    },

    applyGreatSageBlessing() {
        this.state.greatSageBlessingUses--;
        // Update UI immediately
        document.getElementById('sage-uses').innerText = this.state.greatSageBlessingUses;

        this.state.tickets += 1;
        if(document.getElementById('ui-tickets')) document.getElementById('ui-tickets').innerText = this.state.tickets;

        // Apply to 12 random cards
        let pool = [...CARDS].sort(() => 0.5 - Math.random());
        let picks = pool.slice(0, 12);

        this.state.activeChaosBlessing = []; // Clear Chaos Blessing

        let newBuffs = picks.map(c => {
            let mult = 0;
            if(c.grade === 'normal') mult = 0.4;
            else if(c.grade === 'rare') mult = 0.3;
            else if(c.grade === 'epic') mult = 0.2;
            else if(c.grade === 'legend') mult = 0.1;
            return { id: c.id, name: c.name, multiplier: mult, isSage: true };
        });

        // Set to activeSageBlessing (Replacing previous)
        this.state.activeSageBlessing = newBuffs;
        this.updateMergedBlessings();

        let msg = "<b>ëŒ€í˜„ìì˜ ì¶•ë³µ ì„±ê³µ!</b><br>12ëª…ì˜ ë™ë£Œì—ê²Œ ì¶•ë³µì´ ë‚´ë ¤ì¡ŒìŠµë‹ˆë‹¤.<br>ë“œë¡œìš° í‹°ì¼“ 1ì¥ íšë“!<br><br><b>[ìƒˆë¡œ ì ìš©ëœ ì¶•ë³µ]</b><br>";
        newBuffs.forEach(b => {
             msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier*100)}%, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€<br>`;
        });
        msg += `<br><b>(í˜„ì¬ ì´ í™œì„±í™”ëœ ì¶•ë³µ: ${this.state.chaosBuffs.length}ê°œ)</b>`;

        this.openInfoModal("ì¶•ë³µ ì„±ê³µ", msg);
    },

    applyChaosBlessing(count) {
        this.state.chaosBlessingUses--;
        // Pick random cards from ALL types (CARDS)
        let pool = [...CARDS].sort(() => 0.5 - Math.random());
        let picks = pool.slice(0, count);

        this.state.activeSageBlessing = []; // Clear Sage Blessing

        let newBuffs = picks.map(c => {
            let mult = 0;
            if(c.grade === 'normal') mult = 0.4;
            else if(c.grade === 'rare') mult = 0.3;
            else if(c.grade === 'epic') mult = 0.2;
            else if(c.grade === 'legend') mult = 0.1;
            return { id: c.id, name: c.name, multiplier: mult };
        });

        // Set to activeChaosBlessing (Replacing previous)
        this.state.activeChaosBlessing = newBuffs;
        this.updateMergedBlessings();

        let msg = "<b>í˜¼ëˆì˜ ì¶•ë³µ ì ìš©!</b><br>ìƒˆë¡œìš´ ì¶•ë³µì´ ë¶€ì—¬ë˜ì—ˆìŠµë‹ˆë‹¤.<br><br><b>[ìƒˆë¡œ ì ìš©ëœ ì¶•ë³µ]</b><br>";
        newBuffs.forEach(b => {
             msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier*100)}%<br>`;
        });
        msg += `<br><b>(í˜„ì¬ ì´ í™œì„±í™”ëœ ì¶•ë³µ: ${this.state.chaosBuffs.length}ê°œ)</b><br>(ì „íˆ¬ ì‹œì‘ ì‹œ í•´ë‹¹ ì¹´ë“œì˜ ì²´ë ¥ì´ ëª¨ë‘ íšŒë³µë©ë‹ˆë‹¤.)`;
        this.openInfoModal("ì¶•ë³µ ì„±ê³µ", msg);
    },

    // --- Gacha & Deck UI ---
    openGacha() {
        if(this.state.tickets < 1) return this.showAlert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
        this.state.tickets--;
        this.runGacha(false);
    },

    openChallengeGacha() {
        if(this.state.tickets < 1) return this.showAlert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");

        // í‹°ì¼“ ì„ ì°¨ê°
        this.state.tickets--;
        document.getElementById('ui-tickets').innerText = this.state.tickets;

        this.startQuiz((success) => {
            if(success) {
                this.runGacha(true);
            } else {
                this.showAlert("í€´ì¦ˆ ì‹¤íŒ¨! (í‹°ì¼“ì´ ì†Œëª¨ë˜ì—ˆìŠµë‹ˆë‹¤)");
            }
        });
    },

    runGacha(isChallenge) {
        document.getElementById('ui-tickets').innerText = this.state.tickets;
        let rand = Math.random();
        let grade = 'normal';

        if (isChallenge) {
            // Legend 20%, Epic 25%, Rare 30%, Normal 25%
            if(rand < 0.20) grade = 'legend';
            else if(rand < 0.45) grade = 'epic';
            else if(rand < 0.75) grade = 'rare';
            else grade = 'normal';
        } else {
            // Default: 10% Legend, 20% Epic, 30% Rare, 40% Normal
            if(rand < 0.10) grade = 'legend';
            else if(rand < 0.30) grade = 'epic';
            else if(rand < 0.60) grade = 'rare';
        }

        const pool = CARDS.filter(c => c.grade === grade);
        const pick = pool[Math.floor(Math.random() * pool.length)];
        this.state.inventory.push(pick.id);

        const modal = document.getElementById('modal-gacha');
        const content = document.getElementById('gacha-result');
        let color = '#bdbdbd', title = "íšë“!";
        if(grade === 'legend') { color = '#ff5252'; title = "ğŸ‰ ëŒ€ë°•! ì „ì„¤ ì¹´ë“œ! ğŸ‰"; }
        else if(grade === 'epic') { color = '#e040fb'; title = "âœ¨ ì—í”½ ì¹´ë“œ! âœ¨"; }

        let msgTitle = isChallenge ? "ë„ì „ ë½‘ê¸° ì„±ê³µ!" : "íšë“!";
        document.getElementById('gacha-title').innerText = msgTitle;
        content.innerHTML = `<div style="color:${color}; font-size:1.2rem; font-weight:bold; margin-bottom:10px;">[${pick.grade.toUpperCase()}] ${pick.name}</div>
            <div class="portrait" style="width:120px; height:160px; margin:0 auto;"><img src="${pick.name}.png" onerror="this.style.display='none'"></div><p>ìƒˆë¡œìš´ ë™ë£Œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤!</p>`;
        modal.classList.add('active');
    },

    // --- Library & Lecture ---
    openLibrary() {
        document.getElementById('modal-library').classList.add('active');
    },
    openMagicClass() {
        const list = document.getElementById('lecture-list');
        list.innerHTML = "";
        GRAMMAR_DATA.forEach(lec => {
             const btn = document.createElement('button');
             btn.className = "menu-btn";
             btn.innerText = `${lec.id}ê°•. ${lec.title}`;
             btn.onclick = () => this.showLecture(lec.id);
             list.appendChild(btn);
        });
        document.getElementById('modal-magic-class').classList.add('active');
    },
    showLecture(id, onCloseCallback) {
        const lec = GRAMMAR_DATA.find(l => l.id === id);
        if(!lec) return;
        document.getElementById('lecture-title').innerText = `${lec.id}ê°•. ${lec.title}`;
        document.getElementById('lecture-content').innerText = lec.content;

        // Setup close button to handle callback if provided (for quiz flow)
        // We override the onclick of the close button inside modal-lecture-view dynamically if needed,
        // or just use a temporary callback variable.
        const modal = document.getElementById('modal-lecture-view');

        // This is a bit hacky for the callback, but simplest given the structure.
        // We will store the callback in RPG.tempLectureClose
        this.tempLectureClose = onCloseCallback;

        modal.classList.add('active');
    },
    closeLectureView() {
        document.getElementById('modal-lecture-view').classList.remove('active');
        if(this.tempLectureClose) {
            this.tempLectureClose();
            this.tempLectureClose = null;
        }
    },

    // --- Wordbook & Quiz ---
    openWordbook() {
        if(!this.state.wrongWords) this.state.wrongWords = [];
        const list = document.getElementById('wordbook-list');
        list.innerHTML = "";

        const onlyWrong = document.getElementById('wordbook-filter-wrong').checked;

        VOCAB_DATA.forEach(v => {
            const isWrong = this.state.wrongWords.includes(v.word);

            // Filter logic
            if(onlyWrong && !isWrong) return;

            const div = document.createElement('div');
            div.style.marginBottom = "10px";
            div.style.borderBottom = "1px solid #444";
            div.style.paddingBottom = "5px";

            // Apply red color if wrong
            const wordColor = isWrong ? '#ef5350' : '#81d4fa';

            div.innerHTML = `<b style="color:${wordColor}; font-size:1.1rem;">${v.word}</b><br>
                             <span style="color:#eee;">${v.meaning}</span>`;
            list.appendChild(div);
        });
        document.getElementById('modal-wordbook').classList.add('active');
    },

    resetWrongWords() {
        this.state.wrongWords = [];
        localStorage.removeItem('cardRpgVocab');
        this.showAlert("ë³µìŠµ ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
        this.openWordbook(); // Re-render
    },

    startQuiz(callback) {
        // Reset specific UI elements for normal quiz
        document.getElementById('quiz-desc').style.display = 'none';

        // Pick a word
        const q = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];

        // Options: Correct, Trap, 2 Random
        let options = [];
        options.push({ text: q.meaning, correct: true });
        options.push({ text: q.trap_meaning, correct: false }); // Trap Answer

        // Randoms (ensure distinct)
        let safeCounter = 0;
        while(options.length < 4 && safeCounter < 100) {
            safeCounter++;
            let r = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];
            // Must be different word, different trap word, and meaning not already in options
            if(r.word !== q.word && r.word !== q.trap_word && !options.some(o => o.text === r.meaning)) {
                options.push({ text: r.meaning, correct: false });
            }
        }

        // Shuffle
        options.sort(() => Math.random() - 0.5);

        const modal = document.getElementById('modal-quiz');
        const qDiv = document.getElementById('quiz-question');
        const oDiv = document.getElementById('quiz-options');
        const fDiv = document.getElementById('quiz-feedback');

        qDiv.innerText = q.word;
        oDiv.innerHTML = "";
        if(fDiv) fDiv.innerText = "";

        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = "menu-btn";
            btn.style.padding = "10px";
            btn.style.fontSize = "0.9rem";
            btn.innerText = opt.text;
            btn.onclick = () => {
                // Disable all buttons
                Array.from(oDiv.children).forEach(c => c.onclick = null);

                if(opt.correct) {
                    btn.classList.add('correct');
                    if(fDiv) { fDiv.innerText = "ì •ë‹µ!"; fDiv.style.color = "#4caf50"; }
                    setTimeout(() => {
                        modal.classList.remove('active');
                        callback(true);
                    }, 1000);
                } else {
                    btn.classList.add('wrong');

                    // Record Wrong Answer
                    if(!RPG.state.wrongWords) RPG.state.wrongWords = [];
                    if(!RPG.state.wrongWords.includes(q.word)) {
                        RPG.state.wrongWords.push(q.word);
                        localStorage.setItem('cardRpgVocab', JSON.stringify(RPG.state.wrongWords));
                    }

                    // Find correct one to highlight
                    Array.from(oDiv.children).forEach(c => {
                         if(c.innerText === q.meaning) c.classList.add('correct');
                    });
                    if(fDiv) { fDiv.innerText = "ì˜¤ë‹µ..."; fDiv.style.color = "#ef5350"; }
                    setTimeout(() => {
                        modal.classList.remove('active');
                        callback(false);
                    }, 1500);
                }
            };
            oDiv.appendChild(btn);
        });

        modal.classList.add('active');
    },

    startChaosQuiz(callback) {
        document.getElementById('quiz-desc').style.display = 'none';

        // Pick a word
        const q = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];

        // Options: Correct (English), 3 Random (English)
        let options = [];
        options.push({ text: q.word, correct: true });

        // Randoms (ensure distinct)
        let safeCounter = 0;
        while(options.length < 4 && safeCounter < 100) {
            safeCounter++;
            let r = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];
            // Must be different word, and word not already in options
            if(r.word !== q.word && !options.some(o => o.text === r.word)) {
                options.push({ text: r.word, correct: false });
            }
        }

        // Shuffle
        options.sort(() => Math.random() - 0.5);

        const modal = document.getElementById('modal-quiz');
        const qDiv = document.getElementById('quiz-question');
        const oDiv = document.getElementById('quiz-options');
        const fDiv = document.getElementById('quiz-feedback');

        // Question is Meaning (Korean)
        qDiv.innerText = q.meaning;
        oDiv.innerHTML = "";
        if(fDiv) fDiv.innerText = "";

        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = "menu-btn";
            btn.style.padding = "10px";
            btn.style.fontSize = "0.9rem";
            btn.innerText = opt.text;
            btn.onclick = () => {
                // Disable all buttons
                Array.from(oDiv.children).forEach(c => c.onclick = null);

                if(opt.correct) {
                    btn.classList.add('correct');
                    if(fDiv) { fDiv.innerText = "ì •ë‹µ!"; fDiv.style.color = "#4caf50"; }
                    setTimeout(() => {
                        modal.classList.remove('active');
                        callback(true);
                    }, 1000);
                } else {
                    btn.classList.add('wrong');
                    // Find correct one to highlight
                    Array.from(oDiv.children).forEach(c => {
                         if(c.innerText === q.word) c.classList.add('correct');
                    });
                    if(fDiv) { fDiv.innerText = "ì˜¤ë‹µ..."; fDiv.style.color = "#ef5350"; }
                    setTimeout(() => {
                        modal.classList.remove('active');
                        callback(false);
                    }, 1500);
                }
            };
            oDiv.appendChild(btn);
        });

        modal.classList.add('active');
    },
    closeGachaModal() { document.getElementById('modal-gacha').classList.remove('active'); },

    openCollection() { this.showScreen('screen-collection'); this.renderCardList('collection-grid', this.state.inventory, (id) => this.showCardInfo(id)); },

    renderCardList(containerId, list, clickHandler) {
        const box = document.getElementById(containerId);
        box.innerHTML = "";
        let counts = {};
        list.forEach(id => { counts[id] = (counts[id] || 0) + 1; });
        for(let id in counts) {
            const data = CARDS.find(c => c.id === id);
            if(!data) continue;
            const el = document.createElement('div');
            el.className = `card-item ${data.grade}`;
            el.innerHTML = `<div class="portrait"><img src="${data.name}.png" onerror="this.style.display='none'"></div><div>${data.name} (x${counts[id]})</div>`;
            el.onclick = () => clickHandler(id);
            box.appendChild(el);
        }
    },

    showCardInfo(id) {
        const data = CARDS.find(c => c.id === id);
        if(!data) return;
        document.getElementById('md-name').innerText = data.name;
        document.getElementById('md-img').src = `${data.name}.png`;
        document.getElementById('md-grade').className = data.grade;
        document.getElementById('md-grade').innerText = `${data.grade.toUpperCase()} / ${data.role} / ${data.element}`;
        document.getElementById('md-stats').innerHTML = `HP:${data.stats.hp} ATK:${data.stats.atk} MATK:${data.stats.matk}<br>DEF:${data.stats.def} MDEF:${data.stats.mdef}`;
        let skills = `<p style="color:#ffd700; margin:5px 0;">[íŠ¹ì„±] ${data.trait.desc}</p>`;
        skills += `<p style="margin:2px 0;">[ì¼ë°˜ ê³µê²©] (Tier 1) ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©</p>`;
        data.skills.forEach(s => {
            let multText = s.val ? ` (x${s.val})` : '';
            skills += `<p style="margin:2px 0;">[${s.name}] (Tier ${s.tier}, MP:${s.cost}) ${s.desc}${multText}</p>`;
        });
        document.getElementById('md-skills').innerHTML = skills;
        document.getElementById('modal-card').classList.add('active');
    },
    closeModal() { document.getElementById('modal-card').classList.remove('active'); },

    openDeck() {
        this.showScreen('screen-deck');
        this.updateDeckSlots();
        this.selectedSlot = -1;
        this.renderCardList('deck-card-list', this.state.inventory, (id) => {
            if(this.selectedSlot === -1) this.selectedSlot = this.state.deck.indexOf(null);
            if(this.selectedSlot === -1) return this.showAlert("ìŠ¬ë¡¯ì„ ë¨¼ì € ì„ íƒí•˜ê±°ë‚˜ ë¹ˆ ìŠ¬ë¡¯ì´ ì—†ìŠµë‹ˆë‹¤.");
            let total = this.state.inventory.filter(x => x === id).length;
            let used = this.state.deck.filter(x => x === id).length;
            if(this.state.deck[this.selectedSlot] === id) used--;
            if(total - used <= 0) return this.showAlert("ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            this.state.deck[this.selectedSlot] = id;
            this.updateDeckSlots();
        });
    },
    selectDeckSlot(idx) { this.selectedSlot = idx; document.querySelectorAll('.deck-slot').forEach((el, i) => { el.style.borderColor = i === idx ? '#ffd700' : '#555'; }); },
    updateDeckSlots() {
        ['ì„ ë´‰', 'ì¤‘ê²¬', 'ëŒ€ì¥'].forEach((role, i) => {
            const id = this.state.deck[i];
            const el = document.getElementById(`slot-${i}`);
            if(id) { const c = CARDS.find(x => x.id === id); el.innerText = `${role}: ${c.name}`; el.classList.add('filled'); }
            else { el.innerText = `${role} (ë¹„ì–´ìˆìŒ)`; el.classList.remove('filled'); }
        });
    },
    confirmDeck() { if(this.state.deck.every(x => x === null)) return this.showAlert("ìµœì†Œ 1ì¥ì˜ ì¹´ë“œëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤."); this.toMenu(); },

    // --- Battle Logic Start ---

    startBattleInit() {
        if(this.state.deck.every(x => x === null)) return this.showAlert("ë±ì„ ì™„ì„±í•´ì£¼ì„¸ìš”.");
        this.showScreen('screen-battle');
        const enemyIdx = this.state.enemyScale % ENEMIES.length;
        const baseEnemy = ENEMIES[enemyIdx];
        let cycle = Math.floor(this.state.enemyScale / ENEMIES.length);
        let scale = 1.0 + (cycle * 0.2);

        this.battle.enemy = {
            id: baseEnemy.id, name: baseEnemy.name,
            maxHp: Math.floor(baseEnemy.stats.hp * scale), hp: Math.floor(baseEnemy.stats.hp * scale),
            atk: Math.floor(baseEnemy.stats.atk * scale), matk: Math.floor(baseEnemy.stats.matk * scale),
            def: Math.floor(baseEnemy.stats.def * scale), mdef: Math.floor(baseEnemy.stats.mdef * scale),
            baseDef: Math.floor(baseEnemy.stats.def * scale), baseMdef: Math.floor(baseEnemy.stats.mdef * scale),
            skills: baseEnemy.skills, buffs: {}, element: baseEnemy.element,
            tookDamageThisTurn: false, lastHitType: null
        };
        if(baseEnemy.id === 'creator_god') this.battle.enemy.chargeTurn = 0;

        // Init Players
        this.battle.players = this.state.deck.map((id, idx) => {
            if(!id) return null;
            const proto = CARDS.find(c => c.id === id);
            let p = {
                id: proto.id, proto: proto, name: proto.name,
                maxHp: proto.stats.hp, hp: proto.stats.hp, mp: 100,
                atk: proto.stats.atk, matk: proto.stats.matk,
                def: proto.stats.def, mdef: proto.stats.mdef,
                buffs: {}, pos: idx, isDead: false, baseCrit: 10, baseEva: 0
            };

            // Apply Chaos Blessing Buffs
            const blessing = this.state.chaosBuffs.find(b => b.id === p.id);
            if(blessing) {
                p.maxHp = Math.floor(p.maxHp * (1 + blessing.multiplier));
                p.hp = p.maxHp; // Heal to full as requested
                p.atk = Math.floor(p.atk * (1 + blessing.multiplier));
                p.matk = Math.floor(p.matk * (1 + blessing.multiplier));
                p.def = Math.floor(p.def * (1 + blessing.multiplier));
                p.mdef = Math.floor(p.mdef * (1 + blessing.multiplier));
                if(blessing.isSage) {
                    p.baseCrit += 10;
                    p.baseEva += 5;
                }
            }

            // Apply Positional Traits
            if(proto.trait.type.startsWith('pos_')) {
                const t = proto.trait;
                let active = (t.type.includes('van') && idx===0) || (t.type.includes('mid') && idx===1) || (t.type.includes('rear') && idx===2);
                if(active) {
                    if(t.type.includes('_atk')) p.atk = Math.floor(p.atk * (1 + t.val/100));
                    if(t.type.includes('_matk')) p.matk = Math.floor(p.matk * (1 + t.val/100));
                    if(t.type.includes('_def')) p.def = Math.floor(p.def * (1 + t.val/100));
                    if(t.type.includes('_mdef')) p.mdef = Math.floor(p.mdef * (1 + t.val/100));
                }
            }
            return p;
        });

        // Identify Synergy Traits (Deck Check)
        this.battle.activeTraits = [];
        const activePlayerCards = this.battle.players.filter(p => p !== null);
        const elements = activePlayerCards.map(p => p.proto.element);

        activePlayerCards.forEach(p => {
             const t = p.proto.trait;
             if(!t.type.startsWith('syn_')) return;

             let active = false;
             if(t.type === 'syn_nature_3_def' && elements.filter(e=>e==='nature').length===3) active = true;
             else if(t.type === 'syn_nature_3_golem' && elements.filter(e=>e==='nature').length===3) active = true;
             else if(t.type === 'syn_water_3_matk' && elements.filter(e=>e==='water').length===3) active = true;
             else if(t.type === 'syn_fire_3_crit' && elements.filter(e=>e==='fire').length===3) active = true;
             else if(t.type === 'syn_dark_3_matk' && elements.filter(e=>e==='dark').length===3) active = true;
             else if(t.type === 'syn_light_fire_atk' && elements.includes('light') && elements.includes('fire')) active = true;
             else if(t.type === 'syn_water_light_matk_mdef' && elements.includes('water') && elements.includes('light')) active = true;
             else if(t.type === 'syn_water_nature' && elements.includes('water') && elements.includes('nature')) {
                 this.battle.activeTraits.push(t.type); // Special handling for Rumi
             }
             else if(t.type === 'syn_nature_3_matk' && elements.filter(e=>e==='nature').length===3) active = true;
             else if(t.type === 'syn_night_rabbit' && this.state.deck.includes('night_rabbit')) active = true;
             else if(t.type === 'syn_snow_rabbit' && this.state.deck.includes('snow_rabbit')) active = true;
             else if(t.type === 'syn_water_3_atk_matk' && elements.filter(e=>e==='water').length===3) active = true;

             if(active) {
                // Stat buffs are applied here, specific logic buffs stored in activeTraits
                this.battle.activeTraits.push(t.type);

                if(t.type === 'syn_nature_3_def') { p.def = Math.floor(p.def * 1.5); p.mdef = Math.floor(p.mdef * 1.5); }
                if(t.type === 'syn_nature_3_golem') { p.atk = Math.floor(p.atk * 1.3); p.def = Math.floor(p.def * 1.3); }
                if(t.type === 'syn_water_3_matk') p.matk = Math.floor(p.matk * 1.5);
                if(t.type === 'syn_nature_3_matk') p.matk = Math.floor(p.matk * 1.5);
                if(t.type === 'syn_fire_3_crit') p.baseCrit += 30;
                if(t.type === 'syn_dark_3_matk') p.matk = Math.floor(p.matk * 1.5);
                if(t.type === 'syn_light_fire_atk') p.atk = Math.floor(p.atk * 1.3);
                if(t.type === 'syn_water_light_matk_mdef') { p.matk = Math.floor(p.matk * 1.3); p.mdef = Math.floor(p.mdef * 1.3); }
                if(t.type === 'syn_night_rabbit') { p.matk = Math.floor(p.matk * 1.5); p.mdef = Math.floor(p.mdef * 1.5); }
                if(t.type === 'syn_snow_rabbit') { p.atk = Math.floor(p.atk * 1.5); p.def = Math.floor(p.def * 1.5); }
                if(t.type === 'syn_water_3_atk_matk') { p.atk = Math.floor(p.atk * 1.5); p.matk = Math.floor(p.matk * 1.5); }
             }
        });

        this.battle.fieldBuffs = [];
        this.battle.delayedEffects = [];
        this.battle.turn = 1;
        this.battle.currentPlayerIdx = 0;
        this.battle.isNewTurn = true;

        while(this.battle.currentPlayerIdx < 3 && this.battle.players[this.battle.currentPlayerIdx] === null) {
            this.battle.currentPlayerIdx++;
        }

        document.getElementById('battle-log').innerHTML = "";
        this.log(`ì „íˆ¬ ê°œì‹œ! ì : ${this.battle.enemy.name}`);
        this.renderBattlefield();
        this.TurnManager.startPlayerTurn();
    },

    // --- Turn Manager ---
    TurnManager: {
        startPlayerTurn() {
            const b = RPG.battle;
            if(b.currentPlayerIdx >= 3) { RPG.loseBattle(); return; }

            if(b.isNewTurn) {
                 b.isNewTurn = false;
                 RPG.log(`=== ${b.turn}í„´ ===`, 'info');

                 // Demon God Passive (Apply at start of turn for visibility)
                 if(b.enemy && b.enemy.id === 'demon_god') {
                     b.enemy.def = b.enemy.baseDef; b.enemy.mdef = b.enemy.baseMdef;
                     if(b.turn % 2 === 0) {
                         b.enemy.def = Math.floor(b.enemy.def * 1.5);
                         RPG.log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: ì§ìˆ˜ í„´ ë¬¼ë¦¬ë°©ì–´ë ¥ 50% ì¦ê°€.");
                     } else {
                         b.enemy.mdef = Math.floor(b.enemy.mdef * 1.5);
                         RPG.log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: í™€ìˆ˜ í„´ ë§ˆë²•ë°©ì–´ë ¥ 50% ì¦ê°€.");
                     }
                 }
            }
            if(b.enemy) b.enemy.lastHitType = null;

            let p = b.players[b.currentPlayerIdx];
            if(!p || p.isDead) {
                b.currentPlayerIdx++;
                this.startPlayerTurn();
                return;
            }

            // Process Delayed Effects
            for(let i = b.delayedEffects.length - 1; i >= 0; i--) {
                let effect = b.delayedEffects[i];
                if(effect.turn === b.turn) {
                    b.delayedEffects.splice(i, 1);
                    if(effect.source.isDead) {
                        RPG.log(`${effect.skill.name} ë°œë™ ì‹¤íŒ¨... (ì‹œì „ì ì‚¬ë§)`);
                    } else {
                        RPG.log(`${effect.skill.name} ë°œë™!`);
                        RPG.executeSkill(effect.source, b.enemy, effect.skill, true);
                    }
                }
            }

            // Clear temporary self buffs
            ['evasion', 'barrier', 'magic_guard', 'guard'].forEach(k => delete p.buffs[k]);

            RPG.renderBattlefield();

            if(p.buffs.stun) {
                RPG.log(`${p.name} ê¸°ì ˆë¡œ ì¸í•´ í–‰ë™ ë¶ˆê°€.`);
                delete p.buffs.stun;
                this.endPlayerTurn();
                return;
            }

            RPG.setupControls(p);
        },

        endPlayerTurn() {
             setTimeout(() => this.startEnemyTurn(), 500);
        },

        startEnemyTurn() {
            const b = RPG.battle;
            const e = b.enemy;
            if(e.hp <= 0) { RPG.winBattle(); return; }

            RPG.log("--- ì  í„´ ---");
            e.def = e.baseDef; e.mdef = e.baseMdef; // Reset base

            // Boss Passive Logic
            if(e.id === 'artificial_demon_god') {
                 delete e.buffs.defProtocolPhy; delete e.buffs.defProtocolMag;
                 if(e.lastHitType === 'phy') { e.buffs.defProtocolPhy = 1; RPG.log("ë°©ì–´ í”„ë¡œí† ì½œ: ë¬¼ë¦¬ í”¼ê²© ê°ì§€ (ë‹¤ìŒ í„´ ë¬¼ë¦¬ë°©ì–´ë ¥ ì¦ê°€)."); }
                 if(e.lastHitType === 'mag') { e.buffs.defProtocolMag = 1; RPG.log("ë°©ì–´ í”„ë¡œí† ì½œ: ë§ˆë²• í”¼ê²© ê°ì§€ (ë‹¤ìŒ í„´ ë§ˆë²•ë°©ì–´ë ¥ ì¦ê°€)."); }
                 if(e.buffs.defProtocolPhy) e.def = Math.floor(e.def * 1.5);
                 if(e.buffs.defProtocolMag) e.mdef = Math.floor(e.mdef * 1.5);
            }
            if(e.id === 'demon_god') {
                 // Re-apply without log (applied at start of player turn)
                 if(b.turn % 2 === 0) { e.def = Math.floor(e.def * 1.5); }
                 else { e.mdef = Math.floor(e.mdef * 1.5); }
            }

            if(e.buffs.stun) {
                RPG.log(`${e.name} ê¸°ì ˆí•˜ì—¬ í–‰ë™ ë¶ˆê°€.`);
                delete e.buffs.stun;
                this.endEnemyTurn();
                return;
            }

            // Target Logic
            let target = b.players[b.currentPlayerIdx];
            if(!target || target.isDead) {
                let validIdx = b.players.findIndex(p => p && !p.isDead);
                if(validIdx === -1) { RPG.loseBattle(); return; }
                b.currentPlayerIdx = validIdx;
                target = b.players[validIdx];
            }

            // AI Skill Selection
            let skill = RPG.EnemyAI.selectSkill(e, b.turn);

            // Creator God Charge Handling
            if(e.id === 'creator_god' && skill.name === 'ì°¨ì§€') {
                 RPG.log("ì°½ì¡°ì‹ ì´ í˜ì„ ëª¨ìœ¼ê³  ìˆìŠµë‹ˆë‹¤... (ê³µê²© ì—†ìŒ)");
                 this.endEnemyTurn();
                 return;
            }

            // Execute Enemy Skill (Simplified: Calculate -> Apply)
            let val = skill.type === 'phy' ? e.atk : e.matk;
            let mult = skill.val || 1.0;

            // Pharaoh Special Counter Logic
            if(e.id === 'pharaoh' && skill.name === 'ê³ ëŒ€ì˜ì €ì£¼' && e.tookDamageThisTurn) {
                mult = 3.0;
                RPG.log("ê³ ëŒ€ì˜ ì €ì£¼: í„´ ë‚´ í”¼ê²© ê°ì§€! ëŒ€ë¯¸ì§€ 3ë°°ë¡œ ë°˜ê²©!");
            }

            if(e.buffs.weak && skill.type === 'phy') val *= 0.8;
            if(e.buffs.silence && skill.type === 'mag') val *= 0.8;

            let def = skill.type === 'phy' ? target.def : target.mdef;
            let fieldDef = 1.0;
            b.fieldBuffs.forEach(fb => {
                if(fb.name === 'star_powder') fieldDef += 0.3;
                if(fb.name === 'sanctuary' && skill.type === 'mag') fieldDef += 0.25;
                if(fb.name === 'goddess_descent') fieldDef += 0.3;
            });

            // Target Defense Debuffs
            let defMult = 1.0;
            if (skill.type === 'phy') {
                if (target.buffs.darkness && target.buffs.corrosion) defMult = 0.6;
                else if (target.buffs.darkness || target.buffs.corrosion) defMult = 0.8;
            } else {
                if (target.buffs.curse) defMult = 0.8;
            }

            def = Math.floor(def * fieldDef * defMult);

            // Evasion Check
            let eva = 5;
            b.fieldBuffs.forEach(fb => { if(fb.name === 'moon_bless') eva += 15; });
            if(target.proto.trait.type === 'cond_no_field_buff_eva' && b.fieldBuffs.length === 0) eva += 30;
            if(target.proto.trait.type === 'cond_no_field_buff_eva_crit' && b.fieldBuffs.length === 0) eva += target.proto.trait.val;
            if(target.buffs.evasion) eva += 50;

            if(Math.random()*100 < eva) {
                RPG.log(`${target.name} íšŒí”¼ ì„±ê³µ! (${skill.name} íšŒí”¼)`);
                this.endEnemyTurn();
                return;
            }
            if(target.buffs.barrier && skill.type === 'phy') { RPG.log(`${target.name} ë°°ë¦¬ì–´ë¡œ ë°©ì–´!`); this.endEnemyTurn(); return; }
            if(target.buffs.magic_guard && skill.type === 'mag') { RPG.log(`${target.name} ë§¤ì§ê°€ë“œë¡œ ë°©ì–´!`); this.endEnemyTurn(); return; }

            let dmg = val * mult * (100 / (100 + def));
            if(target.buffs.guard) dmg *= 0.5;
            dmg = Math.floor(dmg);
            target.hp -= dmg;
            RPG.log(`${e.name}ì˜ ${skill.name}! <span class="log-dmg">${dmg}</span> í”¼í•´.`);

            // Process Effects (if any)
            if(skill.effects) {
                skill.effects.forEach(eff => {
                    if(eff.type === 'mana_burn') { target.mp = 0; RPG.log("í”Œë ˆì´ì–´ ë§ˆë‚˜ ì†Œë©¸!"); }
                });
            }

            if(target.hp <= 0) {
                target.isDead = true; target.hp = 0;
                RPG.log(`${target.name} ì“°ëŸ¬ì§!`);
                RPG.handleDeathTraits(target, e);

                // Advance to next valid player
                b.currentPlayerIdx++;
                while(b.currentPlayerIdx < 3) {
                     if(b.players[b.currentPlayerIdx] && !b.players[b.currentPlayerIdx].isDead) break;
                     b.currentPlayerIdx++;
                }
                if(b.currentPlayerIdx >= 3 && b.players.every(p => !p || p.isDead)) { RPG.loseBattle(); return; }
            }

            if(e.hp <= 0) RPG.winBattle();
            else this.endEnemyTurn();
        },

        endEnemyTurn() {
            RPG.battle.turn++;
            RPG.battle.enemy.tookDamageThisTurn = false;
            RPG.battle.isNewTurn = true;
            this.startPlayerTurn();
        }
    },

    EnemyAI: {
        selectSkill(e, turn) {
            let skill = null;
            let r = Math.random();

            if(e.id === 'artificial_demon_god') {
                if(turn === 10) skill = e.skills.find(s => s.name === 'íŒŒê´´ì˜í˜•íƒœ');
                else if(r < 0.3) skill = e.skills.find(s => s.name === 'ì•„ì´ìŠ¤ë¹”');
            }
            else if(e.id === 'iris_love') {
                if(turn === 7) skill = e.skills.find(s => s.name === 'ì†Œìš¸ë“œë ˆì¸');
                else if(r < 0.1) skill = e.skills.find(s => s.name === 'ë”í™€ë¦¬');
                else if(r < 0.4) skill = e.skills.find(s => s.name === 'í™€ë¦¬ë ˆì´'); // 0.1 ~ 0.4 (30%)
            }
            else if(e.id === 'iris_curse') {
                if(turn === 10) skill = e.skills.find(s => s.name === 'ì•„í¬ì¹¼ë¦½ìŠ¤');
                else if(r < 0.3) skill = e.skills.find(s => s.name === 'í”„ë ˆì„ìƒ·');
            }
            else if(e.id === 'pharaoh') {
                if(turn % 5 === 0) skill = e.skills.find(s => s.name === 'ê³ ëŒ€ì˜ì €ì£¼');
                else if(r < 0.3) skill = e.skills.find(s => s.name === 'ê³ ëŒ€ì˜í˜');
            }
            else if(e.id === 'demon_god') {
                if(turn === 7 || turn === 14) skill = e.skills.find(s => s.name === 'ì œë…¸ì‚¬ì´ë“œ');
                else if(r < 0.2) skill = e.skills.find(s => s.name === 'ë‹¤í¬ë‹ˆìŠ¤');
            }
            else if(e.id === 'creator_god') {
                if(e.isCharging) {
                    RPG.log("ì°½ì¡°ì‹ ì´ í˜ì„ ëª¨ìœ¼ê³  ìˆìŠµë‹ˆë‹¤...");
                    skill = e.skills.find(s => s.name === 'ë””ë°”ì¸ë¸”ë ˆì´ë“œ');
                    e.isCharging = false;
                }
                else if(turn === 1) {
                    return { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' };
                }
                else if(turn === 2) {
                    skill = e.skills.find(s => s.name === 'ì €ì§€ë¨¼íŠ¸');
                }
                else {
                    // Turn >= 3
                    // 30% Holy Ray (or Judgment if Turn > 15)
                    // 20% Divine Blade (Charge)
                    // 50% Normal Attack
                    if(r < 0.3) {
                         if(turn > 15) skill = e.skills.find(s => s.name === 'ì €ì§€ë¨¼íŠ¸');
                         else skill = e.skills.find(s => s.name === 'í™€ë¦¬ë ˆì´');
                    }
                    else if(r < 0.5) { // 30% ~ 50% range (20%)
                        RPG.log("ì°½ì¡°ì‹ ì´ ìì„¸ë¥¼ ì¡ìŠµë‹ˆë‹¤ (ì°¨ì§€ì¤‘...)");
                        e.isCharging = true;
                        return { type: 'phy', val: 0, name: 'ì°¨ì§€' };
                    }
                    else {
                        return { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' };
                    }
                }
            }

            // Fallback: Use other valid skills if not selected
            if(!skill && Math.random() < 0.3 && e.skills.length > 0) {
                 // Excluding specific skills that have rate 0.0
                 const validSkills = e.skills.filter(s => s.rate > 0);
                 if(validSkills.length > 0) {
                     skill = validSkills[Math.floor(Math.random() * validSkills.length)];
                 }
            }
            return skill || { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' };
        }
    },

    handleDeathTraits(victim, killer) {
        const t = victim.proto.trait;
        if(t.type === 'death_dmg_mag') {
            let dummySkill = { name: 'ì‚¬ë§ ë°˜ê²©', type: 'mag', val: t.val, effects: [] };
            let dmgResult = this.calcDamage(victim, killer, dummySkill);
            if(dmgResult.dmg > 0) {
                killer.hp -= dmgResult.dmg;
                killer.tookDamageThisTurn = true;
                RPG.log(`[íŠ¹ì„±] ì‚¬ë§ ë°˜ê²©! ${dmgResult.isCrit?'Critical! ':''}<span class="log-dmg">${dmgResult.dmg}</span> í”¼í•´.`);
            }
        }
        else if(t.type === 'death_dmg_debuff') {
            let cnt = Object.keys(killer.buffs).length;
            let dummySkill = { name: 'ì €ì£¼ ë°˜ê²©', type: 'mag', val: cnt * t.val, effects: [] };
            let dmgResult = this.calcDamage(victim, killer, dummySkill);
            if(dmgResult.dmg > 0) {
                killer.hp -= dmgResult.dmg;
                killer.tookDamageThisTurn = true;
                RPG.log(`[íŠ¹ì„±] ì €ì£¼ ë°˜ê²©! ${dmgResult.isCrit?'Critical! ':''}<span class="log-dmg">${dmgResult.dmg}</span> í”¼í•´.`);
            }
        }
        else if(t.type === 'death_field_sun') {
            RPG.applyFieldBuff('sun_bless');
        }
        else if(t.type === 'death_stun') {
             if (killer && killer.buffs) {
                 killer.buffs.stun = 1;
                 RPG.log(`[íŠ¹ì„±] ì‚¬ë§ ì‹œ ìŠ¤í„´ ë°œë™! ì ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤.`);
             }
        }
        else if(t.type === 'death_sun_bless_chance') {
             if(Math.random() < t.val) {
                 RPG.applyFieldBuff('sun_bless');
                 RPG.log(`[íŠ¹ì„±] ë§ˆì‹œë©œë¡œê°€ ë…¹ìœ¼ë©° íƒœì–‘ì˜ ì¶•ë³µì„ ë‚¨ê¹ë‹ˆë‹¤!`);
             } else {
                 RPG.log(`[íŠ¹ì„±] ë§ˆì‹œë©œë¡œê°€ í”ì ë„ ì—†ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤... (ì¶•ë³µ ì‹¤íŒ¨)`);
             }
        }
        else if(t.type === 'death_field_buff_count_dmg') {
             let count = RPG.battle.fieldBuffs.length;
             let dummySkill = { name: 'ì‚¬ë§ ë°˜ê²©', type: 'mag', val: count * t.val, effects: [] };
             let dmgResult = this.calcDamage(victim, killer, dummySkill);
             if(dmgResult.dmg > 0) {
                 killer.hp -= dmgResult.dmg;
                 killer.tookDamageThisTurn = true;
                 RPG.log(`[íŠ¹ì„±] ì‚¬ë§ ë°˜ê²©! (í•„ë“œë²„í”„ ${count}ê°œ) ${dmgResult.isCrit?'Critical! ':''}<span class="log-dmg">${dmgResult.dmg}</span> í”¼í•´.`);
             }
        }
    },

    // --- Player Skill Execution ---

    executeSkill(source, target, skill, isDelayed=false) {
        if(!isDelayed && !skill.isDelayed) source.mp -= skill.cost;
        RPG.log(`<b>${source.name}</b>ì˜ <b>${skill.name}</b>!`);

        // Trait: Normal Attack Burn & Divine
        if (skill.name === RPG.NORMAL_ATTACK.name && source.proto.trait && source.proto.trait.type === 'normal_attack_burn_divine') {
             target.buffs['burn'] = (target.buffs['burn'] || 0) + 1;
             target.buffs['divine'] = (target.buffs['divine'] || 0) + 1;
             if(target.buffs['burn'] > 3) target.buffs['burn'] = 3;
             if(target.buffs['divine'] > 3) target.buffs['divine'] = 3;
             RPG.log("[íŠ¹ì„±] ì¼ë°˜ ê³µê²© ì¶”ê°€ íš¨ê³¼: ì‘ì—´, ë””ë°”ì¸ ë¶€ì—¬!");
        }

        // Check for Delayed Attack Effect
        const delayedEff = skill.effects && skill.effects.find(e => e.type === 'delayed_attack');
        if(delayedEff && !isDelayed) {
            RPG.log(`ì¢…ì–¸ì˜ ì˜ˆê³ ê°€ ì‹œì‘ë©ë‹ˆë‹¤... (${delayedEff.turns}í„´ ë’¤ ë°œë™)`);
            RPG.battle.delayedEffects.push({ turn: RPG.battle.turn + delayedEff.turns, source: source, skill: skill });
            RPG.TurnManager.endPlayerTurn();
            return;
        }

        const dmgResult = this.calcDamage(source, target, skill);

        // Apply Damage
        if(dmgResult.dmg > 0) {
            target.hp -= dmgResult.dmg;
            target.tookDamageThisTurn = true;
            RPG.log(`${dmgResult.isCrit?'Critical! ':''}ì ì—ê²Œ <span class="log-dmg">${dmgResult.dmg}</span> í”¼í•´.`);
        }

        // Apply Side Effects (Buffs, Debuffs, Field, Suicide, etc.)
        this.applySkillEffects(source, target, skill);

        if(target.hp <= 0) { RPG.winBattle(); return; }
        if(source.hp <= 0 && !source.isDead) { source.isDead = true; RPG.log(`${source.name} ì‚¬ë§!`); }

        if(!isDelayed) RPG.TurnManager.endPlayerTurn();
    },

    calcDamage(source, target, skill) {
        if(skill.type !== 'phy' && skill.type !== 'mag') return { dmg: 0 };

        // 1. Base Stats
        let atkMult = 1.0, matkMult = 1.0, crit = source.baseCrit, critDmg = 150;
        RPG.battle.fieldBuffs.forEach(fb => {
             if(fb.name === 'sun_bless') { atkMult += 0.3; matkMult += 0.3; critDmg += 60; }
             if(fb.name === 'moon_bless') { matkMult += 0.3; }
             if(fb.name === 'sanctuary') { matkMult += 0.30; }
             if(fb.name === 'goddess_descent') { atkMult += 0.3; matkMult += 0.3; }
             if(fb.name === 'earth_bless') { atkMult += 0.25; matkMult += 0.25; }
             if(fb.name === 'twinkle_party') { atkMult += 0.2; crit += 15; }
        });

        // Weakness Debuff (Applies to Source)
        if (source.buffs.weak) {
            atkMult -= 0.2;
        }
        if (source.buffs.silence) {
            matkMult -= 0.2;
        }

        // Trait: Twinkle Party (Fresh Cream Maid)
        if(source.proto.trait.type === 'cond_twinkle_all' && RPG.battle.fieldBuffs.some(b=>b.name==='twinkle_party')) {
            atkMult *= 1.3;
            matkMult *= 1.3;
        }

        // Trait: Luna (No Field Buff -> Crit +25)
        if(source.proto.trait.type === 'cond_no_field_buff_eva_crit' && RPG.battle.fieldBuffs.length === 0) {
            crit += source.proto.trait.val;
        }

        let val = (skill.type === 'phy' ? source.atk * Math.max(0, atkMult) : source.matk * Math.max(0, matkMult));
        let mult = skill.val;
        let dmgBonus = 0.0;

        // 2. Elemental
        let elMult = this.getElementalMultiplier(source.proto.element, target.element);
        if(elMult > 1.0) RPG.log("ìƒì„± ìš°ìœ„! ëŒ€ë¯¸ì§€ 20% ì¦ê°€.");

        // 3. Skill-Specific Multipliers (from Effects)
        if(skill.effects) {
            skill.effects.forEach(eff => {
                if(eff.type === 'consume_field_all') {
                    let c = RPG.battle.fieldBuffs.length;
                    if(c > 0) {
                        mult += (c * eff.multPerStack);
                        RPG.battle.fieldBuffs = [];
                        RPG.log(`í•„ë“œ ë²„í”„ ${c}ê°œ ì œê±°! ìœ„ë ¥ í­ë°œ!`);
                    }
                }
                else if(eff.type === 'consume_debuff_all') {
                    if(target.buffs[eff.debuff]) {
                        let c = target.buffs[eff.debuff];
                        mult += (c * eff.multPerStack);
                        delete target.buffs[eff.debuff];
                        RPG.log(`${this.BUFF_NAMES[eff.debuff]} ${c}ìŠ¤íƒ ì†Œëª¨!`);
                    }
                }
                else if(eff.type === 'dmg_boost') {
                     if(eff.condition === 'target_debuff' && target.buffs[eff.debuff]) {
                         mult *= eff.mult;
                         RPG.log(`[íŠ¹ì„±] ${this.BUFF_NAMES[eff.debuff]} ëŒ€ìƒ ì¶”ê°€ í”¼í•´! (ë°°ìœ¨ x${eff.mult})`);
                     }
                     else if(eff.condition === 'synergy_active' && RPG.battle.activeTraits.includes(eff.trait)) {
                         mult *= eff.mult;
                         RPG.log(`[ì‹œë„ˆì§€] ì¡°ê±´ ë§Œì¡±! ìœ„ë ¥ ${eff.mult}ë°° ì¦ê°€!`);
                     }
                     else if(eff.condition === 'target_stack' && target.buffs[eff.debuff]) mult += (target.buffs[eff.debuff] * eff.multPerStack);
                     else if(eff.condition === 'target_debuff_count_scale') {
                         let bonus = (Object.keys(target.buffs).length * eff.multPerDebuff);
                         mult += bonus;
                         if(bonus > 0) RPG.log(`[íŠ¹ì„±] ë””ë²„í”„ ëŒ€ìƒ ì¶”ê°€ í”¼í•´! (ë°°ìœ¨ +${bonus.toFixed(1)})`);
                     }
                     else if(eff.condition === 'hp_below' && (source.hp/source.maxHp) <= eff.val) {
                         mult *= eff.mult;
                         if(skill.name === 'ë¼ê·¸ë‚˜ë¡œí¬') RPG.log("ë¼ê·¸ë‚˜ë¡œí¬: ìƒëª…ë ¥ ì¡°ê±´ ë§Œì¡±! ëŒ€ë¯¸ì§€ ì¦ê°€!");
                     }
                     else if(eff.condition === 'hp_full' && source.hp === source.maxHp) {
                         mult *= eff.mult;
                         if(eff.log) RPG.log(eff.log);
                     }
                     else if(eff.condition === 'field_buff' && RPG.battle.fieldBuffs.some(b=>b.name === eff.buff)) mult *= eff.mult;
                }
                else if(eff.type === 'consume_burn_1_dmg') {
                     if(target.buffs['burn'] >= 1) {
                         mult *= eff.mult;
                         // RPG.log("ì‘ì—´ ì†Œë¹„ ì¡°ê±´ ë§Œì¡±! ìœ„ë ¥ ì¦ê°€!"); // Logged in applySkillEffects for clarity on consumption
                     }
                }
                else if(eff.type === 'remove_field_buff_dmg') {
                     if(RPG.battle.fieldBuffs.length > 0) {
                         mult *= eff.mult;
                     }
                }
                else if(eff.type === 'cond_target_debuff_3_dmg') {
                     if(Object.keys(target.buffs).length >= 3) {
                         mult *= eff.mult;
                         RPG.log("ì  ë””ë²„í”„ 3ê°œ ì´ìƒ! ìœ„ë ¥ 2ë°°!");
                     }
                }
                else if(eff.type === 'random_mult') {
                    mult = eff.min + Math.floor(Math.random() * (eff.max - eff.min + 1));
                    RPG.log(`ë¬´ì‘ìœ„ ìœ„ë ¥! x${mult.toFixed(1)}`);
                }
            });
        }

        // 4. Trait Multipliers
        const t = source.proto.trait;
        if(t.type === 'cond_silence_dmg' && target.buffs.silence) {
            dmgBonus += (t.val - 1.0);
            RPG.log("[íŠ¹ì„±] ì¹¨ë¬µ ëŒ€ìƒ ì¶”ê°€ í”¼í•´!");
        }
        if(t.type === 'cond_corrosion_dmg' && target.buffs.corrosion) {
            dmgBonus += (t.val - 1.0);
            RPG.log("[íŠ¹ì„±] ë¶€ì‹ ëŒ€ìƒ ì¶”ê°€ í”¼í•´!");
        }
        if(t.type === 'cond_debuff_3_dmg' && Object.keys(target.buffs).length >= 3) {
            dmgBonus += (t.val - 1.0);
            RPG.log("[íŠ¹ì„±] ë””ë²„í”„ 3ê°œ ì´ìƒ ëŒ€ìƒ ì¶”ê°€ í”¼í•´!");
        }
        if(t.type === 'cond_divine_3_dmg' && target.buffs.divine >= 3) {
            dmgBonus += (t.val - 1.0);
            RPG.log("[íŠ¹ì„±] ë””ë°”ì¸ 3ìŠ¤íƒ ì´ìƒ ëŒ€ìƒ ì¶”ê°€ í”¼í•´!");
        }

        // 5. Defense Calculation
        let isCrit = Math.random() * 100 < crit;
        if(isCrit) val *= (critDmg / 100);

        let def = skill.type === 'phy' ? target.def : target.mdef;
        let defRed = 0.0;

        if (skill.type === 'phy') {
            if (target.buffs.darkness && target.buffs.corrosion) {
                defRed = 0.4;
            } else if (target.buffs.darkness || target.buffs.corrosion) {
                defRed = 0.2;
            }
        } else {
            if (target.buffs.curse) {
                defRed = 0.2;
            }
        }

        def = Math.floor(def * (1.0 - defRed));

        let finalMult = mult * elMult * (1.0 + dmgBonus);
        let finalDmg = Math.floor(val * finalMult * (100 / (100 + def)));

        if(target.id === 'demon_god') {
             const b = RPG.battle;
             if((b.turn % 2 === 0 && skill.type === 'phy') || (b.turn % 2 !== 0 && skill.type === 'mag')) {
                 RPG.log("(ë§ˆì‹ ì˜ ê¶ŒëŠ¥: ë°©ì–´ë ¥ ìƒìŠ¹ ì ìš©ì¤‘)");
             }
        }

        target.lastHitType = skill.type;

        return { dmg: finalDmg, isCrit: isCrit };
    },

    applySkillEffects(source, target, skill) {
        if(!skill.effects) return;

        skill.effects.forEach(eff => {
            if(eff.type === 'buff') {
                source.buffs[eff.id] = (eff.duration || 1);
            }
            else if(eff.type === 'debuff' || eff.type === 'self_debuff') {
                let t = eff.type === 'debuff' ? target : source;
                if(eff.stack) {
                    t.buffs[eff.id] = (t.buffs[eff.id] || 0) + 1;
                    if(t.buffs[eff.id] > 3) t.buffs[eff.id] = 3;
                    RPG.log(`${t === source ? 'ìì‹ ' : 'ì '}ì—ê²Œ [${this.BUFF_NAMES[eff.id]}] ${t.buffs[eff.id]}ìŠ¤íƒ.`);
                } else {
                    t.buffs[eff.id] = 1; // Flag or duration 1
                    RPG.log(`${t === source ? 'ìì‹ ' : 'ì '}ì—ê²Œ [${this.BUFF_NAMES[eff.id]}] ë¶€ì—¬.`);
                }
            }
            else if(eff.type === 'field_buff') {
                this.applyFieldBuff(eff.id);
            }
            else if(eff.type === 'conditional_field_buff') {
                if(eff.condition === 'target_has_debuff' && target.buffs[eff.debuff]) this.applyFieldBuff(eff.id);
            }
            else if(eff.type === 'random_debuff') {
                let pool = [...eff.pool].sort(() => 0.5 - Math.random());
                for(let i=0; i<eff.count; i++) {
                    if(pool[i]) {
                         target.buffs[pool[i]] = 1;
                         RPG.log(`ì ì—ê²Œ [${this.BUFF_NAMES[pool[i]]}] ë¶€ì—¬.`);
                    }
                }
            }
            else if(eff.type === 'conditional_debuff') {
                if(eff.condition === 'target_debuff_count' && Object.keys(target.buffs).length >= eff.count) {
                    target.buffs[eff.debuff] = 1;
                    RPG.log(`ì¡°ê±´ ë§Œì¡±! ì ì—ê²Œ [${this.BUFF_NAMES[eff.debuff]}] ë¶€ì—¬.`);
                }
            }
            else if(eff.type === 'suicide') {
                source.hp = 0;
            }
            else if(eff.type === 'chance_debuff') {
                if(Math.random() < eff.chance) {
                    target.buffs[eff.id] = eff.duration || 1;
                    RPG.log(`<b>ì„±ê³µ!</b> ${target === source ? 'ìì‹ ' : 'ì '}ì—ê²Œ [${this.BUFF_NAMES[eff.id]}] ë¶€ì—¬.`);
                } else {
                    RPG.log(`[${this.BUFF_NAMES[eff.id]}] ë¶€ì—¬ <b>ì‹¤íŒ¨</b>.`);
                }
            }
            else if(eff.type === 'conditional_field_debuff') {
                 if(RPG.battle.fieldBuffs.some(b => b.name === eff.field)) {
                     eff.debuffs.forEach(d => {
                         target.buffs[d] = 1;
                         RPG.log(`ì¡°ê±´ ë§Œì¡±! [${this.BUFF_NAMES[d]}] ë¶€ì—¬.`);
                     });
                 }
            }
            else if(eff.type === 'clear_target_debuffs') {
                 const count = Object.keys(target.buffs).length;
                 target.buffs = {};
                 if(count > 0) RPG.log(`ì ì˜ ëª¨ë“  ë””ë²„í”„ë¥¼ ì œê±°í–ˆìŠµë‹ˆë‹¤! (${count}ê°œ)`);
            }
            else if(eff.type === 'consume_all_burn_cond_buff') {
                 if(target.buffs['burn']) {
                     delete target.buffs['burn'];
                     RPG.applyFieldBuff('sun_bless');
                     RPG.log("ì‘ì—´ ìŠ¤íƒì„ ëª¨ë‘ ì†Œëª¨í•˜ì—¬ íƒœì–‘ì˜ ì¶•ë³µì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤!");
                 } else {
                     RPG.applyFieldBuff('earth_bless');
                     RPG.log("ì†Œëª¨í•  ì‘ì—´ì´ ì—†ì–´ ëŒ€ì§€ì˜ ì¶•ë³µì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.");
                 }
            }
            else if(eff.type === 'consume_burn_1_dmg') {
                 if(target.buffs['burn'] >= 1) {
                     target.buffs['burn']--;
                     if(target.buffs['burn'] <= 0) delete target.buffs['burn'];
                     RPG.log("ì‘ì—´ 1ìŠ¤íƒ ì†Œëª¨! ëŒ€ë¯¸ì§€ 2ë°° ì ìš©!");
                 }
            }
            else if(eff.type === 'remove_field_buff_dmg') {
                 if(RPG.battle.fieldBuffs.length > 0) {
                     let rm = RPG.battle.fieldBuffs.shift();
                     RPG.log(`í•„ë“œë²„í”„ [${this.BUFF_NAMES[rm.name]}] ì œê±°! ëŒ€ë¯¸ì§€ 2ë°° ì ìš©!`);
                 }
            }
        });

        // Special Rumi Trait Trigger
        if(RPG.battle.activeTraits.includes('syn_water_nature') && skill.name === 'ë¬¸ë¼ì´íŠ¸ì„¸ë ˆë‚˜') {
            RPG.log("ë£¨ë¯¸ì˜ íŠ¹ì„± ë°œë™! íŠ¸ìœ™í´íŒŒí‹° ì¶”ê°€!");
            this.applyFieldBuff('twinkle_party');
        }
    },

    applyFieldBuff(id) {
        if(this.battle.fieldBuffs.some(b => b.name === id)) return RPG.log(`í•„ë“œë²„í”„ [${this.BUFF_NAMES[id]}] ì´ë¯¸ ì¡´ì¬.`);
        if(this.battle.fieldBuffs.length >= 3) {
             let removed = this.battle.fieldBuffs.shift();
             RPG.log(`í•„ë“œë²„í”„ [${this.BUFF_NAMES[removed.name]}] ì†Œë©¸.`);
        }
        this.battle.fieldBuffs.push({ name: id });
        RPG.log(`í•„ë“œë²„í”„ [${this.BUFF_NAMES[id]}] ë°œë™!`);
    },

    // --- Setup & UI ---

    setupControls(p) {
        const panel = document.getElementById('battle-controls');
        panel.innerHTML = "";

        // Normal Attack
        const btn = document.createElement('button');
        btn.className = 'skill-btn phy';
        btn.innerHTML = `<span>ì¼ë°˜ê³µê²©</span><span style="color:#aaa">MP 0</span>`;
        btn.onclick = () => RPG.executeSkill(p, RPG.battle.enemy, RPG.NORMAL_ATTACK);
        panel.appendChild(btn);

        // Skills
        p.proto.skills.forEach(s => {
            const btn = document.createElement('button');
            btn.className = `skill-btn ${s.type}`;
            btn.innerHTML = `<span>${s.name}</span><span style="color:#aaa">MP ${s.cost}</span>`;
            if(p.mp < s.cost) btn.disabled = true;
            else btn.onclick = () => RPG.executeSkill(p, RPG.battle.enemy, s);
            panel.appendChild(btn);
        });
    },

    renderBattlefield() {
        const p = this.battle.players[this.battle.currentPlayerIdx];

        if(p && !p.isDead) {
            document.getElementById('p-name').innerText = p.name;
            const pImg = document.getElementById('p-img');
            pImg.src = `${p.name}.png`;
            pImg.style.display = 'block';

            let hpPct = (p.hp / p.maxHp) * 100;
            document.getElementById('p-hp-bar').style.width = `${Math.max(0, hpPct)}%`;
            let mpPct = (p.mp / 100) * 100;
            document.getElementById('p-mp-bar').style.width = `${Math.max(0, mpPct)}%`;

            let buffTxt = Object.keys(p.buffs).map(k=>this.BUFF_NAMES[k]||k).join(',');
            document.getElementById('p-buffs').innerText = buffTxt;
            document.getElementById('player-actor-box').style.opacity = 1;
        } else {
             document.getElementById('player-actor-box').style.opacity = 0;
        }

        const e = this.battle.enemy;
        let eHpPct = (e.hp / e.maxHp) * 100;
        document.getElementById('e-hp-bar').style.width = `${Math.max(0, eHpPct)}%`;
        document.getElementById('e-name').innerText = e.name;
        const eImg = document.getElementById('e-img');
        eImg.src = `${e.name}.png`;
        eImg.style.display = 'block';

        let eBuffTxt = Object.keys(e.buffs).map(k=>`${this.BUFF_NAMES[k]||k}${e.buffs[k]>1?e.buffs[k]:''}`).join(' ');
        document.getElementById('e-buffs').innerText = eBuffTxt;

        document.getElementById('bt-turn').innerText = this.battle.turn;
        document.getElementById('field-buff-box').innerHTML = this.battle.fieldBuffs.map(b => `[${this.BUFF_NAMES[b.name]||b.name}]`).join(" ");
    },

    getElementalMultiplier(atkEl, defEl) {
        if(atkEl === 'water' && defEl === 'fire') return 1.2;
        if(atkEl === 'fire' && defEl === 'nature') return 1.2;
        if(atkEl === 'nature' && defEl === 'water') return 1.2;
        if((atkEl === 'light' && defEl === 'dark') || (atkEl === 'dark' && defEl === 'light')) return 1.2;
        return 1.0;
    },

    handlePermadeath(players) {
        let deadNames = [];
        players.forEach(p => {
            if(p && p.isDead) {
                let idx = this.state.inventory.indexOf(p.id);
                if(idx > -1) this.state.inventory.splice(idx, 1);
                if(p.pos !== undefined) this.state.deck[p.pos] = null;
                deadNames.push(p.name);
            }
        });
        if(deadNames.length > 0) return `ì „ì‚¬ì ë°œìƒ: ${deadNames.join(', ')}<br>(ì¹´ë“œê°€ ì†Œë©¸í–ˆìŠµë‹ˆë‹¤)`;
        return "";
    },

    winBattle() {
        let deadMsg = this.handlePermadeath(this.battle.players);
        let reward = 1;
        if(this.battle.players.some(p => p && p.proto.trait.type === 'looter')) reward += 1;

        this.state.tickets += reward;
        this.state.enemyScale++;

        // Reset Chaos Blessing
        this.state.chaosBlessingUses = 3;
        this.state.chaosBuffs = [];
        this.state.activeChaosBlessing = [];
        this.state.activeSageBlessing = [];

        this.log(`ìŠ¹ë¦¬ ë³´ìƒ: ë½‘ê¸°ê¶Œ ${reward}ì¥ íšë“.`);

        let msg = "ìŠ¹ë¦¬!<br>ë³´ìƒì„ íšë“í–ˆìŠµë‹ˆë‹¤.";
        if (deadMsg) msg += "<br><br>" + deadMsg;

        this.openInfoModal("ì „íˆ¬ ê²°ê³¼", msg, () => {
             // Creator God Bonus Check
             if (this.battle.enemy.id === 'creator_god') {
                 this.showConfirm("ì°½ì¡°ì‹  ê²©íŒŒ ë³´ë„ˆìŠ¤! ë¬¸ë²• í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ë½‘ê¸°ê¶Œ 3ì¥ íšë“)",
                    () => { // Yes
                        let allQuizzes = [];
                        GRAMMAR_DATA.forEach(lec => { allQuizzes = allQuizzes.concat(lec.quizzes); });
                        let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

                        this.startGrammarQuiz(q,
                            () => { // Success
                                this.state.tickets += 3;
                                document.getElementById('ui-tickets').innerText = this.state.tickets;
                                this.showAlert("ì •ë‹µ! ë“œë¡œìš°ê¶Œ 3ì¥ì„ ì¶”ê°€ë¡œ íšë“í–ˆìŠµë‹ˆë‹¤.");
                                this.toMenu();
                            },
                            () => { // Fail
                                this.showAlert("ì˜¤ë‹µì…ë‹ˆë‹¤... ë³´ìƒ ì—†ìŒ.");
                                this.toMenu();
                            }
                        );
                    },
                    () => { // No
                        this.toMenu();
                    }
                 );
             } else {
                 // Quiz Challenge Prompt using Custom Modal
                 this.showConfirm("ì¶”ê°€ ë³´ìƒì„ ìœ„í•œ í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ë“œë¡œìš°ê¶Œ 1ì¥ íšë“)",
                    // Yes Callback
                    () => {
                         this.startQuiz((success) => {
                             if(success) {
                                 this.state.tickets += 1;
                                 document.getElementById('ui-tickets').innerText = this.state.tickets;
                                 this.showAlert("ì •ë‹µ! ë“œë¡œìš°ê¶Œ 1ì¥ì„ ì¶”ê°€ë¡œ íšë“í–ˆìŠµë‹ˆë‹¤.");
                             } else {
                                 this.showAlert("ì˜¤ë‹µì…ë‹ˆë‹¤... ë³´ìƒ ì—†ìŒ.");
                             }
                             this.toMenu();
                         });
                    },
                    // No Callback
                    () => {
                        this.toMenu();
                    }
                 );
             }
        });
    },

    loseBattle() {
        // No saveRecord here (User request: only on New Game)

        // Reset Chaos Blessing
        this.state.chaosBlessingUses = 3;
        this.state.chaosBuffs = [];
        this.state.activeChaosBlessing = [];
        this.state.activeSageBlessing = [];

        let deadMsg = this.handlePermadeath(this.battle.players);
        let msg = "íŒ¨ë°°...";
        if (deadMsg) msg += "<br><br>" + deadMsg;
        this.openInfoModal("ì „íˆ¬ ê²°ê³¼", msg, () => this.toMenu());
    },

    getEffectiveStats(char, fieldBuffs) {
        let stats = {
            atk: char.atk, matk: char.matk,
            def: char.def, mdef: char.mdef,
            evasion: (char.baseEva || 0) + 5,
            crit: (char.baseCrit || 10)
        };
        let m = { atk: 1.0, matk: 1.0, def: 1.0, mdef: 1.0 };
        let addEva = 0;
        let addCrit = 0;

        // 1. Dynamic Traits (Player Only)
        const trait = char.proto ? char.proto.trait : null;
        if (trait) {
            if (trait.type === 'cond_twinkle_all' && fieldBuffs.some(b => b.name === 'twinkle_party')) {
                 m.atk += 0.3; m.matk += 0.3;
            }
            if (trait.type === 'cond_no_field_buff_eva_crit' && fieldBuffs.length === 0) {
                addEva += trait.val;
                addCrit += trait.val;
            }
        }

        // 2. Field Buffs
        if (char.proto) {
            fieldBuffs.forEach(fb => {
                if(fb.name === 'sun_bless') { m.atk += 0.3; m.matk += 0.3; }
                if(fb.name === 'moon_bless') { m.matk += 0.3; addEva += 15; }
                if(fb.name === 'sanctuary') { m.matk += 0.30; m.mdef += 0.30; }
                if(fb.name === 'goddess_descent') { m.atk += 0.3; m.matk += 0.3; m.def += 0.3; m.mdef += 0.3; }
                if(fb.name === 'earth_bless') { m.atk += 0.25; m.matk += 0.25; }
                if(fb.name === 'twinkle_party') { m.atk += 0.2; addCrit += 15; }
                if(fb.name === 'star_powder') { m.def += 0.3; m.mdef += 0.3; }
            });
        }

        // 3. Buffs/Debuffs
        if (char.buffs['weak']) { m.atk -= 0.2; }
        if (char.buffs['silence']) { m.matk -= 0.2; }
        if (char.buffs['evasion']) { addEva += 50; }

        let defRed = 0.0;
        if (char.buffs['darkness'] && char.buffs['corrosion']) defRed = 0.4;
        else if (char.buffs['darkness'] || char.buffs['corrosion']) defRed = 0.2;
        m.def -= defRed;

        if (char.buffs['curse']) m.mdef -= 0.2;

        stats.atk = Math.floor(stats.atk * Math.max(0, m.atk));
        stats.matk = Math.floor(stats.matk * Math.max(0, m.matk));
        stats.def = Math.floor(stats.def * Math.max(0, m.def));
        stats.mdef = Math.floor(stats.mdef * Math.max(0, m.mdef));
        stats.evasion += addEva;
        stats.crit += addCrit;

        return stats;
    },

    showBattleStat(side, idx) {
        let char;
        if(side === 'player') char = this.battle.players[idx];
        else char = this.battle.enemy;
        if(!char) return;

        let buffs = Object.keys(char.buffs).map(k => {
            let name = this.BUFF_NAMES[k] || k;
            let val = char.buffs[k];
            if(val === true) return name;
            return `${name}(${val})`;
        }).join(', ') || 'ì—†ìŒ';

        const eff = this.getEffectiveStats(char, this.battle.fieldBuffs);
        const colorize = (val, base) => {
             if(val > base) return `<span style="color:#69f0ae">${val}</span>`;
             if(val < base) return `<span style="color:#ff5252">${val}</span>`;
             return `<span style="color:#eee">${val}</span>`;
        };

        let content = `<b>[${char.name}]</b><br>HP: ${char.hp}/${char.maxHp}<br>`;
        if(side === 'player') content += `MP: ${char.mp}<br>`;
        content += `ATK: ${colorize(eff.atk, char.atk)} / MATK: ${colorize(eff.matk, char.matk)}<br>`;
        content += `DEF: ${colorize(eff.def, char.def)} / MDEF: ${colorize(eff.mdef, char.mdef)}<br>`;
        content += `ì¹˜ëª…íƒ€ìœ¨: <span style="color:#ff5252">${eff.crit}%</span> / íšŒí”¼ìœ¨: <span style="color:#4fc3f7">${eff.evasion}%</span><br>`;
        content += `ìƒíƒœ: ${buffs}<br><br>`;

        if(side === 'player') {
             content += `<b>[ìŠ¤í‚¬]</b><br>`;
             char.proto.skills.forEach(s => {
                 let multText = s.val ? ` (x${s.val})` : '';
                 content += `- ${s.name}: ${s.desc}${multText}<br>`;
             });
        } else {
             content += `<b>[ìŠ¤í‚¬]</b><br>`;
             char.skills.forEach(s => {
                 let multText = s.val ? ` (x${s.val})` : '';
                 content += `- ${s.name}: ${s.desc}${multText}<br>`;
             });
        }
        this.openInfoModal(char.name, content);
    },

    showFieldBuffInfo() {
        if(this.battle.fieldBuffs.length === 0) return this.showAlert("í™œì„±í™”ëœ í•„ë“œ ë²„í”„ê°€ ì—†ìŠµë‹ˆë‹¤.");
        const buffInfo = {
            'sun_bless': 'ë¬¼ê³µ/ë§ˆê³µ +30%, ì¹˜ëª…íƒ€ëŒ€ë¯¸ì§€ +60%',
            'moon_bless': 'ë§ˆê³µ +30%, íšŒí”¼ìœ¨ +15%',
            'sanctuary': 'ë§ˆê³µ +30%, ë§ˆë°© +30%',
            'goddess_descent': 'ë¬¼ê³µ/ë§ˆê³µ +30%, ë°©ì–´/ë§ˆë°© +30%',
            'earth_bless': 'ë¬¼ê³µ/ë§ˆê³µ +25%',
            'twinkle_party': 'ë¬¼ê³µ +20%, ì¹˜ëª…íƒ€ìœ¨ +15%',
            'star_powder': 'ë°©ì–´/ë§ˆë°© +30%'
        };
        let msg = "";
        this.battle.fieldBuffs.forEach(b => {
             msg += `<b>[${this.BUFF_NAMES[b.name]}]</b><br>${buffInfo[b.name] || ''}<br><br>`;
        });
        this.openInfoModal("í•„ë“œ ë²„í”„", msg);
    },

    openInfoModal(title, content, onClose = null) {
        document.getElementById('info-title').innerText = title;
        document.getElementById('info-content').innerHTML = content;
        document.getElementById('modal-info').classList.add('active');
        this.tempOnClose = onClose;
    },
    closeInfoModal() {
        document.getElementById('modal-info').classList.remove('active');
        if (this.tempOnClose) {
            this.tempOnClose();
            this.tempOnClose = null;
        }
    },

    showConfirm(msg, onYes, onNo) {
        document.getElementById('confirm-msg').innerText = msg;
        const modal = document.getElementById('modal-confirm');
        const btnYes = document.getElementById('confirm-yes');
        const btnNo = document.getElementById('confirm-no');

        btnYes.onclick = () => {
            modal.classList.remove('active');
            if(onYes) onYes();
        };
        btnNo.onclick = () => {
             modal.classList.remove('active');
             if(onNo) onNo();
        };

        modal.classList.add('active');
    },

    showAlert(msg) {
        this.openInfoModal("ì•Œë¦¼", msg);
    }
};
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Card RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Noto Sans KR', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .header {
            padding: 10px;
            text-align: center;
            background: #1f1f1f;
            border-bottom: 1px solid #333;
            font-size: 0.95rem;
            color: #bbb;
            font-weight: bold;
            flex-shrink: 0;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            overflow: hidden;
            gap: 8px;
        }

        .screen {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .screen.active {
            display: flex;
        }

        .menu-btn {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 15px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 10px;
            width: 100%;
            text-align: center;
        }

        .menu-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .menu-btn:active {
            background: #555;
            transform: scale(0.98);
        }

        .menu-btn.correct {
            background: #1b5e20 !important;
            border-color: #4caf50 !important;
        }

        .menu-btn.wrong {
            background: #b71c1c !important;
            border-color: #ef5350 !important;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 5px;
            overflow-y: auto;
            padding: 5px;
            padding-bottom: 80px;
            flex: 1;
            align-content: start;
        }

        .card-item {
            background: #222;
            border: 2px solid #444;
            border-radius: 5px;
            padding: 5px;
            text-align: center;
            font-size: 0.8rem;
            cursor: pointer;
            position: relative;
        }

        .card-item.selected {
            border-color: #ffd700;
            box-shadow: 0 0 5px #ffd700;
        }

        @keyframes glow-legend {
            0% {
                box-shadow: 0 0 5px #ff5252;
            }

            50% {
                box-shadow: 0 0 20px #ff5252;
            }

            100% {
                box-shadow: 0 0 5px #ff5252;
            }
        }

        @keyframes glow-epic {
            0% {
                box-shadow: 0 0 5px #e040fb;
            }

            50% {
                box-shadow: 0 0 15px #e040fb;
            }

            100% {
                box-shadow: 0 0 5px #e040fb;
            }
        }

        .card-item.legend {
            border-color: #ff5252;
            color: #ff5252;
            animation: glow-legend 2s infinite;
        }

        .card-item.epic {
            border-color: #e040fb;
            color: #e040fb;
            animation: glow-epic 2s infinite;
        }

        .card-item.rare {
            border-color: #448aff;
            color: #448aff;
        }

        .card-item.normal {
            border-color: #bdbdbd;
            color: #bdbdbd;
        }

        @keyframes glow-gold {
            0% {
                box-shadow: 0 0 5px #ffd700;
                border-color: #ffd700;
            }

            50% {
                box-shadow: 0 0 20px #ffd700;
                border-color: #ffeb3b;
            }

            100% {
                box-shadow: 0 0 5px #ffd700;
                border-color: #ffd700;
            }
        }

        .card-item.transcendence {
            border: 2px solid #ffd700;
            color: #ffd700;
            animation: glow-gold 2s infinite;
            background: #2a2a1a;
        }

        .portrait {
            width: 100%;
            aspect-ratio: 3/4;
            border-radius: 6px;
            background: #000;
            border: 2px solid #555;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 3px;
        }

        .portrait img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .battle-header {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            background: #222;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .field-buffs {
            height: 20px;
            font-size: 0.7rem;
            color: #81d4fa;
            text-align: center;
            overflow: hidden;
            white-space: nowrap;
            cursor: pointer;
        }

        .visual-stage {
            flex: 1;
            position: relative;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            background-image: linear-gradient(to bottom, #2a2a2a, #121212);
            min-height: 200px;
            max-height: 40vh;
        }

        .battle-actor {
            width: 120px;
            text-align: center;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .battle-actor .portrait {
            width: 90px;
            height: 120px;
            border-color: #999;
        }

        .battle-actor.player .portrait {
            border-color: #4caf50;
        }

        .battle-actor.enemy .portrait {
            border-color: #ff5252;
        }

        .battle-actor.turn {
            transform: scale(1.05);
            z-index: 10;
        }

        .battle-actor.dead {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .actor-hp-bar {
            width: 100%;
            height: 6px;
            background: #333;
            margin-top: 4px;
            border-radius: 3px;
            overflow: hidden;
        }

        .actor-hp-fill {
            height: 100%;
            background: #ef5350;
            width: 100%;
            transition: width 0.5s;
        }

        .actor-mp-bar {
            width: 100%;
            height: 4px;
            background: #333;
            margin-top: 2px;
            border-radius: 2px;
            overflow: hidden;
        }

        .actor-mp-fill {
            height: 100%;
            background: #42a5f5;
            width: 100%;
            transition: width 0.3s;
        }

        .actor-buffs {
            font-size: 0.6rem;
            color: #ffd700;
            height: 12px;
            overflow: hidden;
            margin-top: 2px;
        }

        .log-container {
            height: 150px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 5px;
            overflow-y: auto;
            font-size: 0.75rem;
            margin-bottom: 5px;
        }

        .log-line {
            margin-bottom: 2px;
            border-bottom: 1px solid #252525;
        }

        .log-dmg {
            color: #ff5252;
        }

        .log-heal {
            color: #69f0ae;
        }

        .log-info {
            color: #4fc3f7;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            height: 110px;
            margin-bottom: 60px;
        }

        .skill-btn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 5px;
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
        }

        .skill-btn:disabled {
            opacity: 0.5;
            background: #222;
        }

        .skill-btn span {
            pointer-events: none;
        }

        .skill-btn.phy {
            border-color: #9c27b0;
            color: #e1bee7;
        }

        .skill-btn.mag {
            border-color: #2196f3;
            color: #bbdefb;
        }

        .skill-btn.sup {
            border-color: #4caf50;
            color: #c8e6c9;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #222;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            width: 320px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            text-align: center;
            color: #e0e0e0;
        }

        .modal-scroll {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .deck-slot {
            width: 100%;
            height: 50px;
            background: #333;
            margin-bottom: 5px;
            border: 1px dashed #555;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .deck-slot.filled {
            border: 1px solid #4caf50;
            background: #1b5e20;
        }

        .title-loading {
            width: 100%;
            max-width: 320px;
            margin: 0 auto 14px auto;
            padding: 10px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid #4fc3f7;
            color: #81d4fa;
            font-size: 0.9rem;
        }

        .title-loading.hidden {
            display: none;
        }

        /* Artifact mode mobile UI fix for Chaos modal */
        #modal-chaos.artifact-mode .menu-btn {
            padding: 8px !important;
            margin-bottom: 5px !important;
        }

        #modal-chaos.artifact-mode .modal-content {
            min-height: auto !important;
            padding-bottom: 20px;
        }

        #modal-artifact-select .modal-content {
            padding: 10px !important;
            padding-top: 5px !important;
            min-height: auto !important;
        }

        #modal-artifact-select h3 {
            margin: 5px 0 !important;
        }

        #modal-artifact-select p {
            margin: 5px 0 !important;
            margin-bottom: 8px !important;
        }

        @media (max-width: 768px) {
            #modal-chaos.artifact-mobile-compact {
                justify-content: center;
            }

            #modal-chaos.artifact-mobile-compact .modal-content {
                min-height: auto !important;
                max-height: calc(100vh - 16px);
                overflow-y: auto;
                padding-top: 8px;
            }

            #modal-chaos.artifact-mobile-compact .chaos-title {
                margin: 4px 0 8px 0;
            }

            #modal-chaos.artifact-mobile-compact .chaos-desc {
                margin: 4px 0 8px 0;
                line-height: 1.35;
            }

            #modal-chaos.artifact-mobile-compact .chaos-uses {
                margin-bottom: 6px !important;
            }

            #modal-chaos.artifact-mobile-compact .menu-btn {
                margin-bottom: 7px;
                padding: 10px;
            }

            #modal-chaos.artifact-mobile-compact .chaos-close-btn {
                margin-top: 6px !important;
            }
        }

        /* === TOEIC Practice UI === */
        #modal-toeic-practice .modal-content {
            display: flex;
            flex-direction: column;
            background: #121212;
            padding: 15px;
            position: relative;
            overflow: hidden;
        }

        /* Part 5: auto height */
        #modal-toeic-practice.is-part5 .modal-content {
            height: auto !important;
            max-height: 85vh !important;
            overflow-y: auto !important;
        }

        /* Part 6/7: fixed height */
        #modal-toeic-practice.is-part67 .modal-content {
            height: 85vh !important;
            max-height: 85vh !important;
        }

        /* Explanation View: fixed height */
        #modal-toeic-practice.is-explanation .modal-content {
            height: 85vh !important;
            max-height: 85vh !important;
            overflow-y: hidden !important;
        }

        /* Part 5: hide hub and passage */
        #modal-toeic-practice.is-part5 #toeic-hub,
        #modal-toeic-practice.is-part5 #toeic-passage-view {
            display: none !important;
        }

        #modal-toeic-practice.is-part5:not(.is-review) #toeic-q-back-btn {
            display: none !important;
        }

        /* Hub screen */
        #toeic-hub {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            gap: 20px;
        }

        .toeic-hub-btn {
            width: 80%;
            max-width: 320px;
            padding: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            background: #222;
            border: 2px solid #448aff;
            color: #82b1ff;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s;
            text-align: center;
        }

        .toeic-hub-btn:hover,
        .toeic-hub-btn:active {
            background: #448aff;
            color: #fff;
            transform: scale(1.02);
        }

        /* Passage view: fills remaining space */
        #toeic-passage-view {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        #toeic-passage-view .toeic-passage-scroll {
            flex: 1;
            min-height: 0;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch;
            background: #1a1a1a;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            font-size: 0.92rem;
            line-height: 1.7;
            white-space: pre-wrap;
            text-align: left;
            color: #e0e0e0;
            margin-bottom: 10px;
        }

        /* Question view */
        #toeic-question-view {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 5px 0;
        }

        .toeic-back-btn {
            width: 100%;
            padding: 14px;
            margin-top: 12px;
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.95rem;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .toeic-back-btn:hover,
        .toeic-back-btn:active {
            background: #444;
        }
    </style>
</head>

<body>
    <div class="header">Card RPG</div>
    <div class="container">
        <div id="screen-title" class="screen active" style="justify-content: center; align-items: center;">
            <h1 style="color:#ffd700;">Card RPG</h1>
            <div id="title-loading" class="title-loading">â³ ë°ì´í„° ë¡œë”© ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</div>
            <button id="btn-start-new" class="menu-btn" onclick="RPG.startGame('new')" disabled>ìƒˆë¡œí•˜ê¸°</button>
            <button id="btn-start-load" class="menu-btn" onclick="RPG.startGame('load')" disabled>ì´ì–´í•˜ê¸°</button>
        </div>
        <div id="screen-menu" class="screen">
            <div style="text-align:center; padding: 10px;">ë³´ìœ  í‹°ì¼“: <span id="ui-tickets" style="color:#ffd700">0</span>ì¥
            </div>
            <div id="next-enemy-preview"
                style="text-align:center; padding: 10px; background: #222; border-radius: 5px; margin-bottom: 10px; border: 1px solid #444; color: #ffcc80;">
                <div style="margin-bottom:5px;">ë‹¤ìŒ ìƒëŒ€: <span id="next-enemy-text">?</span></div>
                <div class="portrait" style="width:80px; height:106px; margin:0 auto; border-color:#ff5252;"><img
                        id="next-enemy-img" src="" onerror="this.style.display='none'"
                        style="width:100%; height:100%; object-fit:contain;"></div>
            </div>
            <div id="menu-gacha-area" style="display:flex; gap:5px; margin-bottom:10px;">
                <button class="menu-btn" onclick="RPG.openGacha()" style="flex:1;">ì¼ë°˜ ë½‘ê¸° (1ì¥)</button>
                <button class="menu-btn" onclick="RPG.openChallengeGacha()"
                    style="flex:1; border-color:#e040fb; color:#e040fb;">ë„ì „ ë½‘ê¸°</button>
            </div>
            <div id="menu-draft-area" style="display:none; margin-bottom:10px;">
                <button class="menu-btn" onclick="RPG.startDraft()" style="border-color:#00e676; color:#00e676;">ë± ë¹Œë”©
                    (ë“œë˜í”„íŠ¸)</button>
            </div>
            <div id="menu-chaos-area" style="display:none; margin-bottom:10px;">
                <button class="menu-btn" onclick="RPG.reshuffleChaosPool()"
                    style="border-color:#ff5252; color:#ff5252;">
                    ì¹´ì˜¤ìŠ¤ ì…”í”Œ (í‹°ì¼“ 1ì¥)
                </button>
            </div>
            <button class="menu-btn" onclick="RPG.openDeck()">ë± êµ¬ì„±</button>
            <button class="menu-btn" onclick="RPG.openCollection()">ì¹´ë“œ í™•ì¸</button>
            <button class="menu-btn" onclick="RPG.openLibrary()">ë„ì„œê´€</button>
            <button class="menu-btn" onclick="RPG.openChaosBlessing()"
                style="border-color: #ffd700; color: #ffd700;">ì¶•ë³µì˜ ì œë‹¨</button>
            <button class="menu-btn" onclick="RPG.startBattleInit()"
                style="background:#b71c1c; border-color:#f44336;">ì „íˆ¬ ì§„ì…</button>
            <button class="menu-btn" onclick="RPG.openSystemMenu()">ë©”ë‰´</button>
        </div>
        <div id="screen-draft" class="screen">
            <h3 style="margin:5px 0;">ë± ë¹Œë”© (<span id="draft-round-text">ì„ ë´‰</span> ì„ ë°œ)</h3>
            <div style="text-align:center; margin-bottom:2px;">
                ë‚¨ì€ ë¦¬ë¡¤: <span id="draft-reroll-cnt" style="color:#ffd700">3</span>íšŒ
            </div>

            <div id="draft-grid"
                style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; padding:5px; overflow-y:auto; flex:1;">
            </div>

            <div style="margin-top:auto; margin-bottom: 40px; padding-bottom: 10px;">
                <button class="menu-btn" onclick="RPG.rerollDraft()"
                    style="background:#333; border-color:#ff9800; color:#ff9800;">ë¦¬ë¡¤ (ìƒˆë¡œê³ ì¹¨)</button>
                <button class="menu-btn" onclick="RPG.toMenu()" style="margin-top:5px;">ë‚˜ê°€ê¸°</button>
            </div>
        </div>
        <div id="screen-collection" class="screen">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3>ì¹´ë“œ ëª©ë¡</h3><button onclick="RPG.toMenu()"
                    style="background:#fff; color:#000; padding:5px; border:1px solid #ccc; cursor:pointer;">ë’¤ë¡œ</button>
            </div>
            <div id="collection-grid" class="card-grid"></div>
        </div>
        <div id="screen-deck" class="screen">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3>ë± êµ¬ì„±</h3>
                <button onclick="RPG.toMenu()"
                    style="background:#fff; color:#000; padding:5px; border:1px solid #ccc; cursor:pointer;">ë’¤ë¡œ</button>
            </div>
            <div style="margin-bottom:10px;">
                <div id="slot-0" class="deck-slot" onclick="RPG.selectDeckSlot(0)">ì„ ë´‰ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
                <div id="slot-1" class="deck-slot" onclick="RPG.selectDeckSlot(1)">ì¤‘ê²¬ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
                <div id="slot-2" class="deck-slot" onclick="RPG.selectDeckSlot(2)">ëŒ€ì¥ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
            </div>
            <div style="flex:1; overflow-y:auto; border-top:1px solid #333;">
                <div id="deck-card-list" class="card-grid"></div>
            </div>
            <button class="menu-btn" onclick="RPG.confirmDeck()" style="margin-bottom: 60px;">í™•ì¸</button>
        </div>
        <div id="screen-chaos-roulette" class="screen">
            <div
                style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding-top:15vh; gap:20px;">
                <div style="text-align:center;">
                    <h2 style="color:#ffd700; margin-bottom:5px;">ì¹´ì˜¤ìŠ¤ ë£°ë ›</h2>
                    <p>ë³´ìœ  ì¹´ì˜¤ìŠ¤ í‹°ì¼“: <span id="ui-chaos-tickets"
                            style="color:#ffd700; font-weight:bold; font-size:1.2rem;">0</span>ì¥</p>
                </div>
                <button class="menu-btn" onclick="RPG.spinChaosRoulette()"
                    style="border-color:#ffd700; color:#ffd700; width:80%; max-width:300px; padding:20px;">
                    ì¹´ì˜¤ìŠ¤ ë£°ë › ëŒë¦¬ê¸° (í‹°ì¼“ 1ì¥)
                </button>
                <button class="menu-btn" onclick="RPG.openTranscendenceCheck()" style="width:80%; max-width:300px;">
                    ì´ˆì›” í™•ì¸
                </button>
                <button class="menu-btn" onclick="RPG.toTitle(); RPG.openModeSelect();"
                    style="width:80%; max-width:300px; background:#444;">
                    ëŒì•„ê°€ê¸°
                </button>
            </div>
        </div>
        <div id="screen-transcendence-check" class="screen">
            <div
                style="display:flex; justify-content:space-between; align-items:center; padding:10px; background:#1f1f1f;">
                <h3 style="margin:0; color:#ffd700;">ë³´ìœ  ì´ˆì›” ì¹´ë“œ (ë‹¤ìŒ ì˜¤ë¦¬ì§„ ê²Œì„ ì ìš©)</h3>
                <button onclick="RPG.openChaosRoulette()"
                    style="background:#fff; color:#000; padding:5px 10px; border:1px solid #ccc; cursor:pointer; border-radius:4px;">ë’¤ë¡œ</button>
            </div>
            <div id="transcendence-grid" class="card-grid"></div>
        </div>
        <div id="screen-battle" class="screen">
            <div class="battle-header"><span>Turn: <span id="bt-turn">1</span></span>
                <div id="field-buff-box" class="field-buffs" onclick="RPG.showFieldBuffInfo()"></div>
            </div>
            <div class="visual-stage">
                <div id="player-actor-box" class="battle-actor player"
                    onclick="RPG.showBattleStat('player', RPG.battle.currentPlayerIdx)">
                    <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="p-name">Player</div>
                    <div class="portrait"><img id="p-img" src="" onerror="this.style.display='none'"></div>
                    <div class="actor-hp-bar">
                        <div id="p-hp-bar" class="actor-hp-fill"></div>
                    </div>
                    <div class="actor-mp-bar">
                        <div id="p-mp-bar" class="actor-mp-fill"></div>
                    </div>
                    <div id="p-buffs" class="actor-buffs"></div>
                </div>

                <div style="color:#555; font-size:1.5rem; font-weight:bold;">VS</div>

                <div id="enemy-actor-box" class="battle-actor enemy" onclick="RPG.showBattleStat('enemy', 0)">
                    <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="e-name">Enemy</div>
                    <div class="portrait"><img id="e-img" src="" onerror="this.style.display='none'"></div>
                    <div class="actor-hp-bar">
                        <div id="e-hp-bar" class="actor-hp-fill"></div>
                    </div>
                    <div id="e-buffs" class="actor-buffs"></div>
                </div>
            </div>
            <div id="battle-log" class="log-container"></div>
            <div id="battle-controls" class="control-panel"></div>
        </div>
    </div>

    <div id="modal-mode-select" class="modal">
        <div class="modal-content" style="height:auto; min-height:400px; width: 360px;">
            <div style="position:relative;">
                <h3>ê²Œì„ ëª¨ë“œ ì„ íƒ</h3>
                <button id="btn-chaos-roulette" onclick="RPG.openChaosRoulette()"
                    style="display:none; position:absolute; top:-5px; right:0; padding:5px 10px; font-size:0.8rem; background:#333; border:1px solid #ffd700; color:#ffd700; border-radius:5px;">ì¹´ì˜¤ìŠ¤
                    ë£°ë ›</button>
            </div>
            <div id="mode-list" style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; margin-bottom:10px;">
            </div>
            <div id="mode-desc"
                style="font-size:0.8rem; color:#ccc; background:#333; padding:10px; border-radius:5px; height:100px; overflow-y:auto; text-align:left;">
                ëª¨ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.
            </div>
            <button id="btn-enter-mode" class="menu-btn"
                style="background:#1b5e20; border-color:#4caf50; margin-top:10px; margin-bottom: 5px;">ì…ì¥</button>
            <button onclick="document.getElementById('modal-mode-select').classList.remove('active')"
                style="margin-top:5px; width:100%; padding:10px;">ì·¨ì†Œ</button>
        </div>
    </div>

    <div id="modal-type-select" class="modal">
        <div class="modal-content" style="height:auto; min-height:300px; width: 360px;">
            <h3>ê²Œì„ ì¢…ë¥˜ ì„ íƒ</h3>
            <p style="font-size:0.9rem; color:#aaa; margin-bottom:20px;">
                í”Œë ˆì´í•˜ì‹¤ ê²Œì„ ì¢…ë¥˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.
            </p>
            <button class="menu-btn" onclick="RPG.selectGameType('endless')" style="padding:20px; margin-bottom:10px;">
                ë¬´í•œ ëª¨ë“œ (Endless)<br>
                <span style="font-size:0.8rem; color:#ccc;">í´ë¦¬ì–´ ì¡°ê±´ ì—†ìŒ / ë¬´í•œ ì§„í–‰</span>
            </button>
            <button class="menu-btn" onclick="RPG.selectGameType('challenge')"
                style="padding:20px; border-color:#e040fb; color:#e040fb;">
                ë„ì „ ëª¨ë“œ (Challenge)<br>
                <span style="font-size:0.8rem; color:#e1bee7;">ëª©í‘œ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ë„ì „</span>
            </button>
            <button onclick="RPG.toTitle()" style="margin-top:20px; width:100%; padding:10px;">ë’¤ë¡œê°€ê¸°</button>
        </div>
    </div>

    <div id="modal-card" class="modal">
        <div class="modal-content">
            <h3 id="md-name">Name</h3>
            <div class="modal-scroll">
                <div class="portrait" style="width:150px; height:200px; margin:0 auto;"><img id="md-img" src=""
                        style="width:100%; height:100%; object-fit:contain;"></div>
                <p id="md-grade" style="font-size:0.8rem; margin:5px 0;">Grade</p>
                <div id="md-stats"
                    style="font-size:0.8rem; text-align:left; background:#333; padding:5px; margin:5px 0;"></div>
                <div id="md-skills" style="font-size:0.8rem; text-align:left;"></div>
            </div>
            <button onclick="RPG.closeModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-info" class="modal" style="z-index: 200;">
        <div class="modal-content" style="height:auto;">
            <h3 id="info-title">ì •ë³´</h3>
            <div id="info-content" class="modal-scroll" style="text-align:left; font-size:0.85rem; line-height:1.4;">
            </div>
            <button onclick="RPG.closeInfoModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-confirm" class="modal" style="z-index: 210;">
        <div class="modal-content" style="height:auto;">
            <h3 id="confirm-title">í™•ì¸</h3>
            <div id="confirm-msg" style="margin: 10px 0;">...</div>
            <div id="confirm-btn-container" style="display:flex; gap:10px; margin-top:15px; width:100%;">
                <button id="confirm-yes" class="menu-btn" style="flex:1; margin-bottom:0;">ì˜ˆ</button>
                <button id="confirm-no" class="menu-btn"
                    style="flex:1; margin-bottom:0; background:#555; border-color:#777;">ì•„ë‹ˆì˜¤</button>
            </div>
        </div>
    </div>

    <div id="modal-gacha" class="modal">
        <div class="modal-content" style="height:auto; min-height:300px;">
            <h2 id="gacha-title">íšë“!</h2>
            <div id="gacha-result"></div>
            <button onclick="RPG.closeGachaModal()" style="margin-top:10px; width:100%; padding:10px;">í™•ì¸</button>
        </div>
    </div>

    <div id="modal-library" class="modal">
        <div class="modal-content" style="height:auto;">
            <h3>ë„ì„œê´€</h3>
            <button class="menu-btn" onclick="RPG.openMagicClass()">ë£¨ë¯¸ì˜ ë§ˆë²•êµì‹¤</button>
            <button class="menu-btn" onclick="RPG.openPrivateTutoring()">ë£¨ë¯¸ì˜ ê°œì¸ê³¼ì™¸</button>
            <button class="menu-btn" onclick="RPG.openWordbook()">ë‹¨ì–´ì¥</button>
            <button class="menu-btn" onclick="RPG.openToeicMenu()">ì‹¤ì „
                ë§ˆë²•ì—°ìŠµ</button>
            <button onclick="document.getElementById('modal-library').classList.remove('active')"
                style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-magic-class" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 600px; height: 80vh;">
            <h3>ë£¨ë¯¸ì˜ ë§ˆë²•êµì‹¤</h3>
            <div id="lecture-list" class="modal-scroll"></div>
            <button onclick="RPG.closeMagicClass()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-lecture-view" class="modal" style="z-index: 150;">
        <div class="modal-content" style="width: 90%; max-width: 600px; height: 90vh;">
            <h3 id="lecture-title">ê°•ì˜ ì œëª©</h3>
            <div style="display: flex; justify-content: center; margin-bottom: 10px;">
                <div class="portrait" style="width: 100px; height: 130px; border-color: #448aff;">
                    <img src="ë£¨ë¯¸.png" onerror="this.src=''" alt="Rumi">
                </div>
            </div>
            <div id="lecture-content" class="modal-scroll"
                style="text-align: left; padding: 10px; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap;">
            </div>
            <button onclick="RPG.closeLectureView()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-wordbook" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 600px; height: 80vh;">
            <h3>ë‹¨ì–´ì¥</h3>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 0.8rem; color: #aaa;">ë¹¨ê°„ìƒ‰: í‹€ë¦° ë‹¨ì–´</span>
                <label
                    style="font-size: 0.8rem; color: #aaa; margin-left: 10px; display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="wordbook-filter-wrong" onchange="RPG.openWordbook()"
                        style="margin-right: 5px;"> í‹€ë¦° ë‹¨ì–´ë§Œ ë³´ê¸°
                </label>
                <button class="menu-btn" onclick="RPG.resetWrongWords()"
                    style="width: auto; padding: 5px 10px; font-size: 0.8rem; margin: 0; background: #555;">ë³µìŠµ
                    ì´ˆê¸°í™”</button>
            </div>
            <div id="wordbook-list" class="modal-scroll" style="text-align: left; padding: 10px;"></div>
            <button onclick="RPG.closeWordbook()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-tutoring" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 600px; height: 80vh;">
            <h3>ë£¨ë¯¸ì˜ ê°œì¸ê³¼ì™¸</h3>
            <div class="portrait" style="width: 100px; height: 130px; border-color: #448aff; margin: 0 auto 10px auto;">
                <img src="ë£¨ë¯¸.png" onerror="this.src=''" alt="Rumi">
            </div>
            <div id="tutoring-content" class="modal-scroll"
                style="text-align: left; padding: 10px; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; background: #222; border: 1px solid #444; min-height: 200px;">
                ìˆ˜ì—…ì„ ì‹œì‘í•˜ë ¤ë©´ 'ìˆ˜ì—… ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="menu-btn" onclick="RPG.startTutoringSession()" style="flex: 1; margin-bottom: 0;">ìˆ˜ì—…
                    ì‹œì‘</button>
                <button id="btn-tutoring-quiz" class="menu-btn" onclick="RPG.startTutoringQuiz()"
                    style="flex: 1; margin-bottom: 0; display: none; border-color: #ffd700; color: #ffd700;">í€´ì¦ˆ
                    í’€ê¸°</button>
            </div>
            <button onclick="RPG.closePrivateTutoring()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-quiz" class="modal">
        <div class="modal-content" style="width: 320px;">
            <h3>í€´ì¦ˆ</h3>
            <div id="quiz-question" style="font-size: 1.2rem; margin: 10px 0; font-weight: bold; color: #ffd700;"></div>
            <div id="quiz-desc" style="font-size: 0.9rem; margin-bottom: 10px; color: #aaa; display:none;"></div>
            <div id="quiz-options" style="display: flex; flex-direction: column; gap: 8px; width: 100%;"></div>
            <div id="quiz-feedback" style="margin-top:10px; font-weight:bold; height:20px;"></div>
        </div>
    </div>

    <div id="modal-chaos" class="modal">
        <div class="modal-content" style="height:auto; min-height: 550px;">
            <h3 class="chaos-title">í˜¼ëˆì˜ ì¶•ë³µ</h3>
            <p class="chaos-desc" style="font-size:0.8rem; color:#aaa;">ì „íˆ¬ ì‹œ ë¬´ì‘ìœ„ ì¹´ë“œì—ê²Œ ê°•ë ¥í•œ ì¶•ë³µì„ ë‚´ë¦½ë‹ˆë‹¤.<br>(ì „íˆ¬ ì¢…ë£Œ ì‹œ ì‚¬ë¼ì§, ìµœëŒ€
                3íšŒ)</p>
            <div class="chaos-uses" style="margin-bottom:10px; font-weight:bold; color:#ffd700;">
                í˜¼ëˆì˜ ì¶•ë³µ: <span id="chaos-uses">3</span>íšŒ / ëŒ€í˜„ìì˜ ì¶•ë³µ: <span id="sage-uses">3</span>íšŒ
            </div>
            <button class="menu-btn" onclick="RPG.activateChaos('normal')">
                í˜¼ëˆì˜ ì¶•ë³µ (ì¼ë°˜)<br>
                <span style="font-size:0.75rem; font-weight:normal; color:#ccc;">ëœë¤ 3ì¢… ì¹´ë“œ ëŠ¥ë ¥ì¹˜ ëŒ€í­ ìƒìŠ¹, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€</span>
            </button>
            <button class="menu-btn" onclick="RPG.activateChaos('challenge')"
                style="border-color:#e040fb; color:#e040fb;">
                í˜¼ëˆì˜ ì¶•ë³µ (ë„ì „)<br>
                <span style="font-size:0.75rem; font-weight:normal; color:#e1bee7;">í€´ì¦ˆ ì„±ê³µ ì‹œ ëœë¤ 5ì¢… ì¹´ë“œ ëŠ¥ë ¥ì¹˜ ëŒ€í­ ìƒìŠ¹, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨
                    ì¦ê°€</span>
            </button>
            <button class="menu-btn" onclick="RPG.activateChaos('great_sage')"
                style="border-color:#00e676; color:#00e676;">
                ëŒ€í˜„ìì˜ ì¶•ë³µ<br>
                <span style="font-size:0.75rem; font-weight:normal; color:#b9f6ca;">ë¬¸ë²• í€´ì¦ˆ ì„±ê³µ ì‹œ 12ëª…ì—ê²Œ ì¶•ë³µ + í‹°ì¼“ 1ì¥</span>
            </button>
            <button class="menu-btn" onclick="RPG.checkActiveChaosBlessings()"
                style="border-color:#29b6f6; color:#29b6f6;">
                ì ìš©ëœ ì¶•ë³µ í™•ì¸
            </button>
            <button id="btn-artifact-check" onclick="RPG.openArtifactCheck()"
                style="display:none; border-color:#ffd700; color:#ffd700;" class="menu-btn">
                ì•„í‹°íŒ©íŠ¸ í™•ì¸
            </button>
            <button onclick="document.getElementById('modal-chaos').classList.remove('active')"
                style="margin-top:10px; width:100%; padding:10px;" class="chaos-close-btn">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-artifact-select" class="modal" style="z-index: 210;">
        <div class="modal-content" style="height:auto; min-height:350px;">
            <h3 style="color:#ffd700;">ì•„í‹°íŒ©íŠ¸ ì„ íƒ</h3>
            <p style="font-size:0.8rem; color:#aaa;">ì•„ë˜ 3ê°œ ì¤‘ 1ê°œë¥¼ ì„ íƒí•˜ì„¸ìš”. (ìµœëŒ€ 4ê°œ ë³´ìœ )</p>
            <div id="artifact-select-list" style="display:flex; flex-direction:column; gap:8px; margin:10px 0;"></div>
        </div>
    </div>

    <div id="modal-artifact-check" class="modal" style="z-index: 200;">
        <div class="modal-content" style="height:auto;">
            <h3 style="color:#ffd700;">ë³´ìœ  ì•„í‹°íŒ©íŠ¸</h3>
            <div id="artifact-check-list" style="text-align:left; font-size:0.85rem; line-height:1.6;"></div>
            <button onclick="document.getElementById('modal-artifact-check').classList.remove('active')"
                style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-menu" class="modal">
        <div class="modal-content" style="height:auto;">
            <h3>ë©”ë‰´</h3>
            <button id="btn-toggle-tutoring" class="menu-btn" onclick="RPG.toggleTutoringEvent()">ê°œì¸ê³¼ì™¸ ì´ë²¤íŠ¸: ON</button>
            <button class="menu-btn" onclick="RPG.openApiSettings()">API ì„¤ì •</button>
            <button class="menu-btn" onclick="RPG.saveGame()">ì €ì¥í•˜ê¸°</button>
            <button class="menu-btn" onclick="RPG.showRecords()">ê¸°ë¡ í™•ì¸</button>
            <button class="menu-btn" onclick="RPG.toTitle()" style="border-color:#f44336; color:#ef5350;">íƒ€ì´í‹€ë¡œ</button>
            <button onclick="document.getElementById('modal-menu').classList.remove('active')"
                style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-api-settings" class="modal">
        <div class="modal-content" style="height:auto;">
            <h3>API ì„¤ì •</h3>
            <p style="font-size:0.8rem; color:#aaa; margin-bottom:10px;">Gemini API Keyë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</p>
            <input type="password" id="api-key-input" placeholder="Gemini API Key ì…ë ¥"
                style="width:100%; box-sizing:border-box; padding:10px; background:#333; color:#fff; border:1px solid #555; margin-bottom:10px;">
            <button class="menu-btn" onclick="RPG.saveApiKey()">ì €ì¥</button>
            <button onclick="document.getElementById('modal-api-settings').classList.remove('active')"
                style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
        </div>
    </div>

    <div id="modal-toeic-menu" class="modal">
        <div class="modal-content" style="height:auto;">
            <h3>ì‹¤ì „ ë§ˆë²•ì—°ìŠµ</h3>
            <p style="font-size:0.8rem; color:#aaa; margin-bottom:10px;">í† ìµ ì˜ˆìƒ ë¬¸ì œ í’€ì´</p>
            <button class="menu-btn" onclick="RPG.startToeicPractice()">ì—°ìŠµ ì‹œì‘</button>
            <button class="menu-btn" onclick="RPG.resetToeicProgress()" style="border-color:#ff5252; color:#ef5350;">ì—°ìŠµ
                ì´ˆê¸°í™”</button>
            <button
                onclick="document.getElementById('modal-toeic-menu').classList.remove('active'); document.getElementById('modal-library').classList.add('active');"
                style="margin-top:10px; width:100%; padding:10px;">ë’¤ë¡œ</button>
        </div>
    </div>

    <div id="modal-toeic-practice" class="modal">
        <div class="modal-content" style="width: 95%; max-width: 900px;">
            <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; flex-shrink:0;">
                <h3 id="toeic-title" style="margin:0; font-size:1.1rem; color:#ffd700;">Practice</h3>
                <button onclick="document.getElementById('modal-toeic-practice').classList.remove('active');"
                    style="padding:5px 15px; background:#444; border:1px solid #666; color:#fff; cursor:pointer; border-radius:4px;">ë‚˜ê°€ê¸°</button>
            </div>

            <!-- Hub: Part 6/7 only -->
            <div id="toeic-hub" class="toeic-hub" style="display:none;">
                <p style="color:#aaa; font-size:0.9rem; text-align:center; margin-bottom:10px;">ì§€ë¬¸ì„ ì½ê³  ë¬¸ì œë¥¼ í’€ì–´ë³´ì„¸ìš”.</p>
                <button class="toeic-hub-btn" onclick="RPG.showToeicPassage()">ğŸ“– ì§€ë¬¸ë³´ê¸°</button>
                <button class="toeic-hub-btn" onclick="RPG.showToeicQuestions()"
                    style="border-color:#ffd700; color:#ffd700;">ğŸ“ ë¬¸ì œë³´ê¸°</button>
            </div>

            <!-- Review Hub -->
            <div id="toeic-review-hub" class="toeic-hub" style="display:none; gap:10px;"></div>

            <!-- Passage View: scrollable passage + back button -->
            <div id="toeic-passage-view" class="toeic-passage-view">
                <div id="toeic-passage-scroll" class="toeic-passage-scroll"></div>
                <button class="toeic-back-btn" onclick="RPG.backToToeicHub()">â†© ëŒì•„ê°€ê¸°</button>
            </div>

            <!-- Explanation View -->
            <div id="toeic-explanation-view" class="toeic-passage-view" style="display:none;">
                <div style="display:flex; justify-content:flex-end; padding:0 0 10px 0;">
                    <button class="menu-btn" onclick="RPG.backToToeicHub()" style="padding:8px 15px; font-size:0.9rem; width:auto; margin:0; border-color:#aaa;">â†© ëŒì•„ê°€ê¸°</button>
                </div>
                <div id="toeic-explanation-scroll" class="toeic-passage-scroll" style="border:1px solid #333; padding:10px;"></div>
            </div>

            <!-- Question View: question + options + feedback + back button -->
            <div id="toeic-question-view" class="toeic-question-view">
                <div id="toeic-q-text"
                    style="font-size:1rem; font-weight:bold; margin-bottom:15px; color:#ffd700; line-height:1.4;">
                </div>
                <div id="toeic-options" style="display:flex; flex-direction:column; gap:10px;"></div>
                <div id="toeic-feedback" style="margin-top:15px; font-weight:bold; min-height:24px; text-align:center;">
                </div>
                <button id="toeic-q-back-btn" class="toeic-back-btn" onclick="RPG.backToToeicHub()"
                    style="display:none;">â†© ëŒì•„ê°€ê¸°</button>
            </div>
        </div>
    </div>

    <div id="modal-toeic-result" class="modal">
        <div class="modal-content" style="height:auto;">
            <h3 id="toeic-result-title">í•™ìŠµ ì¢…ë£Œ</h3>
            <div id="toeic-result-content" class="modal-scroll" style="text-align:left; font-size:0.9rem; line-height:1.5;"></div>
            <div style="display:flex; gap:10px; margin-top:10px;">
                 <button class="menu-btn" onclick="RPG.openToeicReview()" style="flex:1; margin-bottom:0; border-color:#ffd700; color:#ffd700;">í•´ì„¤ / ë¦¬ë·°</button>
                 <button class="menu-btn" onclick="document.getElementById('modal-toeic-result').classList.remove('active'); RPG.toMenu();" style="flex:1; margin-bottom:0;">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <script>
        window._scriptLoadErrors = [];
        // Sequential script loader â€” loads one file at a time for mobile file:// reliability
        (function () {
            var scripts = [
                { src: 'data.js', label: 'ì¹´ë“œ/ì  ë°ì´í„°' },
                { src: 'vocab_data.js', label: 'ë‹¨ì–´ ë°ì´í„°' },
                { src: 'collocation_data.js', label: 'ì—°ì–´ ë°ì´í„°' },
                { src: 'grammar_data.js', label: 'ë¬¸ë²• ë°ì´í„°' },
                { src: 'toeic.js', label: 'í† ìµ ë°ì´í„°' },
                { src: 'toeic_explanations.js', label: 'í† ìµ í•´ì„¤' },
                { src: 'api.js', label: 'API ëª¨ë“ˆ' },
                { src: 'logic.js', label: 'ê²Œì„ ë¡œì§' }
            ];
            var idx = 0;

            function loadNext() {
                if (idx >= scripts.length) return;
                var info = scripts[idx];
                var el = document.createElement('script');
                el.src = info.src;

                el.onload = function () {
                    idx++;
                    updateProgress();
                    // ğŸš€ í•µì‹¬ ìˆ˜ì •: ëª¨ë°”ì¼ ê¸°ê¸°ì˜ íŒŒì¼ I/O ë° ë©”ëª¨ë¦¬ ì •ë¦¬ë¥¼ ìœ„í•´ 100ms ëŒ€ê¸° í›„ ë‹¤ìŒ íŒŒì¼ ë¡œë“œ
                    setTimeout(loadNext, 100);
                };

                el.onerror = function () {
                    window._scriptLoadErrors.push(info.src);
                    idx++;
                    updateProgress();
                    // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ê¸°ê¸°ê°€ ì‰´ ìˆ˜ ìˆê²Œ ëŒ€ê¸° ì‹œê°„ ë¶€ì—¬
                    setTimeout(loadNext, 100);
                };

                // headë³´ë‹¤ëŠ” bodyì— ì¶”ê°€í•˜ëŠ” ê²ƒì´ ëª¨ë°”ì¼ ì›¹ë·° ë©”ëª¨ë¦¬ ì²˜ë¦¬ì— ë” ì•ˆì •ì ì…ë‹ˆë‹¤.
                document.body.appendChild(el);
            }

            function updateProgress() {
                var el = document.getElementById('title-loading');
                if (el) el.innerText = 'â³ ë°ì´í„° ë¡œë”© ì¤‘ (' + idx + '/' + scripts.length + ')... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.';
            }

            // ì²« ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹œì‘ ì „ì—ë„ DOMì´ ì•ˆì •í™”ë  ì‹œê°„ì„ ì•½ê°„ ì¤ë‹ˆë‹¤.
            setTimeout(loadNext, 50);
        })();
    </script>
    <script defer>
        /**
         * QuizEngine â€” Unified quiz rendering system for Card RPG.
         *
         * Replaces 5 separate quiz functions with a single configurable engine:
         *   - startQuiz (vocab, Korean meaning â†’ pick correct meaning)
         *   - startChaosQuiz (vocab, Korean meaning â†’ pick correct English word)
         *   - startCollocationQuiz (collocation quiz)
         *   - startGrammarQuiz (grammar quiz)
         *   - startTutoringQuiz (tutoring review quiz)
         *
         * Usage:
         *   QuizEngine.show({
         *       question: 'What is ...?',
         *       desc: 'optional description',        // falsy â†’ hidden
         *       options: ['A', 'B', 'C', 'D'],       // will be shuffled
         *       answer: 'B',                          // correct option text
         *       onCorrect: () => { ... },
         *       onWrong: (chosen) => { ... },
         *       correctDelay: 1000,                   // ms before closing on correct
         *       wrongDelay: 1500                      // ms before closing on wrong
         *   });
         */
        const QuizEngine = {
            /**
             * Weighted selection for quiz generation.
             * Favors items in RPG.state.tutoredItems with 10x weight.
             */
            pickWeighted(data, getItemId) {
                const tutored = (RPG.state && RPG.state.tutoredItems) ? RPG.state.tutoredItems : [];

                // If no data or no tutored items relevant to this dataset, pick random
                if (!data || data.length === 0) return null;

                // Optimization: if no tutored items at all, skip logic
                if (tutored.length === 0) return data[Math.floor(Math.random() * data.length)];

                // Check if any tutored item exists in this data
                const candidates = data.filter(d => tutored.includes(getItemId(d)));
                if (candidates.length === 0) return data[Math.floor(Math.random() * data.length)];

                // Calculate weights
                // Candidates: 10, Others: 1
                const weightC = candidates.length * 10;
                const weightN = (data.length - candidates.length) * 1;
                const totalWeight = weightC + weightN;

                let r = Math.random() * totalWeight;

                if (r < weightC) {
                    // Pick from candidates
                    return candidates[Math.floor(Math.random() * candidates.length)];
                } else {
                    // Pick from others (Rejection sampling for efficiency)
                    // Since candidates are very few (max 3), rejection probability is very low.
                    let pick;
                    let safety = 0;
                    do {
                        pick = data[Math.floor(Math.random() * data.length)];
                        safety++;
                    } while (tutored.includes(getItemId(pick)) && safety < 50);
                    return pick;
                }
            },

            /**
             * Show a quiz modal with the given configuration.
             * @param {Object} config
             * @param {string}   config.question      - The question text
             * @param {string}   [config.desc]        - Optional description/translation (hidden if falsy)
             * @param {string[]} config.options       - Array of option strings (will be shuffled)
             * @param {string}   config.answer        - The correct answer string (must match one of options)
             * @param {Function} [config.onCorrect]   - Callback when correct answer is chosen
             * @param {Function} [config.onWrong]     - Callback when wrong answer is chosen, receives (chosenText)
             * @param {number}   [config.correctDelay=1000] - Delay in ms before closing modal on correct
             * @param {number}   [config.wrongDelay=1500]   - Delay in ms before closing modal on wrong
             */
            show(config) {
                const modal = document.getElementById('modal-quiz');
                const qDiv = document.getElementById('quiz-question');
                const descDiv = document.getElementById('quiz-desc');
                const oDiv = document.getElementById('quiz-options');
                const fDiv = document.getElementById('quiz-feedback');

                // Reset modal state
                modal.classList.remove('active');
                oDiv.innerHTML = '';
                if (fDiv) fDiv.innerText = '';

                // Question
                qDiv.innerText = config.question;

                // Description
                if (config.desc) {
                    descDiv.innerText = config.desc;
                    descDiv.style.display = 'block';
                } else {
                    descDiv.style.display = 'none';
                }

                // Shuffle options
                const shuffled = [...config.options].sort(() => Math.random() - 0.5);
                const correctDelay = config.correctDelay || 1000;
                const wrongDelay = config.wrongDelay || 1500;

                shuffled.forEach(optText => {
                    const btn = document.createElement('button');
                    btn.className = 'menu-btn';
                    btn.style.padding = '10px';
                    btn.style.fontSize = '0.9rem';
                    btn.innerText = optText;

                    btn.onclick = () => {
                        // Immediately disable all buttons
                        btn.disabled = true;
                        Array.from(oDiv.children).forEach(c => { c.onclick = null; });

                        if (optText === config.answer) {
                            btn.classList.add('correct');
                            if (fDiv) { fDiv.innerText = 'ì •ë‹µ!'; fDiv.style.color = '#4caf50'; }
                            setTimeout(() => {
                                modal.classList.remove('active');
                                if (config.onCorrect) config.onCorrect();
                            }, correctDelay);
                        } else {
                            btn.classList.add('wrong');
                            // Highlight correct answer
                            Array.from(oDiv.children).forEach(c => {
                                if (c.innerText === config.answer) c.classList.add('correct');
                            });
                            if (fDiv) { fDiv.innerText = 'ì˜¤ë‹µ...'; fDiv.style.color = '#ef5350'; }
                            setTimeout(() => {
                                modal.classList.remove('active');
                                if (config.onWrong) config.onWrong(optText);
                            }, wrongDelay);
                        }
                    };
                    oDiv.appendChild(btn);
                });

                modal.classList.add('active');
            },

            // â”€â”€â”€ Convenience builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            /**
             * Build config for a standard vocab quiz (word â†’ meaning).
             * @param {Function} callback - (success: boolean) => void
             * @returns {Object|null} config or null if data unavailable
             */
            buildVocabQuiz(callback) {
                if (!VOCAB_DATA || VOCAB_DATA.length === 0) return null;

                const q = this.pickWeighted(VOCAB_DATA, v => v.word);

                let options = [{ text: q.meaning, correct: true }];
                options.push({ text: q.trap_meaning, correct: false });

                let safety = 0;
                while (options.length < 4 && safety < 100) {
                    safety++;
                    const r = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];
                    if (r.word !== q.word && r.word !== q.trap_word && !options.some(o => o.text === r.meaning)) {
                        options.push({ text: r.meaning, correct: false });
                    }
                }

                return {
                    question: q.word,
                    desc: null,
                    options: options.map(o => o.text),
                    answer: q.meaning,
                    onCorrect: () => callback(true),
                    onWrong: () => {
                        // Record wrong word
                        if (!RPG.state.wrongWords) RPG.state.wrongWords = [];
                        if (!RPG.state.wrongWords.includes(q.word)) {
                            RPG.state.wrongWords.push(q.word);
                            Storage.save(Storage.keys.VOCAB, RPG.state.wrongWords);
                        }
                        callback(false);
                    }
                };
            },

            /**
             * Build config for a chaos quiz (meaning â†’ word, reverse direction).
             * @param {Function} callback - (success: boolean) => void
             * @returns {Object|null} config or null if data unavailable
             */
            buildChaosQuiz(callback) {
                if (!VOCAB_DATA || VOCAB_DATA.length === 0) return null;

                const q = this.pickWeighted(VOCAB_DATA, v => v.word);

                let options = [{ text: q.word, correct: true }];
                let safety = 0;
                while (options.length < 4 && safety < 100) {
                    safety++;
                    const r = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];
                    if (r.word !== q.word && !options.some(o => o.text === r.word)) {
                        options.push({ text: r.word, correct: false });
                    }
                }

                return {
                    question: q.meaning,
                    desc: null,
                    options: options.map(o => o.text),
                    answer: q.word,
                    onCorrect: () => callback(true),
                    onWrong: () => callback(false)
                };
            },

            /**
             * Build config for a collocation quiz.
             * @param {Function} callback - (success: boolean) => void
             * @returns {Object|null} config or null if data unavailable
             */
            buildCollocationQuiz(callback) {
                if (!COLLOCATION_DATA || COLLOCATION_DATA.length === 0) return null;

                let allQuizzes = [];
                COLLOCATION_DATA.forEach(item => {
                    if (item.quizzes) {
                        item.quizzes.forEach(q => { allQuizzes.push({ ...q, parentId: item.id }); });
                    } else {
                        allQuizzes.push({ ...item, parentId: item.id });
                    }
                });
                if (allQuizzes.length === 0) return null;

                const q = this.pickWeighted(allQuizzes, item => item.parentId);

                return {
                    question: q.question,
                    desc: q.translation,
                    options: [...q.options],
                    answer: q.answer,
                    onCorrect: () => callback(true),
                    onWrong: () => {
                        if (!RPG.state.wrongCollocations) RPG.state.wrongCollocations = [];
                        if (!RPG.state.wrongCollocations.includes(q.parentId)) {
                            RPG.state.wrongCollocations.push(q.parentId);
                            Storage.save(Storage.keys.COLLOCATION, RPG.state.wrongCollocations);
                        }
                        callback(false);
                    }
                };
            },

            /**
             * Build config for a grammar quiz.
             * @param {Object}   q               - Quiz object from GRAMMAR_DATA
             * @param {Function} [onCorrect]     - Callback on correct
             * @param {Function} [onWrong]       - Callback on wrong
             * @returns {Object} config
             */
            buildGrammarQuiz(q, onCorrect, onWrong) {
                let cleanDesc = q.desc.replace(/\s*\(.*?\)/g, '').trim();

                return {
                    question: q.question,
                    desc: cleanDesc,
                    options: [...q.options],
                    answer: q.answer,
                    onCorrect: onCorrect || null,
                    onWrong: onWrong || null
                };
            },

            /**
             * Build config for a tutoring review quiz (vocab or collocation).
             * @param {Object}   item           - { data, type: 'vocab'|'collocation' }
             * @param {Function} onCorrect      - Callback on correct
             * @param {Function} onWrong        - Callback on wrong
             * @returns {Object} config
             */
            buildTutoringQuiz(item, onCorrect, onWrong) {
                const data = item.data;

                if (item.type === 'collocation') {
                    let quizList = data.quizzes || [{ question: data.question, options: data.options, answer: data.answer, translation: data.translation }];
                    let q = quizList[Math.floor(Math.random() * quizList.length)];

                    return {
                        question: q.question,
                        desc: q.translation || '',
                        options: [...q.options],
                        answer: q.answer,
                        onCorrect: onCorrect,
                        onWrong: onWrong
                    };
                } else {
                    // Vocab tutoring quiz
                    let options = [{ text: data.meaning, correct: true }];
                    options.push({ text: data.trap_meaning, correct: false });

                    let safety = 0;
                    while (options.length < 4 && safety < 100) {
                        safety++;
                        const r = VOCAB_DATA[Math.floor(Math.random() * VOCAB_DATA.length)];
                        if (r.word !== data.word && r.word !== data.trap_word && !options.some(o => o.text === r.meaning)) {
                            options.push({ text: r.meaning, correct: false });
                        }
                    }

                    return {
                        question: data.word,
                        desc: null,
                        options: options.map(o => o.text),
                        answer: data.meaning,
                        onCorrect: onCorrect,
                        onWrong: onWrong
                    };
                }
            }
        };

        /**
         * RPG Game Namespace
         * Encapsulates all game logic, state, and UI handling.
         */
        const RPG = {
            global: {
                unlocked_modes: ['origin'],
                unlocked_bonus_cards: [],
                achievements: { origin: false },
                chaosTickets: 0,
                lastRewardDate: null,
                pendingTranscendenceCards: []
            },

            // Game State (Session Persistent)
            state: {
                mode: 'origin',
                tickets: 20,
                inventory: [],
                deck: [null, null, null],
                enemyScale: 0,
                chaosBlessingUses: 3,
                greatSageBlessingUses: 3,
                chaosBuffs: [], // Array of { id: cardId, multiplier: float } (Merged)
                activeChaosBlessing: [], // Specific buffs from Chaos Blessing
                activeSageBlessing: [],   // Specific buffs from Great Sage Blessing
                quiz_stats: { correct: 0, total: 0 }
            },

            // Battle State (Transient)
            battle: {
                turn: 1,
                players: [],
                enemy: null,
                fieldBuffs: [],
                currentPlayerIdx: 0,
                phase: 'start', // start, player, enemy, end
                delayedEffects: [],
                activeTraits: [], // List of active deck synergy traits
                isNewTurn: true
            },

            // UI Helper Variables
            selectedSlot: -1,
            tempOnClose: null,
            tempConfirmYes: null,
            tempConfirmNo: null,
            isApiLoading: false,

            // Constants
            NORMAL_ATTACK: { name: 'ì¼ë°˜ ê³µê²©', type: 'phy', tier: 1, cost: 0, val: 1.0, desc: 'ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©', effects: [] },


            // --- Core Functions ---

            log(msg, type = 'info') {
                const box = document.getElementById('battle-log');
                const div = document.createElement('div');
                div.className = `log-line log-${type}`;
                div.innerHTML = msg;
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            getCardData(id) {
                return CARDS.find(c => c.id === id) || BONUS_CARDS.find(c => c.id === id) || (typeof TRANSCENDENCE_CARDS !== 'undefined' ? TRANSCENDENCE_CARDS.find(c => c.id === id) : null);
            },

            // --- Global Data ---
            loadGlobalData() {
                const data = Storage.load(Storage.keys.GLOBAL);
                if (data) {
                    this.global = { ...this.global, ...data };
                }
            },
            saveGlobalData() {
                Storage.save(Storage.keys.GLOBAL, this.global);
            },

            checkDailyChaosTicket() {
                const today = new Date().toDateString();
                if (this.global.lastRewardDate !== today) {
                    this.global.lastRewardDate = today;
                    this.global.chaosTickets = (this.global.chaosTickets || 0) + 1;
                    this.saveGlobalData();
                    this.showAlert("ì¶œì„ ë³´ìƒ: ì¹´ì˜¤ìŠ¤ í‹°ì¼“ 1ì¥ì„ íšë“í–ˆìŠµë‹ˆë‹¤!");
                }
            },

            checkAllBonusUnlocked() {
                if (!this.global.unlocked_bonus_cards) return false;
                return BONUS_CARDS.every(c => this.global.unlocked_bonus_cards.includes(c.id));
            },

            getMissingRequiredData() {
                const requiredData = [
                    { name: 'CARDS', ref: typeof CARDS !== 'undefined' ? CARDS : null },
                    { name: 'ENEMIES', ref: typeof ENEMIES !== 'undefined' ? ENEMIES : null },
                    { name: 'BONUS_CARDS', ref: typeof BONUS_CARDS !== 'undefined' ? BONUS_CARDS : null },
                    { name: 'TRANSCENDENCE_CARDS', ref: typeof TRANSCENDENCE_CARDS !== 'undefined' ? TRANSCENDENCE_CARDS : null },
                    { name: 'VOCAB_DATA', ref: typeof VOCAB_DATA !== 'undefined' ? VOCAB_DATA : null },
                    { name: 'COLLOCATION_DATA', ref: typeof COLLOCATION_DATA !== 'undefined' ? COLLOCATION_DATA : null },
                    { name: 'GRAMMAR_DATA', ref: typeof GRAMMAR_DATA !== 'undefined' ? GRAMMAR_DATA : null },
                    { name: 'Logic', ref: typeof Logic !== 'undefined' ? Logic : null },
                    { name: 'SideEffects', ref: typeof SideEffects !== 'undefined' ? SideEffects : null },
                    { name: 'GameUtils', ref: typeof GameUtils !== 'undefined' ? GameUtils : null },
                    { name: 'QuizEngine', ref: typeof QuizEngine !== 'undefined' ? QuizEngine : null },
                    { name: 'TOEIC_DATA', ref: typeof TOEIC_DATA !== 'undefined' ? TOEIC_DATA : null },
                    { name: 'GameAPI', ref: typeof GameAPI !== 'undefined' ? GameAPI : null }
                ];
                return requiredData.filter(d => !d.ref || (Array.isArray(d.ref) && d.ref.length === 0));
            },

            setStartButtonsEnabled(enabled) {
                const btnNew = document.getElementById('btn-start-new');
                const btnLoad = document.getElementById('btn-start-load');
                if (btnNew) btnNew.disabled = !enabled;
                if (btnLoad) btnLoad.disabled = !enabled;

                const loading = document.getElementById('title-loading');
                if (loading) {
                    if (enabled) {
                        loading.innerText = 'â³ ë°ì´í„° ë¡œë”© ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.';
                        loading.classList.add('hidden');
                    } else {
                        loading.classList.remove('hidden');
                    }
                }
            },

            waitForInitialDataLoad() {
                let attempts = 0;
                const maxAttempts = 200;
                const pollingMs = 150;

                const checkReady = () => {
                    // Check for script load errors first
                    if (window._scriptLoadErrors && window._scriptLoadErrors.length > 0) {
                        const loading = document.getElementById('title-loading');
                        if (loading) {
                            loading.innerHTML = `âš ï¸ ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨: ${window._scriptLoadErrors.join(', ')}<br><span style="font-size:0.8rem; color:#aaa;">íŒŒì¼ì´ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</span><br><button onclick="location.reload()" style="margin-top:8px; padding:8px 16px; border-radius:4px; border:1px solid #ff5252; background:#b71c1c; color:#fff; cursor:pointer; font-size:0.9rem;">ìƒˆë¡œê³ ì¹¨</button>`;
                        }
                        return;
                    }

                    const missing = this.getMissingRequiredData();
                    if (missing.length === 0) {
                        this.setStartButtonsEnabled(true);
                        return;
                    }

                    attempts++;
                    if (attempts >= maxAttempts) {
                        const loading = document.getElementById('title-loading');
                        if (loading) {
                            const errorInfo = window._scriptLoadErrors && window._scriptLoadErrors.length > 0
                                ? `<br>ë¡œë“œ ì‹¤íŒ¨ íŒŒì¼: ${window._scriptLoadErrors.join(', ')}` : '';
                            loading.innerHTML = `âš ï¸ ë¡œë”© ì‹œê°„ ì´ˆê³¼: ${missing.map(d => d.name).join(', ')}${errorInfo}<br><span style="font-size:0.8rem; color:#aaa;">ëª¨ë“  .js íŒŒì¼ì´ index.htmlê³¼ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</span><br><button onclick="location.reload()" style="margin-top:8px; padding:8px 16px; border-radius:4px; border:1px solid #ff5252; background:#b71c1c; color:#fff; cursor:pointer; font-size:0.9rem;">ìƒˆë¡œê³ ì¹¨</button>`;
                        }
                        return;
                    }

                    // Update loading text with progress every 50 attempts
                    if (attempts % 50 === 0) {
                        const loading = document.getElementById('title-loading');
                        if (loading) {
                            const missing = this.getMissingRequiredData();
                            loading.innerText = `â³ ë°ì´í„° ë¡œë”© ì¤‘... (${missing.map(d => d.name).join(', ')} ëŒ€ê¸°)`;
                        }
                    }

                    setTimeout(checkReady, pollingMs);
                };

                this.setStartButtonsEnabled(false);
                checkReady();
            },

            startGame(mode, retryCount = 0) {
                const missing = this.getMissingRequiredData();

                if (missing.length > 0) {
                    if (retryCount < 6) {
                        setTimeout(() => this.startGame(mode, retryCount + 1), 180);
                        return;
                    }
                    const names = missing.map(d => d.name).join(', ');
                    this.showAlert(`ê²Œì„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: ${names}<br><br>íŒŒì¼ì´ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ê²Œì„ì„ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.`);
                    return; // ê²Œì„ ì§„ì… ì°¨ë‹¨
                }

                this.loadGlobalData();
                this.checkDailyChaosTicket();

                if (mode === 'load') {
                    const save = Storage.load(Storage.keys.SAVE);
                    if (save) {
                        this.state = { ...this.state, ...save };
                        if (this.state.chaosBlessingUses === undefined) this.state.chaosBlessingUses = 3;
                        if (this.state.greatSageBlessingUses === undefined) this.state.greatSageBlessingUses = 3;
                        if (!this.state.chaosBuffs) this.state.chaosBuffs = [];
                        if (!this.state.activeChaosBlessing) this.state.activeChaosBlessing = [];
                        if (!this.state.activeSageBlessing) this.state.activeSageBlessing = [];
                        if (!this.state.tutoredItems) this.state.tutoredItems = [];
                        if (!this.state.mode) this.state.mode = 'origin';
                        if (!this.state.quiz_stats) this.state.quiz_stats = { correct: 0, total: 0 };
                        if (!this.state.artifacts) this.state.artifacts = [];

                        // Load persistent wordbook
                        const vocab = Storage.load(Storage.keys.VOCAB);
                        if (vocab) this.state.wrongWords = vocab;

                        const col = Storage.load(Storage.keys.COLLOCATION);
                        if (col) this.state.wrongCollocations = col;

                        this.showAlert("ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ");
                        this.toMenu();
                    } else { this.showAlert("ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤."); this.openTypeSelect(); }
                } else {
                    // New Game Logic: Show Type Select
                    this.openTypeSelect();
                }
            },

            openTypeSelect() {
                this.selectedModeId = null;
                document.getElementById('modal-type-select').classList.add('active');
            },

            selectGameType(type) {
                this.tempGameType = type;
                document.getElementById('modal-type-select').classList.remove('active');
                this.openModeSelect();
            },

            openModeSelect() {
                this.selectedModeId = null;
                const modal = document.getElementById('modal-mode-select');
                const list = document.getElementById('mode-list');
                const desc = document.getElementById('mode-desc');
                list.innerHTML = "";
                desc.innerText = "ëª¨ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.";

                const chaosBtn = document.getElementById('btn-chaos-roulette');
                if (chaosBtn) {
                    if (this.tempGameType === 'endless' && this.checkAllBonusUnlocked()) {
                        chaosBtn.style.display = 'block';
                    } else {
                        chaosBtn.style.display = 'none';
                    }
                }

                let MODES = [
                    { id: 'origin', name: 'ì˜¤ë¦¬ì§„', desc: 'ê¸°ë³¸ ëª¨ë“œì…ë‹ˆë‹¤.\n(ì„±ê³µì¡°ê±´: ì—†ìŒ / ë¬´í•œ)' },
                    { id: 'restriction', name: 'ì œì•½ì˜ ì‹œë ¨', desc: 'ë½‘ê¸°/ì¶•ë³µì—ì„œ ë ˆì–´ ë“±ê¸‰ ì´í•˜ë§Œ ë“±ì¥í•©ë‹ˆë‹¤.\n(ì„±ê³µì¡°ê±´: 18 ìŠ¤í…Œì´ì§€)' },
                    { id: 'balance', name: 'ê· í˜•ì˜ ë„ì „', desc: 'ë½‘ê¸°/ì¶•ë³µì—ì„œ ì—í”½ ë“±ê¸‰ ì´í•˜ë§Œ ë“±ì¥í•©ë‹ˆë‹¤.\n(ì„±ê³µì¡°ê±´: 18 ìŠ¤í…Œì´ì§€)' },
                    { id: 'suffering', name: 'ê³ ë‚œì˜ ì—¬ì •', desc: 'ì´ˆê¸° 10ì¥, í´ë¦¬ì–´ ë³´ìƒ ì—†ìŒ, ì¶•ë³µ ì¹´ë“œ +2ì¥.\n(ì„±ê³µì¡°ê±´: 24 ìŠ¤í…Œì´ì§€)' },
                    { id: 'overdrive', name: 'ì˜¤ë²„ë“œë¼ì´ë¸Œ', desc: 'ì´ˆê¸° 10ì¥, í´ë¦¬ì–´ ë³´ìƒ +1ì¥, ì¶•ë³µ ì¹´ë“œ +1ì¥.\n(ì„±ê³µì¡°ê±´: 30 ìŠ¤í…Œì´ì§€)' },
                    { id: 'archive', name: 'ì•„ì¹´ì´ë¸Œ', desc: 'ë§¤ ìŠ¤í…Œì´ì§€ ì¢…ë£Œ í›„ ë¬¸ë²• í€´ì¦ˆ. ì •ë‹µë¥  80% ì´ìƒ í•„ìš”.\n(ì„±ê³µì¡°ê±´: 18 ìŠ¤í…Œì´ì§€)' },
                    { id: 'curse', name: 'ì €ì£¼ì˜ ì¦í­', desc: 'ë””ë²„í”„ì˜ ìŠ¤íƒ¯ ê°ì†Œ íš¨ê³¼ 2ë°°.\n(ì„±ê³µì¡°ê±´: 30 ìŠ¤í…Œì´ì§€)' },
                    { id: 'flood', name: 'ì¶•ë³µì˜ ë²”ëŒ', desc: 'í•„ë“œ ë²„í”„ì˜ ê°•í™” íš¨ê³¼ 2ë°°.\n(ì„±ê³µì¡°ê±´: 30 ìŠ¤í…Œì´ì§€)' },
                    { id: 'chaos', name: 'ì¹´ì˜¤ìŠ¤', desc: 'ë§¤ ì „íˆ¬ ë±/ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™”. ë¬´ì‘ìœ„ 15ì¥ í’€ì—ì„œ ë½‘ê¸° ì§„í–‰.\n(ì„±ê³µì¡°ê±´: 24 ìŠ¤í…Œì´ì§€ / íŒ¨ë°° ì‹œ ë°ì´í„° ì‚­ì œ)' },
                    { id: 'draft', name: 'ë“œë˜í”„íŠ¸', desc: 'ë½‘ê¸° ëŒ€ì‹  ë± ë¹Œë”©(ë“œë˜í”„íŠ¸)ìœ¼ë¡œ 3ëª…ì„ ì„ ë°œí•˜ì—¬ ì „íˆ¬.\n(ì„±ê³µì¡°ê±´: 24 ìŠ¤í…Œì´ì§€ / íŒ¨ë°° ì‹œ ë°ì´í„° ì‚­ì œ)' },
                    { id: 'artifact', name: 'ì•„í‹°íŒ©íŠ¸', desc: 'ë§¤ ë³´ìŠ¤(ì°½ì¡°ì‹ ) í´ë¦¬ì–´ ì‹œ ì•„í‹°íŒ©íŠ¸ íšë“ (ìµœëŒ€ 4ê°œ).\nê³ ìœ í•œ ì•„í‹°íŒ©íŠ¸ íš¨ê³¼ë¡œ ì „íˆ¬ë¥¼ ìœ ë¦¬í•˜ê²Œ!\n(ì„±ê³µì¡°ê±´: 36 ìŠ¤í…Œì´ì§€)' }
                ];

                if (this.tempGameType === 'endless') {
                    MODES = MODES.filter(m => ['origin', 'draft', 'chaos', 'artifact'].includes(m.id));
                    MODES.forEach(m => {
                        if (m.id === 'chaos') m.desc = 'ë§¤ ì „íˆ¬ ë±/ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™”. ë¬´ì‘ìœ„ 15ì¥ í’€ì—ì„œ ë½‘ê¸° ì§„í–‰.\n(ì„±ê³µì¡°ê±´: ì—†ìŒ / ë¬´í•œ / íŒ¨ë°° ì‹œ ë°ì´í„° ì‚­ì œ)';
                        if (m.id === 'draft') m.desc = 'ë½‘ê¸° ëŒ€ì‹  ë± ë¹Œë”©(ë“œë˜í”„íŠ¸)ìœ¼ë¡œ 3ëª…ì„ ì„ ë°œí•˜ì—¬ ì „íˆ¬.\n(ì„±ê³µì¡°ê±´: ì—†ìŒ / ë¬´í•œ / íŒ¨ë°° ì‹œ ë°ì´í„° ì‚­ì œ)';
                        if (m.id === 'artifact') m.desc = 'ë§¤ ë³´ìŠ¤(ì°½ì¡°ì‹ ) í´ë¦¬ì–´ ì‹œ ì•„í‹°íŒ©íŠ¸ íšë“ (ìµœëŒ€ 4ê°œ).\nê³ ìœ í•œ ì•„í‹°íŒ©íŠ¸ íš¨ê³¼ë¡œ ì „íˆ¬ë¥¼ ìœ ë¦¬í•˜ê²Œ!\n(ì„±ê³µì¡°ê±´: ì—†ìŒ / ë¬´í•œ)';
                    });
                } else if (this.tempGameType === 'challenge') {
                    MODES = MODES.filter(m => m.id !== 'origin');
                }

                MODES.forEach(m => {
                    const btn = document.createElement('button');
                    btn.className = "menu-btn";
                    btn.style.padding = "10px";
                    btn.style.fontSize = "0.9rem";
                    btn.innerText = m.name;
                    btn.id = `mode-btn-${m.id}`;

                    const isUnlocked = this.global.unlocked_modes.includes(m.id);
                    if (isUnlocked) btn.style.color = "#e040fb"; // Purple for unlocked

                    btn.onclick = () => {
                        this.selectedModeId = m.id;
                        desc.innerText = `[${m.name}]\n${m.desc}`;

                        // Visual Update
                        list.querySelectorAll('.menu-btn').forEach(b => b.style.borderColor = '#555');
                        btn.style.borderColor = '#ffd700';
                    };
                    list.appendChild(btn);
                });

                // Enter Button Logic
                const enterBtn = document.getElementById('btn-enter-mode');
                enterBtn.onclick = () => {
                    if (!this.selectedModeId) return this.showAlert("ëª¨ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
                    const mName = MODES.find(m => m.id === this.selectedModeId).name;
                    this.showDoubleConfirm(
                        `${mName} ëª¨ë“œë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,
                        `ì •ë§ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì—”ë“œë¦¬ìŠ¤ ê²Œì„ ë°ì´í„°ëŠ” ì´ˆê¸°í™”ë©ë‹ˆë‹¤.<br>(ê²Œì„ ì‹œì‘ ì‹œ ìë™ ì €ì¥ë©ë‹ˆë‹¤)`,
                        () => {
                            this.initNewGame(this.selectedModeId);
                            modal.classList.remove('active');
                            this.toMenu();
                        }
                    );
                };

                modal.classList.add('active');
            },

            initNewGame(mode = 'origin') {
                // Record saving logic (Only for Origin mode as per request "Record check only for Origin")
                // Check previous state
                if (this.state.mode === 'origin' && this.state.enemyScale > 0) {
                    this.saveRecord();
                }

                let initTickets = GameUtils.getInitialTickets(mode);

                this.state = {
                    mode: mode,
                    gameType: this.tempGameType || 'challenge',
                    tickets: initTickets,
                    inventory: [],
                    deck: [null, null, null],
                    enemyScale: 0,
                    chaosBlessingUses: 3,
                    greatSageBlessingUses: 3,
                    chaosBuffs: [],
                    activeChaosBlessing: [],
                    activeSageBlessing: [],
                    tutoredItems: [],
                    wrongWords: [],
                    quiz_stats: { correct: 0, total: 0 },
                    chaosPool: [],
                    draft: { active: false, round: 0, rerolls: 3, currentOptions: [] },
                    artifacts: []
                };

                // Transfer Pending Transcendence to Active State (Endless Only)
                if (this.state.gameType === 'endless') {
                    this.state.activeTranscendenceCards = [...(this.global.pendingTranscendenceCards || [])];
                    this.global.pendingTranscendenceCards = [];
                    this.saveGlobalData();
                } else {
                    this.state.activeTranscendenceCards = [];
                }

                if (mode === 'chaos') {
                    let allCards = GameUtils.buildCardPool(this.global, {
                        includeTranscendence: true,
                        activeTranscendenceCards: this.state.activeTranscendenceCards
                    });

                    allCards.sort(() => Math.random() - 0.5);
                    const picks = allCards.slice(0, GAME_CONSTANTS.CHAOS_POOL_SIZE).map(c => c.id);

                    this.state.chaosPool = picks;
                    this.state.inventory = [...picks];
                }

                // Origin Mode: Add Transcendence Cards directly to Inventory
                if (mode !== 'chaos' && mode !== 'draft' && this.state.activeTranscendenceCards.length > 0) {
                    this.state.inventory.push(...this.state.activeTranscendenceCards);
                    setTimeout(() => this.showAlert(`ì´ˆì›” ì¹´ë“œ ${this.state.activeTranscendenceCards.length}ì¥ì´ ì¸ë²¤í† ë¦¬ì— í•©ë¥˜í–ˆìŠµë‹ˆë‹¤!`), 500);
                }

                // Load persistent wordbook
                const vocab = Storage.load(Storage.keys.VOCAB);
                if (vocab) this.state.wrongWords = vocab;

                const col = Storage.load(Storage.keys.COLLOCATION);
                if (col) this.state.wrongCollocations = col;

                this.saveGame();
            },

            saveGame() {
                Storage.save(Storage.keys.SAVE, this.state);
                Storage.save(Storage.keys.VOCAB, this.state.wrongWords);
                this.saveGlobalData(); // Also save global just in case
                this.showAlert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
            },

            saveRecord(score = null) {
                let history = Storage.load(Storage.keys.RECORDS) || [];
                let currentStage = score !== null ? score : (this.state.enemyScale + 1);

                let stages = history.map(h => {
                    let m = h.match(/ìµœëŒ€ ìŠ¤í…Œì´ì§€: (\d+)/);
                    return m ? parseInt(m[1]) : 0;
                });

                stages.push(currentStage);
                stages.sort((a, b) => b - a);
                stages = stages.slice(0, GAME_CONSTANTS.MAX_RECORDS);

                history = stages.map(s => `ìµœëŒ€ ìŠ¤í…Œì´ì§€: ${s}`);
                Storage.save(Storage.keys.RECORDS, history);
            },

            showRecords() {
                let history = Storage.load(Storage.keys.RECORDS) || [];
                if (history.length === 0) return this.showAlert("ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
                let msg = history.map((h, i) => `${i + 1}ìœ„. ${h}`).join("<br>");
                this.openInfoModal("ìµœëŒ€ ìŠ¤í…Œì´ì§€ ê¸°ë¡ (Top 5)", msg);
            },

            // --- Screen Navigation ---
            toMenu() {
                this.showScreen('screen-menu');
                document.getElementById('ui-tickets').innerText = this.state.tickets;
                const enemyIdx = this.state.enemyScale % ENEMIES.length;
                const nextEnemy = ENEMIES[enemyIdx];
                document.getElementById('next-enemy-text').innerText = `${nextEnemy.name} [Stage ${this.state.enemyScale + 1}]`;
                const imgEl = document.getElementById('next-enemy-img');
                imgEl.src = `${nextEnemy.name}.png`;
                imgEl.style.display = 'none';
                imgEl.parentElement.style.display = 'none';

                // Mode Specific Menu Areas
                const gachaArea = document.getElementById('menu-gacha-area');
                const draftArea = document.getElementById('menu-draft-area');
                const chaosArea = document.getElementById('menu-chaos-area');

                // Hide all first
                gachaArea.style.display = 'none';
                draftArea.style.display = 'none';
                if (chaosArea) chaosArea.style.display = 'none';

                if (this.state.mode === 'draft') {
                    draftArea.style.display = 'block';
                }
                else if (this.state.mode === 'chaos') {
                    if (chaosArea) chaosArea.style.display = 'block';
                }
                else {
                    gachaArea.style.display = 'flex';
                }
            },
            toTitle() {
                // No saveRecord here
                this.showScreen('screen-title');
            },
            showScreen(id) { document.querySelectorAll('.screen').forEach(el => el.classList.remove('active')); document.getElementById(id).classList.add('active'); },

            openSystemMenu() {
                this.updateSystemMenuUI();
                document.getElementById('modal-menu').classList.add('active');
            },

            toggleTutoringEvent() {
                if (this.global.tutoringEventEnabled === undefined) this.global.tutoringEventEnabled = true;
                this.global.tutoringEventEnabled = !this.global.tutoringEventEnabled;
                this.saveGlobalData();
                this.updateSystemMenuUI();
            },

            updateSystemMenuUI() {
                const btn = document.getElementById('btn-toggle-tutoring');
                if (btn) {
                    const isOn = this.global.tutoringEventEnabled !== false;
                    btn.innerText = `ê°œì¸ê³¼ì™¸ ì´ë²¤íŠ¸: ${isOn ? 'ON' : 'OFF'}`;
                    btn.style.borderColor = isOn ? '#4caf50' : '#555';
                    btn.style.color = isOn ? '#fff' : '#aaa';
                }
            },

            // --- Chaos Roulette ---
            openChaosRoulette() {
                if (!this.checkAllBonusUnlocked()) return this.showAlert("ì•„ì§ í•´ê¸ˆë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");

                // Fix: ëª¨ë‹¬ì´ í™”ë©´ì„ ê°€ë¦¬ëŠ” ë¬¸ì œ ìˆ˜ì •
                document.getElementById('modal-mode-select').classList.remove('active');

                this.showScreen('screen-chaos-roulette');
                document.getElementById('ui-chaos-tickets').innerText = this.global.chaosTickets || 0;
            },

            spinChaosRoulette() {
                if ((this.global.chaosTickets || 0) < 1) return this.showAlert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");

                let pool = TRANSCENDENCE_CARDS.filter(c => !this.global.pendingTranscendenceCards.includes(c.id));

                if (pool.length === 0) return this.showAlert("ì´ë¯¸ ëª¨ë“  ì´ˆì›” ì¹´ë“œë¥¼ ë³´ìœ í•˜ê³  ìˆìŠµë‹ˆë‹¤. (ë‹¤ìŒ ì˜¤ë¦¬ì§„ ê²Œì„ì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”)");

                this.global.chaosTickets--;
                const pick = pool[Math.floor(Math.random() * pool.length)];
                this.global.pendingTranscendenceCards.push(pick.id);
                this.saveGlobalData();

                document.getElementById('ui-chaos-tickets').innerText = this.global.chaosTickets;

                const modal = document.getElementById('modal-gacha');
                const content = document.getElementById('gacha-result');
                document.getElementById('gacha-title').innerText = "ì´ˆì›” ì†Œí™˜ ì„±ê³µ!";
                content.innerHTML = `<div class="card-item transcendence" style="border:2px solid #ffd700; color:#ffd700; font-size:1.2rem; font-weight:bold; margin-bottom:10px; animation: glow-gold 2s infinite;">[ì´ˆì›”] ${pick.name}</div>
            <div class="portrait" style="width:120px; height:160px; margin:0 auto; border-color:#ffd700;"><img src="${pick.name}.png" onerror="this.style.display='none'"></div><p>ë‹¤ìŒ ì˜¤ë¦¬ì§„ ê²Œì„ ì „ì„¤ í’€ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!</p>`;
                modal.classList.add('active');
            },

            openTranscendenceCheck() {
                this.showScreen('screen-transcendence-check');
                this.renderCardList('transcendence-grid', this.global.pendingTranscendenceCards, (id) => this.showCardInfo(id));
            },

            // --- Chaos Blessing ---
            openChaosBlessing() {
                if (this.state.greatSageBlessingUses === undefined) this.state.greatSageBlessingUses = 3;
                document.getElementById('chaos-uses').innerText = this.state.chaosBlessingUses;
                document.getElementById('sage-uses').innerText = this.state.greatSageBlessingUses;

                const chaosModal = document.getElementById('modal-chaos');
                const isArtifactMobileLayout = this.state.mode === 'artifact' &&
                    (this.state.gameType === 'challenge' || this.state.gameType === 'endless');
                chaosModal.classList.toggle('artifact-mobile-compact', isArtifactMobileLayout);

                // Show artifact check button only in artifact mode
                const artBtn = document.getElementById('btn-artifact-check');
                const modal = document.getElementById('modal-chaos');
                if (artBtn) {
                    artBtn.style.display = (this.state.mode === 'artifact') ? 'block' : 'none';
                }

                if (this.state.mode === 'artifact') {
                    modal.classList.add('artifact-mode');
                } else {
                    modal.classList.remove('artifact-mode');
                }

                modal.classList.add('active');
                chaosModal.classList.add('active');
            },
            checkActiveChaosBlessings() {
                if (!this.state.chaosBuffs || this.state.chaosBuffs.length === 0) {
                    return this.showAlert("í˜„ì¬ ì ìš©ëœ ì¶•ë³µì´ ì—†ìŠµë‹ˆë‹¤.");
                }
                let msg = "<b>í˜„ì¬ ì ìš©ëœ ì¶•ë³µ</b><br><br>";
                this.state.chaosBuffs.forEach(b => {
                    msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier * 100)}%, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€`;
                    msg += "<br>";
                });
                msg += "<br>(ì „íˆ¬ ì‹œì‘ ì‹œ í•´ë‹¹ ì¹´ë“œì˜ ì²´ë ¥ì´ ëª¨ë‘ íšŒë³µë©ë‹ˆë‹¤.)";
                this.openInfoModal("ì¶•ë³µ ìƒíƒœ", msg);
            },
            activateChaos(type) {
                if (type === 'great_sage') {
                    if (this.state.greatSageBlessingUses <= 0) {
                        return this.showAlert("ëŒ€í˜„ìì˜ ì¶•ë³µ ê¸°íšŒë¥¼ ëª¨ë‘ ì†Œì§„í–ˆìŠµë‹ˆë‹¤. (ìƒˆë¡œí•˜ê¸° ì‹œ ë¦¬ì…‹)");
                    }
                    document.getElementById('modal-chaos').classList.remove('active');

                    // Pick random quiz
                    let allQuizzes = [];
                    GRAMMAR_DATA.forEach(lec => {
                        allQuizzes = allQuizzes.concat(lec.quizzes);
                    });
                    let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

                    this.showConfirm(`ì´ ë¬¸ì œëŠ” ${q.lecture_id}ê°•ì˜ ë‚´ìš©ì´ì•¼. ê°•ì˜ë¥¼ í™•ì¸í•˜ê³  í’€ë˜?`,
                        () => { // Yes
                            this.showLecture(q.lecture_id, () => {
                                this.startGrammarQuiz(q);
                            });
                        },
                        () => { // No
                            this.startGrammarQuiz(q);
                        }
                    );
                    return;
                }

                if (this.state.chaosBlessingUses <= 0) {
                    return this.showAlert("ì´ë²ˆ ì „íˆ¬ êµ¬ê°„ì˜ ì¶•ë³µ ê¸°íšŒë¥¼ ëª¨ë‘ ì†Œì§„í–ˆìŠµë‹ˆë‹¤.");
                }
                document.getElementById('modal-chaos').classList.remove('active');

                // Mode Bonus
                let bonus = 0;
                if (this.state.mode === 'suffering') bonus = 2;
                if (this.state.mode === 'overdrive') bonus = 1;

                if (type === 'normal') {
                    this.applyChaosBlessing(3 + bonus);
                } else if (type === 'challenge') {
                    this.startChaosQuiz((success) => {
                        if (success) {
                            this.applyChaosBlessing(5 + bonus);
                        } else {
                            this.state.chaosBlessingUses--;
                            document.getElementById('chaos-uses').innerText = this.state.chaosBlessingUses;
                            this.showAlert("í€´ì¦ˆ ì‹¤íŒ¨... ê¸°íšŒê°€ 1íšŒ ì°¨ê°ë˜ì—ˆìŠµë‹ˆë‹¤.");
                        }
                    });
                }
            },

            startGrammarQuiz(q, successCallback = null, failCallback = null) {
                const onCorrect = successCallback
                    ? successCallback
                    : () => this.applyGreatSageBlessing();
                const onWrong = failCallback
                    ? failCallback
                    : () => {
                        this.state.greatSageBlessingUses--;
                        this.showAlert(`í‹€ë ¸ì–´... ë‚¨ì€ ê¸°íšŒ: ${this.state.greatSageBlessingUses}íšŒ`);
                    };
                const config = QuizEngine.buildGrammarQuiz(q, onCorrect, onWrong);
                QuizEngine.show(config);
            },

            updateMergedBlessings() {
                this.state.chaosBuffs = [];

                const addBuffs = (list) => {
                    list.forEach(nb => {
                        let existing = this.state.chaosBuffs.find(b => b.id === nb.id);
                        if (existing) {
                            existing.multiplier += nb.multiplier;
                        } else {
                            this.state.chaosBuffs.push({ ...nb });
                        }
                    });
                };

                if (this.state.activeChaosBlessing) addBuffs(this.state.activeChaosBlessing);
                if (this.state.activeSageBlessing) addBuffs(this.state.activeSageBlessing);
            },

            applyGreatSageBlessing() {
                this.state.greatSageBlessingUses--;
                // Update UI immediately
                document.getElementById('sage-uses').innerText = this.state.greatSageBlessingUses;

                this.state.tickets += 1;
                if (document.getElementById('ui-tickets')) document.getElementById('ui-tickets').innerText = this.state.tickets;

                // Apply to 12 random cards
                let pool = GameUtils.buildCardPool(this.global, {
                    excludeTranscendence: true,
                    maxGrade: GameUtils.getMaxGradeForMode(this.state.mode)
                });

                pool.sort(() => 0.5 - Math.random());
                let picks = pool.slice(0, GAME_CONSTANTS.SAGE_BLESSING_PICK_COUNT);

                this.state.activeChaosBlessing = []; // Clear Chaos Blessing

                let newBuffs = picks.map(c => {
                    let mult = 0;
                    if (c.grade === 'normal') mult = 0.4;
                    else if (c.grade === 'rare') mult = 0.3;
                    else if (c.grade === 'epic') mult = 0.2;
                    else if (c.grade === 'legend') mult = 0.1;
                    return { id: c.id, name: c.name, multiplier: mult, isSage: true };
                });

                // Set to activeSageBlessing (Replacing previous)
                this.state.activeSageBlessing = newBuffs;
                this.updateMergedBlessings();

                let msg = "<b>ëŒ€í˜„ìì˜ ì¶•ë³µ ì„±ê³µ!</b><br>12ëª…ì˜ ë™ë£Œì—ê²Œ ì¶•ë³µì´ ë‚´ë ¤ì¡ŒìŠµë‹ˆë‹¤.<br>ë“œë¡œìš° í‹°ì¼“ 1ì¥ íšë“!<br><br><b>[ìƒˆë¡œ ì ìš©ëœ ì¶•ë³µ]</b><br>";
                newBuffs.forEach(b => {
                    msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier * 100)}%, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€<br>`;
                });
                msg += `<br><b>(í˜„ì¬ ì´ í™œì„±í™”ëœ ì¶•ë³µ: ${this.state.chaosBuffs.length}ê°œ)</b>`;

                this.openInfoModal("ì¶•ë³µ ì„±ê³µ", msg);
            },

            applyChaosBlessing(count) {
                this.state.chaosBlessingUses--;

                // 1. Build Pool
                let pool = GameUtils.buildCardPool(this.global, {
                    excludeTranscendence: true,
                    maxGrade: GameUtils.getMaxGradeForMode(this.state.mode)
                });

                // 2. Shuffle and Pick
                pool.sort(() => 0.5 - Math.random());
                let picks = pool.slice(0, count);

                this.state.activeSageBlessing = []; // Clear Sage Blessing

                let newBuffs = picks.map(c => {
                    let mult = 0;
                    if (c.grade === 'normal') mult = 0.4;
                    else if (c.grade === 'rare') mult = 0.3;
                    else if (c.grade === 'epic') mult = 0.2;
                    else if (c.grade === 'legend') mult = 0.1;
                    return { id: c.id, name: c.name, multiplier: mult };
                });

                // Set to activeChaosBlessing (Replacing previous)
                this.state.activeChaosBlessing = newBuffs;
                this.updateMergedBlessings();

                let msg = "<b>í˜¼ëˆì˜ ì¶•ë³µ ì ìš©!</b><br>ìƒˆë¡œìš´ ì¶•ë³µì´ ë¶€ì—¬ë˜ì—ˆìŠµë‹ˆë‹¤.<br><br><b>[ìƒˆë¡œ ì ìš©ëœ ì¶•ë³µ]</b><br>";
                newBuffs.forEach(b => {
                    msg += `[${b.name}] ì˜¬ìŠ¤íƒ¯ +${Math.round(b.multiplier * 100)}%, ì¹˜ëª…íƒ€/íšŒí”¼ìœ¨ ì¦ê°€<br>`;
                });
                msg += `<br><b>(í˜„ì¬ ì´ í™œì„±í™”ëœ ì¶•ë³µ: ${this.state.chaosBuffs.length}ê°œ)</b><br>(ì „íˆ¬ ì‹œì‘ ì‹œ í•´ë‹¹ ì¹´ë“œì˜ ì²´ë ¥ì´ ëª¨ë‘ íšŒë³µë©ë‹ˆë‹¤.)`;
                this.openInfoModal("ì¶•ë³µ ì„±ê³µ", msg);
            },

            // --- Gacha & Deck UI ---
            reshuffleChaosPool() {
                if (this.state.tickets < GAME_CONSTANTS.COSTS.CHAOS_SHUFFLE) {
                    return this.showAlert("ì…”í”Œí•  í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }

                this.showDoubleConfirm(
                    `í˜„ì¬ ë³´ìœ í•œ ëª¨ë“  ì¹´ë“œì™€ ë± êµ¬ì„±ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.<br>
            í‹°ì¼“ 1ì¥ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ 15ì¥ì„ ë°›ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?`,
                    `ì •ë§ ì…”í”Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>í˜„ì¬ ë±ê³¼ ì¸ë²¤í† ë¦¬ê°€ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.`,
                    () => {
                        this.state.tickets -= GAME_CONSTANTS.COSTS.CHAOS_SHUFFLE;
                        document.getElementById('ui-tickets').innerText = this.state.tickets;

                        let allCards = GameUtils.buildCardPool(this.global, {
                            includeTranscendence: true,
                            activeTranscendenceCards: this.state.activeTranscendenceCards
                        });

                        allCards.sort(() => Math.random() - 0.5);
                        const newPicks = allCards.slice(0, GAME_CONSTANTS.CHAOS_POOL_SIZE).map(c => c.id);

                        this.state.chaosPool = newPicks;
                        this.state.inventory = [...newPicks];
                        this.state.deck = [null, null, null];

                        this.saveGame();

                        let legendCnt = 0, epicCnt = 0;
                        newPicks.forEach(id => {
                            const c = this.getCardData(id);
                            if (c.grade === 'legend') legendCnt++;
                            if (c.grade === 'epic') epicCnt++;
                        });

                        this.showAlert(
                            `<b>ì¹´ì˜¤ìŠ¤ ì…”í”Œ ì™„ë£Œ!</b><br><br>
                    ìƒˆë¡œìš´ 15ì¥ì´ ì§€ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
                    (ì „ì„¤: ${legendCnt}, ì—í”½: ${epicCnt})<br><br>
                    * ë±ì´ ì´ˆê¸°í™”ë˜ì—ˆìœ¼ë‹ˆ ë‹¤ì‹œ êµ¬ì„±í•´ì£¼ì„¸ìš”.`
                        );
                    }
                );
            },

            openGacha() {
                if (this.state.tickets < GAME_CONSTANTS.COSTS.GACHA_SINGLE) return this.showAlert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                this.state.tickets -= GAME_CONSTANTS.COSTS.GACHA_SINGLE;
                this.runGacha(false);
            },

            openChallengeGacha() {
                if (this.state.tickets < GAME_CONSTANTS.COSTS.GACHA_SINGLE) return this.showAlert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");

                // í‹°ì¼“ ì„ ì°¨ê°
                this.state.tickets -= GAME_CONSTANTS.COSTS.GACHA_SINGLE;
                document.getElementById('ui-tickets').innerText = this.state.tickets;

                this.startQuiz((success) => {
                    if (success) {
                        this.runGacha(true);
                    } else {
                        this.showAlert("í€´ì¦ˆ ì‹¤íŒ¨! (í‹°ì¼“ì´ ì†Œëª¨ë˜ì—ˆìŠµë‹ˆë‹¤)");
                    }
                });
            },

            runGacha(isChallenge) {
                document.getElementById('ui-tickets').innerText = this.state.tickets;
                const mode = this.state.mode;

                // Determine Grade (data-driven via GACHA_RATES)
                const grade = GameUtils.resolveGachaGrade(mode, isChallenge);

                // Build Pool
                let pool = CARDS.filter(c => c.grade === grade && !c.hide_from_gacha);

                // Add Bonus Cards
                if (this.global.unlocked_bonus_cards.length > 0) {
                    const bonus = BONUS_CARDS.filter(c => c.grade === grade && this.global.unlocked_bonus_cards.includes(c.id));
                    pool = pool.concat(bonus);
                }


                if (pool.length === 0) {
                    // Fallback if pool is empty (e.g. no cards of that grade? Should not happen with standard set)
                    // But if Restriction mode and we rolled something else? Logic guarantees valid grade.
                    // If somehow empty, fallback to normal
                    console.error("Empty pool for grade: " + grade);
                    grade = 'normal';
                    pool = CARDS.filter(c => c.grade === 'normal' && !c.hide_from_gacha);
                }

                const pick = pool[Math.floor(Math.random() * pool.length)];
                this.state.inventory.push(pick.id);

                const modal = document.getElementById('modal-gacha');
                const content = document.getElementById('gacha-result');
                let color = '#bdbdbd', title = "íšë“!";
                if (pick.grade === 'transcendence') { color = '#ffd700'; title = "ğŸŒŸ ì´ˆì›” ì¹´ë“œ ê°•ë¦¼! ğŸŒŸ"; }
                else if (grade === 'legend') { color = '#ff5252'; title = "ğŸ‰ ëŒ€ë°•! ì „ì„¤ ì¹´ë“œ! ğŸ‰"; }
                else if (grade === 'epic') { color = '#e040fb'; title = "âœ¨ ì—í”½ ì¹´ë“œ! âœ¨"; }

                let msgTitle = isChallenge ? "ë„ì „ ë½‘ê¸° ì„±ê³µ!" : "íšë“!";
                if (pick.grade === 'transcendence') msgTitle = title;
                document.getElementById('gacha-title').innerText = msgTitle;
                content.innerHTML = `<div style="color:${color}; font-size:1.2rem; font-weight:bold; margin-bottom:10px;">[${pick.grade.toUpperCase()}] ${pick.name}</div>
            <div class="portrait" style="width:120px; height:160px; margin:0 auto;"><img src="${pick.name}.png" onerror="this.style.display='none'"></div><p>ìƒˆë¡œìš´ ë™ë£Œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤!</p>`;
                modal.classList.add('active');
            },

            // --- Library & Lecture ---
            openLibrary() {
                document.getElementById('modal-library').classList.add('active');
            },
            openMagicClass() {
                document.getElementById('modal-library').classList.remove('active');
                const list = document.getElementById('lecture-list');
                list.innerHTML = "";
                GRAMMAR_DATA.forEach(lec => {
                    const btn = document.createElement('button');
                    btn.className = "menu-btn";
                    btn.innerText = `${lec.id}ê°•. ${lec.title}`;
                    btn.onclick = () => this.showLecture(lec.id);
                    list.appendChild(btn);
                });
                document.getElementById('modal-magic-class').classList.add('active');
            },
            showLecture(id, onCloseCallback) {
                const lec = GRAMMAR_DATA.find(l => l.id === id);
                if (!lec) return;
                document.getElementById('lecture-title').innerText = `${lec.id}ê°•. ${lec.title}`;
                document.getElementById('lecture-content').innerText = lec.content;

                // Setup close button to handle callback if provided (for quiz flow)
                // We override the onclick of the close button inside modal-lecture-view dynamically if needed,
                // or just use a temporary callback variable.
                const modal = document.getElementById('modal-lecture-view');

                // This is a bit hacky for the callback, but simplest given the structure.
                // We will store the callback in RPG.tempLectureClose
                this.tempLectureClose = onCloseCallback;

                modal.classList.add('active');
            },
            closeLectureView() {
                document.getElementById('modal-lecture-view').classList.remove('active');
                const cb = this.tempLectureClose;
                this.tempLectureClose = null;
                if (cb) {
                    cb();
                }
            },

            // --- Wordbook & Quiz ---
            openWordbook() {
                document.getElementById('modal-library').classList.remove('active');
                if (this.state.mode === 'chaos' || this.state.mode === 'draft') {
                    this.openCollocationBook();
                    return;
                }

                document.querySelector('#modal-wordbook h3').innerText = "ë‹¨ì–´ì¥"; // Reset title
                if (!this.state.wrongWords) this.state.wrongWords = [];
                const list = document.getElementById('wordbook-list');
                list.innerHTML = "";

                const onlyWrong = document.getElementById('wordbook-filter-wrong').checked;

                VOCAB_DATA.forEach(v => {
                    const isWrong = this.state.wrongWords.includes(v.word);

                    // Filter logic
                    if (onlyWrong && !isWrong) return;

                    const div = document.createElement('div');
                    div.style.marginBottom = "10px";
                    div.style.borderBottom = "1px solid #444";
                    div.style.paddingBottom = "5px";

                    // Apply red color if wrong
                    const wordColor = isWrong ? '#ef5350' : '#81d4fa';

                    div.innerHTML = `<b style="color:${wordColor}; font-size:1.1rem;">${v.word}</b><br>
                             <span style="color:#eee;">${v.meaning}</span>`;
                    list.appendChild(div);
                });
                document.getElementById('modal-wordbook').classList.add('active');
            },

            resetWrongWords() {
                if (this.state.mode === 'chaos' || this.state.mode === 'draft') {
                    this.state.wrongCollocations = [];
                    Storage.remove(Storage.keys.COLLOCATION);
                    this.showAlert("ìˆ™ì–´/êµ¬ë™ì‚¬ ë³µìŠµ ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
                    this.openCollocationBook();
                    return;
                }

                this.state.wrongWords = [];
                Storage.remove(Storage.keys.VOCAB);
                this.showAlert("ë³µìŠµ ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
                this.openWordbook(); // Re-render
            },

            openCollocationBook() {
                if (!this.state.wrongCollocations) this.state.wrongCollocations = [];
                const list = document.getElementById('wordbook-list');
                list.innerHTML = "";

                const onlyWrong = document.getElementById('wordbook-filter-wrong').checked;

                COLLOCATION_DATA.forEach(v => {
                    const isWrong = this.state.wrongCollocations.includes(v.id);

                    if (onlyWrong && !isWrong) return;

                    const div = document.createElement('div');
                    div.style.marginBottom = "10px";
                    div.style.borderBottom = "1px solid #444";
                    div.style.paddingBottom = "5px";

                    const color = isWrong ? '#ef5350' : '#81d4fa';

                    div.innerHTML = `<b style="color:${color}; font-size:1.1rem;">${v.expression}</b><br>
                             <span style="color:#eee;">${v.meaning}</span>`;
                    list.appendChild(div);
                });

                document.querySelector('#modal-wordbook h3').innerText = "ìˆ™ì–´/êµ¬ë™ì‚¬ ë‹¨ì–´ì¥";
                document.getElementById('modal-wordbook').classList.add('active');
            },

            startCollocationQuiz(callback) {
                const config = QuizEngine.buildCollocationQuiz(callback);
                if (!config) return this.showAlert("ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜: Collocation ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                QuizEngine.show(config);
            },

            startQuiz(callback) {
                const config = QuizEngine.buildVocabQuiz(callback);
                if (!config) return this.showAlert("ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜: ë‹¨ì–´ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                QuizEngine.show(config);
            },

            startChaosQuiz(callback) {
                const config = QuizEngine.buildChaosQuiz(callback);
                if (!config) return this.showAlert("ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜: ë‹¨ì–´ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                QuizEngine.show(config);
            },
            closeGachaModal() { document.getElementById('modal-gacha').classList.remove('active'); },

            openCollection() { this.showScreen('screen-collection'); this.renderCardList('collection-grid', this.state.inventory, (id) => this.showCardInfo(id)); },

            renderCardList(containerId, list, clickHandler) {
                const box = document.getElementById(containerId);
                box.innerHTML = "";
                let counts = {};
                list.forEach(id => { counts[id] = (counts[id] || 0) + 1; });
                for (let id in counts) {
                    const data = this.getCardData(id);
                    if (!data) continue;
                    const el = document.createElement('div');
                    el.className = `card-item ${data.grade}`;
                    el.innerHTML = `<div class="portrait"><img src="${data.name}.png" onerror="this.style.display='none'"></div><div>${data.name} (x${counts[id]})</div>`;
                    el.onclick = () => clickHandler(id);
                    box.appendChild(el);
                }
            },

            showCardInfo(id) {
                const data = this.getCardData(id);
                if (!data) return;
                document.getElementById('md-name').innerText = data.name;
                document.getElementById('md-img').src = `${data.name}.png`;
                document.getElementById('md-grade').className = data.grade;
                document.getElementById('md-grade').innerText = `${data.grade.toUpperCase()} / ${data.role} / ${data.element}`;
                document.getElementById('md-stats').innerHTML = `HP:${data.stats.hp} ATK:${data.stats.atk} MATK:${data.stats.matk}<br>DEF:${data.stats.def} MDEF:${data.stats.mdef}`;
                let skills = `<p style="color:#ffd700; margin:5px 0;">[íŠ¹ì„±] ${data.trait.desc}</p>`;
                skills += `<p style="margin:2px 0;">[ì¼ë°˜ ê³µê²©] (Tier 1) ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©</p>`;
                data.skills.forEach(s => {
                    let multText = s.val ? ` (x${s.val})` : '';
                    skills += `<p style="margin:2px 0;">[${s.name}] (Tier ${s.tier}, MP:${s.cost}) ${s.desc}${multText}</p>`;
                });
                document.getElementById('md-skills').innerHTML = skills;
                document.getElementById('modal-card').classList.add('active');
            },
            closeModal() { document.getElementById('modal-card').classList.remove('active'); },

            openDeck() {
                this.showScreen('screen-deck');
                this.updateDeckSlots();
                this.selectedSlot = -1;
                this.renderCardList('deck-card-list', this.state.inventory, (id) => {
                    if (this.selectedSlot === -1) this.selectedSlot = this.state.deck.indexOf(null);
                    if (this.selectedSlot === -1) return this.showAlert("ìŠ¬ë¡¯ì„ ë¨¼ì € ì„ íƒí•˜ê±°ë‚˜ ë¹ˆ ìŠ¬ë¡¯ì´ ì—†ìŠµë‹ˆë‹¤.");
                    let total = this.state.inventory.filter(x => x === id).length;
                    let used = this.state.deck.filter(x => x === id).length;
                    if (this.state.deck[this.selectedSlot] === id) used--;
                    if (total - used <= 0) return this.showAlert("ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                    this.state.deck[this.selectedSlot] = id;
                    this.updateDeckSlots();
                });
            },
            selectDeckSlot(idx) { this.selectedSlot = idx; document.querySelectorAll('.deck-slot').forEach((el, i) => { el.style.borderColor = i === idx ? '#ffd700' : '#555'; }); },
            updateDeckSlots() {
                ['ì„ ë´‰', 'ì¤‘ê²¬', 'ëŒ€ì¥'].forEach((role, i) => {
                    const id = this.state.deck[i];
                    const el = document.getElementById(`slot-${i}`);
                    if (id) { const c = this.getCardData(id); el.innerText = `${role}: ${c.name}`; el.classList.add('filled'); }
                    else { el.innerText = `${role} (ë¹„ì–´ìˆìŒ)`; el.classList.remove('filled'); }
                });
            },
            confirmDeck() { if (this.state.deck.every(x => x === null)) return this.showAlert("ìµœì†Œ 1ì¥ì˜ ì¹´ë“œëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤."); this.toMenu(); },

            // --- Battle Logic Start ---

            startBattleInit() {
                if (this.state.deck.every(x => x === null)) return this.showAlert("ë±ì„ ì™„ì„±í•´ì£¼ì„¸ìš”.");
                this.showScreen('screen-battle');
                const enemyIdx = this.state.enemyScale % ENEMIES.length;
                const baseEnemy = ENEMIES[enemyIdx];
                let cycle = Math.floor(this.state.enemyScale / ENEMIES.length);
                let scale = 1.0 + (cycle * 0.2);

                this.battle.enemy = {
                    id: baseEnemy.id, name: baseEnemy.name,
                    maxHp: Math.floor(baseEnemy.stats.hp * scale), hp: Math.floor(baseEnemy.stats.hp * scale),
                    atk: Math.floor(baseEnemy.stats.atk * scale), matk: Math.floor(baseEnemy.stats.matk * scale),
                    def: Math.floor(baseEnemy.stats.def * scale), mdef: Math.floor(baseEnemy.stats.mdef * scale),
                    baseDef: Math.floor(baseEnemy.stats.def * scale), baseMdef: Math.floor(baseEnemy.stats.mdef * scale),
                    skills: baseEnemy.skills, buffs: {}, element: baseEnemy.element,
                    tookDamageThisTurn: false, lastHitType: null
                };
                if (baseEnemy.id === 'creator_god') this.battle.enemy.chargeTurn = 0;

                // Init Players (Using Logic for Initial Stats)
                this.battle.activeTraits = []; // Reset active traits before calc

                this.battle.players = this.state.deck.map((id, idx) => {
                    if (!id) return null;
                    const proto = this.getCardData(id);

                    // Call Logic to calculate initial stats (Base + Synergies)
                    const allCards = [...CARDS, ...BONUS_CARDS, ...(typeof TRANSCENDENCE_CARDS !== 'undefined' ? TRANSCENDENCE_CARDS : [])];
                    const init = Logic.calculateInitialStats(proto, this.state.deck, allCards, idx);

                    // Log active synergy if any
                    if (init.activeTrait) {
                        // Avoid duplicate logs if multiple players trigger same synergy?
                        // But synergy is usually per player check in Logic.
                        // Actually, Logic returns activeTrait for THIS player.
                        this.battle.activeTraits.push(init.activeTrait);
                        RPG.log(`[ì‹œë„ˆì§€] ${proto.trait.desc} ë°œë™!`);
                    }

                    // Construct Player Object
                    let p = {
                        id: proto.id, proto: proto, name: proto.name,
                        ...init.stats, // hp, maxHp, mp, atk, matk, def, mdef, baseCrit, baseEva
                        buffs: {}, pos: idx, isDead: false,
                        skills: JSON.parse(JSON.stringify(proto.skills)) // Clone skills
                    };

                    // Apply Chaos Blessing Buffs (Multiplicative to the Synergized Base)
                    const blessing = this.state.chaosBuffs.find(b => b.id === p.id);
                    if (blessing) {
                        // Store base stats before blessing for UI comparison
                        p.baseStatsWithoutBlessing = { atk: p.atk, matk: p.matk, def: p.def, mdef: p.mdef };

                        p.maxHp = Math.floor(p.maxHp * (1 + blessing.multiplier));
                        p.hp = p.maxHp;
                        p.blessing = blessing;

                        let mult = 1.0 + blessing.multiplier;
                        p.atk = Math.floor(p.atk * mult);
                        p.matk = Math.floor(p.matk * mult);
                        p.def = Math.floor(p.def * mult);
                        p.mdef = Math.floor(p.mdef * mult);
                    }

                    // Apply Positional Traits (Multiplicative)
                    if (proto.trait.type.startsWith('pos_')) {
                        const t = proto.trait;
                        let active = (t.type.includes('van') && idx === 0) || (t.type.includes('mid') && idx === 1) || (t.type.includes('rear') && idx === 2);
                        if (active) {
                            if (t.type.includes('_atk')) p.atk = Math.floor(p.atk * (1 + t.val / 100));
                            if (t.type.includes('_matk')) p.matk = Math.floor(p.matk * (1 + t.val / 100));
                            if (t.type.includes('_def')) p.def = Math.floor(p.def * (1 + t.val / 100));
                            if (t.type.includes('_mdef')) p.mdef = Math.floor(p.mdef * (1 + t.val / 100));
                        }
                    }
                    return p;
                });

                // Dedup activeTraits if needed?
                // Logic.calculateInitialStats checks active conditions.
                // If 3 nature cards, each one triggers syn_nature_3_def in Logic?
                // Yes, because Logic checks `countEl` based on the deck.
                // So we might get duplicates in `this.battle.activeTraits`.
                // This is fine for `includes` checks, but if we log multiple times it's noisy.
                // We can unique them if we want, but logic relies on `includes` which works.

                this.battle.fieldBuffs = [];
                this.battle.delayedEffects = [];
                this.battle.turn = 1;
                this.battle.currentPlayerIdx = 0;
                this.battle.isNewTurn = true;

                while (this.battle.currentPlayerIdx < 3 && this.battle.players[this.battle.currentPlayerIdx] === null) {
                    this.battle.currentPlayerIdx++;
                }

                document.getElementById('battle-log').innerHTML = "";
                this.log(`ì „íˆ¬ ê°œì‹œ! ì : ${this.battle.enemy.name}`);

                // Artifact: gale_storm â€” apply gale field buff for first 3 turns
                if (this.hasArtifact('gale_storm')) {
                    this.applyFieldBuff('gale');
                    this.log('[ì•„í‹°íŒ©íŠ¸] ì§ˆí’ë…¸ë„: ì „íˆ¬ ì‹œì‘ ì‹œ ì§ˆí’ ë°œë™!');
                }

                // Artifact: support_boost â€” set all sup skill costs to 0
                if (this.hasArtifact('support_boost')) {
                    this.battle.players.forEach(p => {
                        if (p && p.skills) {
                            p.skills.forEach(s => {
                                if (s.type === 'sup') s.cost = 0;
                            });
                        }
                    });
                    this.log('[ì•„í‹°íŒ©íŠ¸] ì„œí¬íŠ¸ë¶€ìŠ¤íŠ¸: ëª¨ë“  ë³´ì¡°ìŠ¤í‚¬ ë§ˆë‚˜ ì†Œë¹„ 0!');
                }

                this.renderBattlefield();
                this.TurnManager.startPlayerTurn();
            },

            // --- Turn Manager ---
            TurnManager: {
                startPlayerTurn() {
                    const b = RPG.battle;
                    if (b.currentPlayerIdx >= 3) { RPG.loseBattle(); return; }

                    if (b.isNewTurn) {
                        b.isNewTurn = false;
                        RPG.log(`=== ${b.turn}í„´ ===`, 'info');

                        // Artifact: kaleidoscope
                        if (RPG.hasArtifact('kaleidoscope')) {
                            let count = b.fieldBuffs.length;
                            if (count > 0) {
                                b.fieldBuffs = []; // Clear
                                RPG.log('[ì•„í‹°íŒ©íŠ¸] ë§Œí™”ê²½: í•„ë“œ ë²„í”„ ì¬êµ¬ì„±!');

                                // Get all available buff keys
                                const allBuffs = Object.keys(GAME_CONSTANTS.FIELD_BUFF_STATS);

                                // Select unique random buffs
                                let pool = [...allBuffs].sort(() => 0.5 - Math.random());
                                let picks = pool.slice(0, Math.min(count, pool.length));

                                picks.forEach(bid => RPG.applyFieldBuff(bid));
                            }
                        }

                        // Artifact: gale_storm â€” maintain gale field buff for first 3 turns
                        if (RPG.hasArtifact('gale_storm')) {
                            if (b.turn <= 3) {
                                if (!b.fieldBuffs.some(buff => buff.name === 'gale')) {
                                    RPG.applyFieldBuff('gale');
                                }
                            } else if (b.turn === 4) {
                                const hadGale = b.fieldBuffs.some(buff => buff.name === 'gale');
                                if (hadGale) {
                                    b.fieldBuffs = b.fieldBuffs.filter(buff => buff.name !== 'gale');
                                    RPG.log('[ì•„í‹°íŒ©íŠ¸] ì§ˆí’ë…¸ë„ íš¨ê³¼ ì¢…ë£Œ. (ì§ˆí’ ì œê±°)');
                                }
                            }
                        }

                        // Demon God Passive (Apply at start of turn for visibility)
                        if (b.enemy && b.enemy.id === 'demon_god') {
                            b.enemy.def = b.enemy.baseDef; b.enemy.mdef = b.enemy.baseMdef;
                            if (b.turn % 2 === 0) {
                                b.enemy.def = Math.floor(b.enemy.def * 1.5);
                                RPG.log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: ì§ìˆ˜ í„´ ë¬¼ë¦¬ë°©ì–´ë ¥ 50% ì¦ê°€.");
                            } else {
                                b.enemy.mdef = Math.floor(b.enemy.mdef * 1.5);
                                RPG.log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: í™€ìˆ˜ í„´ ë§ˆë²•ë°©ì–´ë ¥ 50% ì¦ê°€.");
                            }
                        }
                    }
                    if (b.enemy) b.enemy.lastHitType = null;

                    let p = b.players[b.currentPlayerIdx];
                    if (!p || p.isDead) {
                        b.currentPlayerIdx++;
                        this.startPlayerTurn();
                        return;
                    }

                    // Process Delayed Effects
                    for (let i = b.delayedEffects.length - 1; i >= 0; i--) {
                        let effect = b.delayedEffects[i];
                        if (effect.turn === b.turn) {
                            b.delayedEffects.splice(i, 1);
                            if (effect.source.isDead) {
                                RPG.log(`${effect.skill.name} ë°œë™ ì‹¤íŒ¨... (ì‹œì „ì ì‚¬ë§)`);
                            } else {
                                RPG.log(`${effect.skill.name} ë°œë™!`);
                                RPG.executeSkill(effect.source, b.enemy, effect.skill, true);
                            }
                        }
                    }

                    // Clear temporary self buffs
                    ['evasion', 'barrier', 'magic_guard', 'guard'].forEach(k => delete p.buffs[k]);

                    RPG.renderBattlefield();

                    if (p.buffs.stun) {
                        RPG.log(`${p.name} ê¸°ì ˆë¡œ ì¸í•´ í–‰ë™ ë¶ˆê°€.`);
                        delete p.buffs.stun;
                        this.endPlayerTurn();
                        return;
                    }

                    RPG.setupControls(p);
                },

                endPlayerTurn() {
                    setTimeout(() => this.startEnemyTurn(), 500);
                },

                startEnemyTurn() {
                    const b = RPG.battle;
                    const e = b.enemy;
                    if (e.hp <= 0) { RPG.winBattle(); return; }

                    RPG.log("--- ì  í„´ ---");
                    e.def = e.baseDef; e.mdef = e.baseMdef; // Reset base

                    // Boss Passive Logic
                    if (e.id === 'artificial_demon_god') {
                        delete e.buffs.defProtocolPhy; delete e.buffs.defProtocolMag;
                        if (e.lastHitType === 'phy') { e.buffs.defProtocolPhy = 1; RPG.log("ë°©ì–´ í”„ë¡œí† ì½œ: ë¬¼ë¦¬ í”¼ê²© ê°ì§€ (ë‹¤ìŒ í„´ ë¬¼ë¦¬ë°©ì–´ë ¥ ì¦ê°€)."); }
                        if (e.lastHitType === 'mag') { e.buffs.defProtocolMag = 1; RPG.log("ë°©ì–´ í”„ë¡œí† ì½œ: ë§ˆë²• í”¼ê²© ê°ì§€ (ë‹¤ìŒ í„´ ë§ˆë²•ë°©ì–´ë ¥ ì¦ê°€)."); }
                        if (e.buffs.defProtocolPhy) e.def = Math.floor(e.def * 1.5);
                        if (e.buffs.defProtocolMag) e.mdef = Math.floor(e.mdef * 1.5);
                    }
                    if (e.id === 'demon_god') {
                        // Re-apply without log (applied at start of player turn)
                        if (b.turn % 2 === 0) { e.def = Math.floor(e.def * 1.5); }
                        else { e.mdef = Math.floor(e.mdef * 1.5); }
                    }

                    if (e.buffs.stun) {
                        RPG.log(`${e.name} ê¸°ì ˆí•˜ì—¬ í–‰ë™ ë¶ˆê°€.`);
                        delete e.buffs.stun;
                        this.endEnemyTurn();
                        return;
                    }

                    // Target Logic
                    let target = b.players[b.currentPlayerIdx];
                    if (!target || target.isDead) {
                        let validIdx = b.players.findIndex(p => p && !p.isDead);
                        if (validIdx === -1) { RPG.loseBattle(); return; }
                        b.currentPlayerIdx = validIdx;
                        target = b.players[validIdx];
                    }

                    // AI Skill Selection (Using Logic)
                    let skillInfo = Logic.decideEnemyAction(e, b.turn);

                    // Handle special AI states (Charge)
                    if (skillInfo.chargeReset) e.isCharging = false;
                    if (skillInfo.isChargeStart) {
                        e.isCharging = true;
                        RPG.log("ì°½ì¡°ì‹ ì´ í˜ì„ ëª¨ìœ¼ê³  ìˆìŠµë‹ˆë‹¤... (ê³µê²© ì—†ìŒ)");
                        this.endEnemyTurn();
                        return;
                    }

                    // Map Logic result to actual skill execution
                    // Logic returns { type, val, name ... } or a skill object
                    // We treat it as the skill to execute.
                    let skill = skillInfo;

                    // Execute Enemy Skill (Simplified: Calculate -> Apply)
                    let val = skill.type === 'phy' ? e.atk : e.matk;
                    let mult = skill.val || 1.0;

                    // Pharaoh Special Counter Logic
                    if (e.id === 'pharaoh' && skill.name === 'ê³ ëŒ€ì˜ì €ì£¼' && e.tookDamageThisTurn) {
                        mult = 3.0;
                        RPG.log("ê³ ëŒ€ì˜ ì €ì£¼: í„´ ë‚´ í”¼ê²© ê°ì§€! ëŒ€ë¯¸ì§€ 3ë°°ë¡œ ë°˜ê²©!");
                    }

                    if (e.buffs.weak && skill.type === 'phy') val *= 0.8;
                    if (e.buffs.silence && skill.type === 'mag') val *= 0.8;

                    let def = skill.type === 'phy' ? target.def : target.mdef;
                    let fieldDef = 1.0;
                    b.fieldBuffs.forEach(fb => {
                        if (fb.name === 'star_powder') fieldDef += 0.3;
                        if (fb.name === 'sanctuary' && skill.type === 'mag') fieldDef += 0.25;
                        if (fb.name === 'goddess_descent') fieldDef += 0.3;
                    });

                    // Target Defense Debuffs
                    let defMult = 1.0;
                    if (skill.type === 'phy') {
                        if (target.buffs.darkness && target.buffs.corrosion) defMult = 0.6;
                        else if (target.buffs.darkness || target.buffs.corrosion) defMult = 0.8;
                    } else {
                        if (target.buffs.curse) defMult = 0.8;
                    }

                    def = Math.floor(def * fieldDef * defMult);

                    // Evasion Check
                    if (Logic.checkEvasion(target, skill.type, b.fieldBuffs, RPG.state.mode, RPG.state.artifacts || [])) {
                        RPG.log(`${target.name} íšŒí”¼ ì„±ê³µ! (${skill.name} íšŒí”¼)`);
                        // Artifact: lucky_vicky â€” mana recovery on evasion
                        if (RPG.hasArtifact('lucky_vicky')) {
                            target.mp = Math.min(GAME_CONSTANTS.MAX_MP, target.mp + 10);
                            RPG.log('[ì•„í‹°íŒ©íŠ¸] ëŸ­í‚¤ë¹„í‚¤: íšŒí”¼ ì„±ê³µ! ë§ˆë‚˜ 10 íšŒë³µ!');
                        }
                        this.endEnemyTurn();
                        return;
                    }
                    if (target.buffs.barrier && skill.type === 'phy') { RPG.log(`${target.name} ë°°ë¦¬ì–´ë¡œ ë°©ì–´!`); this.endEnemyTurn(); return; }
                    if (target.buffs.magic_guard && skill.type === 'mag') { RPG.log(`${target.name} ë§¤ì§ê°€ë“œë¡œ ë°©ì–´!`); this.endEnemyTurn(); return; }

                    let dmg = val * mult * (100 / (100 + def));
                    if (target.buffs.guard) dmg *= 0.5;
                    dmg = Math.floor(dmg);
                    target.hp -= dmg;
                    RPG.log(`${e.name}ì˜ ${skill.name}! <span class="log-dmg">${dmg}</span> í”¼í•´.`);

                    // Process Effects (if any)
                    if (skill.effects) {
                        skill.effects.forEach(eff => {
                            if (eff.type === 'mana_burn') { target.mp = 0; RPG.log("í”Œë ˆì´ì–´ ë§ˆë‚˜ ì†Œë©¸!"); }
                        });
                    }

                    if (target.hp <= 0) {
                        target.isDead = true; target.hp = 0;
                        RPG.log(`${target.name} ì“°ëŸ¬ì§!`);
                        RPG.handleDeathTraits(target, e);

                        // Advance to next valid player
                        b.currentPlayerIdx++;
                        while (b.currentPlayerIdx < 3) {
                            if (b.players[b.currentPlayerIdx] && !b.players[b.currentPlayerIdx].isDead) break;
                            b.currentPlayerIdx++;
                        }
                        if (b.currentPlayerIdx >= 3 && b.players.every(p => !p || p.isDead)) { RPG.loseBattle(); return; }
                    }

                    if (e.hp <= 0) RPG.winBattle();
                    else this.endEnemyTurn();
                },

                endEnemyTurn() {
                    RPG.battle.turn++;
                    RPG.battle.enemy.tookDamageThisTurn = false;
                    RPG.battle.isNewTurn = true;
                    this.startPlayerTurn();
                }
            },

            handleDeathTraits(victim, killer) {
                // Delegate to Logic
                const result = Logic.handleDeathTraits(
                    victim,
                    killer,
                    RPG.battle.fieldBuffs,
                    (msg) => RPG.log(msg),
                    RPG.state.deck,
                    RPG.battle.turn,
                    RPG.state.artifacts || []
                );

                // Apply results
                if (result.damageToKiller > 0) {
                    killer.hp -= result.damageToKiller;
                    killer.tookDamageThisTurn = true;
                }

                if (result.fieldBuffsToAdd && result.fieldBuffsToAdd.length > 0) {
                    result.fieldBuffsToAdd.forEach(b => RPG.applyFieldBuff(b));
                }

                if (result.killerDebuffs && killer && killer.buffs) {
                    Object.keys(result.killerDebuffs).forEach(k => {
                        killer.buffs[k] = (killer.buffs[k] || 0) + result.killerDebuffs[k];
                        // If specific duration handling is needed, add here. Currently assumed 1 stack.
                    });
                }
            },

            // --- Player Skill Execution ---

            executeSkill(source, target, skill, isDelayed = false) {
                if (!isDelayed && !skill.isDelayed) {
                    // Artifact: blue_moon
                    if (this.hasArtifact('blue_moon') && Math.random() < 0.3) {
                        RPG.log('[ì•„í‹°íŒ©íŠ¸] ë¸”ë£¨ë¬¸: ë§ˆë‚˜ ì†Œë¹„ ì—†ì´ ìŠ¤í‚¬ ì‚¬ìš©!');
                    } else {
                        source.mp -= skill.cost;
                    }
                }

                // Artifact: double_attack â€” normal attack 2.0x power
                let modifiedSkill = skill;
                if (this.hasArtifact('double_attack') && skill.name === RPG.NORMAL_ATTACK.name) {
                    modifiedSkill = { ...skill, val: (skill.val || 1.0) * 2.0 };
                }

                RPG.log(`<b>${source.name}</b>ì˜ <b>${skill.name}</b>!`);

                // Trait: Normal Attack Burn & Divine
                if (skill.name === RPG.NORMAL_ATTACK.name && source.proto && source.proto.trait && source.proto.trait.type === 'normal_attack_burn_divine') {
                    let burnMax = this.hasArtifact('over_flame') ? 5 : 3;
                    let divineMax = this.hasArtifact('over_divine') ? 5 : 3;
                    let burnAdd = this.hasArtifact('over_flame') ? 2 : 1;
                    let divineAdd = this.hasArtifact('over_divine') ? 2 : 1;
                    target.buffs['burn'] = Math.min((target.buffs['burn'] || 0) + burnAdd, burnMax);
                    target.buffs['divine'] = Math.min((target.buffs['divine'] || 0) + divineAdd, divineMax);
                    RPG.log("[íŠ¹ì„±] ì¼ë°˜ ê³µê²© ì¶”ê°€ íš¨ê³¼: ì‘ì—´, ë””ë°”ì¸ ë¶€ì—¬!");
                }

                // Trait: Phoenix Normal Attack Burn
                if (skill.name === RPG.NORMAL_ATTACK.name && source.proto && source.proto.trait && source.proto.trait.type === 'syn_fire_3_crit_burn' && RPG.battle.activeTraits.includes('syn_fire_3_crit_burn')) {
                    let burnMax = this.hasArtifact('over_flame') ? 5 : 3;
                    let burnAdd = this.hasArtifact('over_flame') ? 2 : 1;
                    target.buffs['burn'] = Math.min((target.buffs['burn'] || 0) + burnAdd, burnMax);
                    RPG.log("[íŠ¹ì„±] í”¼ë‹‰ìŠ¤: ì¼ë°˜ ê³µê²© ì‹œ ì‘ì—´ ë¶€ì—¬!");
                }

                // Trait: Behemoth (Skill Use -> Stun Chance)
                if (source.proto && source.proto.trait && source.proto.trait.type === 'behemoth_trait') {
                    if (Math.random() < 0.2) {
                        target.buffs.stun = 1;
                        RPG.log("[íŠ¹ì„±] ë² íˆëª¨ìŠ¤ì˜ ìœ„ì••ê°! ì ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤!");
                    }
                }

                // Trait: Behemoth Liberated (Skill Use -> Stun Chance)
                if (source.proto && source.proto.trait && source.proto.trait.type === 'behemoth_liberated_trait') {
                    if (Math.random() < 0.2) {
                        target.buffs.stun = 1;
                        RPG.log("[íŠ¹ì„±] í•´ë°©ëœ ë² íˆëª¨ìŠ¤: 20% í™•ë¥ ë¡œ ì ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤!");
                    }
                }

                // Check for Delayed Attack Effect
                let delayedEff = modifiedSkill.effects && modifiedSkill.effects.find(e => e.type === 'delayed_attack');
                if (!delayedEff) delayedEff = modifiedSkill.effects && modifiedSkill.effects.find(e => e.type === 'delayed_attack_field');
                if (!delayedEff) delayedEff = modifiedSkill.effects && modifiedSkill.effects.find(e => e.type === 'delayed_random_attack');

                if (delayedEff && !isDelayed) {
                    RPG.log(`ì¢…ì–¸ì˜ ì˜ˆê³ ê°€ ì‹œì‘ë©ë‹ˆë‹¤... (${delayedEff.turns}í„´ ë’¤ ë°œë™)`);
                    RPG.battle.delayedEffects.push({ turn: RPG.battle.turn + delayedEff.turns, source: source, skill: modifiedSkill });
                    RPG.TurnManager.endPlayerTurn();
                    return;
                }

                const dmgResult = this.calcDamage(source, target, modifiedSkill);

                // Apply Damage
                if (dmgResult.dmg > 0) {
                    target.hp -= dmgResult.dmg;
                    target.tookDamageThisTurn = true;
                    RPG.log(`${dmgResult.isCrit ? 'Critical! ' : ''}ì ì—ê²Œ <span class="log-dmg">${dmgResult.dmg}</span> í”¼í•´.`);
                }

                // Artifact: lucky_vicky â€” mana recovery on crit
                if (dmgResult.luckyVicky) {
                    source.mp = Math.min(GAME_CONSTANTS.MAX_MP, source.mp + 10);
                    RPG.log('[ì•„í‹°íŒ©íŠ¸] ëŸ­í‚¤ë¹„í‚¤: ì¹˜ëª…íƒ€ ë°œìƒ! ë§ˆë‚˜ 10 íšŒë³µ!');
                }

                // Artifact: death_roulette â€” 30% chance to die on skill use
                if (this.hasArtifact('death_roulette') && skill.name !== RPG.NORMAL_ATTACK.name && !isDelayed) {
                    if (Math.random() < 0.3) {
                        source.hp = 0;
                        RPG.log('<span style="color:#ff5252">[ì•„í‹°íŒ©íŠ¸] ë°ìŠ¤ë£°ë ›: ì£½ìŒì˜ ë£°ë ›ì— ë‹¹ì²¨...</span>');
                    }
                }

                // Apply Side Effects (Buffs, Debuffs, Field, Suicide, etc.)
                this.applySkillEffects(source, target, modifiedSkill);

                if (target.hp <= 0) { RPG.winBattle(); return; }
                if (source.hp <= 0 && !source.isDead) { source.isDead = true; RPG.log(`${source.name} ì‚¬ë§!`); }

                if (!isDelayed) RPG.TurnManager.endPlayerTurn();
            },

            calcDamage(source, target, skill) {
                if (skill.type !== 'phy' && skill.type !== 'mag') return { dmg: 0 };

                // Logic.js returns { dmg, isCrit, luckyVicky } and logs via callback
                const result = Logic.calculateDamage(
                    source,
                    target,
                    skill,
                    RPG.battle.fieldBuffs,
                    RPG.battle.activeTraits,
                    (msg) => RPG.log(msg),
                    RPG.state.mode, // PASS MODE
                    RPG.state.deck, // PASS DECK
                    RPG.battle.turn, // PASS TURN
                    RPG.state.artifacts || [] // PASS ARTIFACTS
                );

                if (target.id === 'demon_god') {
                    const b = RPG.battle;
                    if ((b.turn % 2 === 0 && skill.type === 'phy') || (b.turn % 2 !== 0 && skill.type === 'mag')) {
                        RPG.log("(ë§ˆì‹ ì˜ ê¶ŒëŠ¥: ë°©ì–´ë ¥ ìƒìŠ¹ ì ìš©ì¤‘)");
                    }
                }

                target.lastHitType = skill.type;

                return result;
            },

            applySkillEffects(source, target, skill) {
                if (!skill.effects) return;

                const ctx = {
                    source: source,
                    target: target,
                    skill: skill,
                    logFn: (msg) => RPG.log(msg),
                    getBuffName: (id) => (BUFF_NAMES[id] || id),
                    applyFieldBuff: (id) => RPG.applyFieldBuff(id),
                    battle: this.battle,
                    executeSkill: this.executeSkill.bind(this),
                    getCardData: this.getCardData.bind(this)
                };

                skill.effects.forEach(eff => {
                    if (typeof SideEffects !== 'undefined') {
                        SideEffects.apply(ctx, eff);
                    }
                });

                // Special Rumi Trait Trigger
                if (RPG.battle.activeTraits.includes('syn_water_nature') && skill.name === 'ë¬¸ë¼ì´íŠ¸ì„¸ë ˆë‚˜') {
                    RPG.log("ë£¨ë¯¸ì˜ íŠ¹ì„± ë°œë™! íŠ¸ìœ™í´íŒŒí‹° ì¶”ê°€!");
                    this.applyFieldBuff('twinkle_party');
                }

                // Siren Trait Trigger
                if (RPG.battle.activeTraits.includes('syn_water_2_moon_twinkle') && skill.name === 'ì‹¤ë²„ë¬¸ë² ì¼') {
                    RPG.log("[íŠ¹ì„±] ì„¸ì´ë Œì˜ ë…¸ë˜! íŠ¸ìœ™í´íŒŒí‹° ì¶”ê°€!");
                    this.applyFieldBuff('twinkle_party');
                }
            },

            applyFieldBuff(id) {
                if (this.battle.fieldBuffs.some(b => b.name === id)) return RPG.log(`í•„ë“œë²„í”„ [${BUFF_NAMES[id]}] ì´ë¯¸ ì¡´ì¬.`);
                // Artifact: buff_overload â€” increase max field buffs to 5
                let maxBuffs = this.hasArtifact('buff_overload') ? 5 : GAME_CONSTANTS.MAX_FIELD_BUFFS;
                if (this.battle.fieldBuffs.length >= maxBuffs) {
                    let removed = this.battle.fieldBuffs.shift();
                    RPG.log(`í•„ë“œë²„í”„ [${BUFF_NAMES[removed.name]}] ì†Œë©¸.`);
                }
                this.battle.fieldBuffs.push({ name: id });
                RPG.log(`í•„ë“œë²„í”„ [${BUFF_NAMES[id]}] ë°œë™!`);
            },

            // --- Setup & UI ---

            setupControls(p) {
                const panel = document.getElementById('battle-controls');
                panel.innerHTML = "";

                // Normal Attack
                const btn = document.createElement('button');
                btn.className = 'skill-btn phy';
                btn.innerHTML = `<span>ì¼ë°˜ê³µê²©</span><span style="color:#aaa">MP 0</span>`;
                btn.onclick = () => RPG.executeSkill(p, RPG.battle.enemy, RPG.NORMAL_ATTACK);
                panel.appendChild(btn);

                // Skills
                (p.skills || p.proto.skills).forEach(s => {
                    const btn = document.createElement('button');
                    btn.className = `skill-btn ${s.type}`;
                    btn.innerHTML = `<span>${s.name}</span><span style="color:#aaa">MP ${s.cost}</span>`;
                    if (p.mp < s.cost) btn.disabled = true;
                    else btn.onclick = () => RPG.executeSkill(p, RPG.battle.enemy, s);
                    panel.appendChild(btn);
                });
            },

            renderBattlefield() {
                const p = this.battle.players[this.battle.currentPlayerIdx];

                if (p && !p.isDead) {
                    document.getElementById('p-name').innerText = p.name;
                    const pImg = document.getElementById('p-img');
                    pImg.src = `${p.name}.png`;
                    pImg.style.display = 'block';

                    let hpPct = (p.hp / p.maxHp) * 100;
                    document.getElementById('p-hp-bar').style.width = `${Math.max(0, hpPct)}%`;
                    let mpPct = (p.mp / 100) * 100;
                    document.getElementById('p-mp-bar').style.width = `${Math.max(0, mpPct)}%`;

                    let buffTxt = Object.keys(p.buffs).map(k => BUFF_NAMES[k] || k).join(',');
                    document.getElementById('p-buffs').innerText = buffTxt;
                    document.getElementById('player-actor-box').style.opacity = 1;
                } else {
                    document.getElementById('player-actor-box').style.opacity = 0;
                }

                const e = this.battle.enemy;
                let eHpPct = (e.hp / e.maxHp) * 100;
                document.getElementById('e-hp-bar').style.width = `${Math.max(0, eHpPct)}%`;
                document.getElementById('e-name').innerText = e.name;
                const eImg = document.getElementById('e-img');
                eImg.src = `${e.name}.png`;
                eImg.style.display = 'block';

                let eBuffTxt = Object.keys(e.buffs).map(k => `${BUFF_NAMES[k] || k}${e.buffs[k] > 1 ? e.buffs[k] : ''}`).join(' ');
                document.getElementById('e-buffs').innerText = eBuffTxt;

                document.getElementById('bt-turn').innerText = this.battle.turn;
                document.getElementById('field-buff-box').innerHTML = this.battle.fieldBuffs.map(b => `[${BUFF_NAMES[b.name] || b.name}]`).join(" ");
            },

            // --- Draft Logic ---
            startDraft() {
                if (this.state.deck.every(x => x !== null)) {
                    return this.showAlert("ì´ë¯¸ ë±ì´ ì™„ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì „íˆ¬ì— ì§„ì…í•˜ì„¸ìš”.");
                }

                if (!this.state.draft) this.state.draft = { active: true, round: 0, rerolls: 3, currentOptions: [] };

                // Find first empty slot
                this.state.draft.round = this.state.deck.indexOf(null);
                if (this.state.draft.round === -1) {
                    this.state.draft.round = 0;
                }

                this.showScreen('screen-draft');
                this.renderDraftScreen();
            },

            renderDraftScreen() {
                const d = this.state.draft;
                const roles = ['ì„ ë´‰', 'ì¤‘ê²¬', 'ëŒ€ì¥'];
                let roundText = roles[d.round] + ` (${d.round + 1}/3)`;
                document.getElementById('draft-round-text').innerText = roundText;
                document.getElementById('draft-reroll-cnt').innerText = d.rerolls;

                if (!d.currentOptions || d.currentOptions.length === 0) {
                    this.generateDraftOptions();
                }

                const grid = document.getElementById('draft-grid');
                grid.innerHTML = "";

                d.currentOptions.forEach(id => {
                    const card = this.getCardData(id);
                    const el = document.createElement('div');
                    let color = '#bdbdbd';
                    if (card.grade === 'legend') color = '#ff5252';
                    else if (card.grade === 'epic') color = '#e040fb';
                    else if (card.grade === 'rare') color = '#448aff';

                    el.className = `card-item ${card.grade}`;
                    el.style.height = "160px";
                    el.style.display = "flex";
                    el.style.flexDirection = "column";
                    el.style.borderColor = color;

                    el.innerHTML = `
                <div style="font-size:0.9rem; font-weight:bold; margin-bottom:5px; color:${color}">${card.name}</div>
                <div class="portrait" style="flex:1; margin-bottom:5px; width:100%;"><img src="${card.name}.png" onerror="this.style.display='none'"></div>
                <div style="display:flex; gap:2px; width:100%;">
                    <button onclick="event.stopPropagation(); RPG.showCardInfo('${card.id}')" style="flex:1; font-size:0.7rem; padding:3px; background:#444; color:#fff; border:1px solid #666;">ìƒì„¸</button>
                    <button onclick="event.stopPropagation(); RPG.selectDraftCard('${card.id}')" style="flex:2; font-size:0.7rem; padding:3px; background:#1b5e20; color:#fff; border:1px solid #4caf50;">ì„ íƒ</button>
                </div>
            `;
                    grid.appendChild(el);
                });
            },

            generateDraftOptions() {
                let pool = GameUtils.buildCardPool(this.global, {
                    includeTranscendence: true,
                    activeTranscendenceCards: this.state.activeTranscendenceCards
                });

                let options = [];
                for (let i = 0; i < 4; i++) {
                    const pick = pool[Math.floor(Math.random() * pool.length)];
                    options.push(pick.id);
                }
                this.state.draft.currentOptions = options;
            },

            selectDraftCard(id) {
                this.state.inventory.push(id);
                this.state.deck[this.state.draft.round] = id;

                // Clear options for next round
                this.state.draft.currentOptions = [];

                if (this.state.deck.indexOf(null) === -1) {
                    this.showAlert("ë± êµ¬ì„± ì™„ë£Œ!");
                    this.toMenu();
                } else {
                    this.startDraft();
                }
            },

            rerollDraft() {
                if (this.state.draft.rerolls > 0) {
                    this.state.draft.rerolls--;
                    this.state.draft.currentOptions = [];
                    this.renderDraftScreen();
                } else {
                    if (this.state.tickets >= GAME_CONSTANTS.COSTS.DRAFT_REROLL_WITH_TICKET) {
                        this.showConfirm(`ë¬´ë£Œ ë¦¬ë¡¤ íšŸìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.<br>í‹°ì¼“ ${GAME_CONSTANTS.COSTS.DRAFT_REROLL_WITH_TICKET}ì¥ì„ ì‚¬ìš©í•˜ì—¬ ë¦¬ë¡¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>(ë³´ìœ  í‹°ì¼“: ${this.state.tickets})`, () => {
                            this.state.tickets -= GAME_CONSTANTS.COSTS.DRAFT_REROLL_WITH_TICKET;
                            document.getElementById('ui-tickets').innerText = this.state.tickets;
                            this.state.draft.currentOptions = [];
                            this.renderDraftScreen();
                        });
                    } else {
                        this.showAlert("ë¦¬ë¡¤ íšŸìˆ˜ì™€ í‹°ì¼“ì´ ëª¨ë‘ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                    }
                }
            },

            resetDraftState() {
                // Called when initializing new draft cycle
                this.state.inventory = [];
                this.state.deck = [null, null, null];
                this.state.draft = { active: true, round: 0, rerolls: GAME_CONSTANTS.DRAFT.INITIAL_REROLLS, currentOptions: [] };
            },

            cleanupTranscendenceCards() {
                if (['draft', 'chaos'].includes(this.state.mode)) return "";

                let removedNames = [];
                this.battle.players.forEach((p, idx) => {
                    if (p && p.proto.grade === 'transcendence') {
                        // Remove from Inventory
                        const invIdx = this.state.inventory.indexOf(p.id);
                        if (invIdx > -1) {
                            this.state.inventory.splice(invIdx, 1);
                        }
                        // Remove from Deck
                        if (this.state.deck[idx] === p.id) {
                            this.state.deck[idx] = null;
                        }
                        removedNames.push(p.name);
                    }
                });

                if (removedNames.length > 0) {
                    const msg = `ì´ˆì›” ì¹´ë“œ ì†Œë©¸: ${removedNames.join(', ')}`;
                    this.log(`<span style="color:#ffd700">[ì‹œìŠ¤í…œ] ${msg}</span>`);
                    return `<br><span style="color:#ffd700">${msg}</span>`;
                }
                return "";
            },

            handlePermadeath(players) {
                let deadNames = [];
                players.forEach(p => {
                    if (p && p.isDead) {
                        let idx = this.state.inventory.indexOf(p.id);
                        if (idx > -1) this.state.inventory.splice(idx, 1);
                        if (p.pos !== undefined) this.state.deck[p.pos] = null;
                        deadNames.push(p.name);
                    }
                });
                if (deadNames.length > 0) return `ì „ì‚¬ì ë°œìƒ: ${deadNames.join(', ')}<br>(ì¹´ë“œê°€ ì†Œë©¸í–ˆìŠµë‹ˆë‹¤)`;
                return "";
            },

            winBattle() {
                let transMsg = this.cleanupTranscendenceCards();
                let deadMsg = this.handlePermadeath(this.battle.players);
                if (transMsg) deadMsg += transMsg;
                let reward = 1;

                // Mode Rewards
                if (this.state.mode === 'suffering') reward = 0;
                if (this.state.mode === 'chaos') reward = 0;

                if (this.battle.players.some(p => p && p.proto.trait.type === 'looter')) reward += 1;
                if (this.state.mode === 'overdrive') reward += 1;

                this.state.tickets += reward;
                this.state.enemyScale++;

                // Reset Chaos Blessing
                this.state.chaosBlessingUses = 3;
                this.state.chaosBuffs = [];
                this.state.activeChaosBlessing = [];
                this.state.activeSageBlessing = [];

                this.log(`ìŠ¹ë¦¬ ë³´ìƒ: ë½‘ê¸°ê¶Œ ${reward}ì¥ íšë“.`);

                // Victory Condition Check
                const mode = this.state.mode;
                const stage = this.state.enemyScale; // current stage (already incremented)
                let clearStage = 24;
                if (['restriction', 'balance', 'archive'].includes(mode)) clearStage = 18;
                if (mode === 'overdrive') clearStage = 30;
                if (mode === 'curse' || mode === 'flood') clearStage = 30;
                if (mode === 'chaos') clearStage = 24;
                if (mode === 'draft') clearStage = 24;
                if (mode === 'artifact') clearStage = 36;
                if (mode === 'origin') clearStage = Infinity;

                if (this.state.gameType === 'endless') clearStage = Infinity;

                let gameClear = false;
                if (stage >= clearStage) {
                    gameClear = true;
                }

                // Chaos/Draft: Reset Deck/Inventory
                if (mode === 'chaos') {
                    this.state.inventory = [];
                    this.state.deck = [null, null, null];

                    let allCards = GameUtils.buildCardPool(this.global);
                    allCards.sort(() => Math.random() - 0.5);

                    const nextPicks = allCards.slice(0, GAME_CONSTANTS.CHAOS_POOL_SIZE).map(c => c.id);
                    this.state.chaosPool = nextPicks;
                    this.state.inventory = [...nextPicks];
                }

                if (mode === 'draft') {
                    this.resetDraftState();
                }

                // Archive Mode: Mandatory Quiz (Direct to finishWinBattle via callback)
                if (mode === 'archive') {
                    let allQuizzes = [];
                    GRAMMAR_DATA.forEach(lec => { allQuizzes = allQuizzes.concat(lec.quizzes); });
                    let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

                    this.startGrammarQuiz(q,
                        () => { // Success
                            this.state.quiz_stats.correct++;
                            this.state.quiz_stats.total++;
                            this.state.tickets++; // Reward Ticket
                            setTimeout(() => this.finishWinBattle(deadMsg, gameClear, true), 200);
                        },
                        () => { // Fail
                            this.state.quiz_stats.total++;
                            setTimeout(() => this.finishWinBattle(deadMsg, gameClear, false), 200);
                        }
                    );
                    return;
                }

                this.finishWinBattle(deadMsg, gameClear, null);
            },

            finishWinBattle(deadMsg, gameClear, quizResult) {
                let msg = "ìŠ¹ë¦¬!<br>ë³´ìƒì„ íšë“í–ˆìŠµë‹ˆë‹¤.";

                if (quizResult !== null) {
                    let correct = this.state.quiz_stats.correct;
                    let total = this.state.quiz_stats.total;
                    let rate = (total > 0) ? ((correct / total) * 100).toFixed(1) : "0.0";
                    let resultMsg = quizResult ? "<span style='color:#4caf50'>ì •ë‹µ!</span>" : "<span style='color:#ef5350'>ì˜¤ë‹µ...</span>";
                    msg = `[í€´ì¦ˆ ê²°ê³¼] ${resultMsg}<br>í˜„í™©: ${correct}/${total} (${rate}%)<hr>` + msg;
                }

                if (this.state.mode === 'chaos') msg += "<br><br>ì¹´ì˜¤ìŠ¤ ëª¨ë“œ: ë±ê³¼ ì¸ë²¤í† ë¦¬ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.";
                if (this.state.mode === 'draft') msg += "<br><br>ë“œë˜í”„íŠ¸ ëª¨ë“œ: ë±ê³¼ ì¸ë²¤í† ë¦¬ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.";

                if (deadMsg) msg += "<br><br>" + deadMsg;

                if (gameClear) {
                    // Check Archive Condition
                    if (this.state.mode === 'archive') {
                        let rate = (this.state.quiz_stats.total > 0) ? (this.state.quiz_stats.correct / this.state.quiz_stats.total) : 0;
                        if (rate < 0.8) {
                            this.showAlert(`[ì‹¤íŒ¨] ì•„ì¹´ì´ë¸Œ ëª¨ë“œ í´ë¦¬ì–´ ì‹¤íŒ¨!<br>ì •ë‹µë¥ : ${(rate * 100).toFixed(1)}% (ëª©í‘œ: 80% ì´ìƒ)`);
                            this.toTitle();
                            return;
                        }
                    }

                    // Transcendence Ticket Logic (On Clear)
                    if (this.state.gameType === 'challenge' || (this.state.mode !== 'origin' && this.checkAllBonusUnlocked())) {
                        this.global.chaosTickets = (this.global.chaosTickets || 0) + 1;
                        this.saveGlobalData();
                        this.log("<b>[ë³´ë„ˆìŠ¤]</b> ì¹´ì˜¤ìŠ¤ í‹°ì¼“ 1ì¥ íšë“!");
                    }

                    // Unlock Mode
                    if (!this.global.unlocked_modes.includes(this.state.mode)) {
                        this.global.unlocked_modes.push(this.state.mode);
                    }
                    this.global.achievements[this.state.mode] = true;

                    // Unlock Bonus Card
                    let newCard = null;
                    let lockedBonus = BONUS_CARDS.filter(c => !this.global.unlocked_bonus_cards.includes(c.id));
                    if (lockedBonus.length > 0) {
                        let pick = lockedBonus[Math.floor(Math.random() * lockedBonus.length)];
                        this.global.unlocked_bonus_cards.push(pick.id);
                        newCard = pick;
                    }

                    this.saveGlobalData();

                    msg = `ğŸ‰ <b>${this.state.mode.toUpperCase()} ëª¨ë“œ í´ë¦¬ì–´!</b> ğŸ‰<br><br>`;
                    if (newCard) msg += `[ë³´ìƒ] ìƒˆë¡œìš´ ë™ë£Œ í•´ê¸ˆ: ${newCard.name}!<br>`;
                    else msg += `(ì´ë¯¸ ëª¨ë“  ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤)<br>`;

                    this.openInfoModal("ê²Œì„ í´ë¦¬ì–´", msg, () => {
                        this.toTitle();
                    });
                    return;
                }

                this.openInfoModal("ì „íˆ¬ ê²°ê³¼", msg, () => {
                    if (this.state.mode !== 'archive') {
                        if (this.state.mode === 'chaos' || this.state.mode === 'draft') {
                            this.showConfirm("ì¶”ê°€ ë³´ìƒì„ ìœ„í•œ ì½œë¡œì¼€ì´ì…˜ í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ë“œë¡œìš°ê¶Œ 1ì¥ íšë“)",
                                () => {
                                    this.startCollocationQuiz((success) => {
                                        if (success) {
                                            this.state.tickets += 1;
                                            document.getElementById('ui-tickets').innerText = this.state.tickets;
                                            this.showAlert("ì •ë‹µ! ë“œë¡œìš°ê¶Œ 1ì¥ì„ ì¶”ê°€ë¡œ íšë“í–ˆìŠµë‹ˆë‹¤.");
                                        } else {
                                            this.showAlert("ì˜¤ë‹µì…ë‹ˆë‹¤... ë³´ìƒ ì—†ìŒ.");
                                        }
                                        this.toMenu();
                                    });
                                },
                                () => {
                                    this.toMenu();
                                }
                            );
                        }
                        else if (this.battle.enemy.id === 'creator_god' && this.state.mode === 'artifact' && (this.state.artifacts || []).length < GAME_CONSTANTS.MAX_ARTIFACTS) {
                            // Artifact Mode: Quiz â†’ Artifact Selection
                            this.showConfirm("ì°½ì¡°ì‹  ê²©íŒŒ ë³´ë„ˆìŠ¤! ë¬¸ë²• í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ì•„í‹°íŒ©íŠ¸ íšë“ ê¸°íšŒ)",
                                () => { // Yes
                                    let allQuizzes = [];
                                    GRAMMAR_DATA.forEach(lec => { allQuizzes = allQuizzes.concat(lec.quizzes); });
                                    let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

                                    this.startGrammarQuiz(q,
                                        () => { // Success - Show artifact selection
                                            this.openArtifactSelect();
                                        },
                                        () => { // Fail
                                            this.showConfirm(`ì˜¤ë‹µì…ë‹ˆë‹¤... ê´€ë ¨ ë¬¸ë²• ê°•ì¢Œ(${q.lecture_id}ê°•)ë¥¼ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,
                                                () => { // Yes
                                                    this.showLecture(q.lecture_id, () => {
                                                        this.toMenu();
                                                    });
                                                },
                                                () => { // No
                                                    this.toMenu();
                                                }
                                            );
                                        }
                                    );
                                },
                                () => { // No
                                    this.toMenu();
                                }
                            );
                        }
                        else if (this.battle.enemy.id === 'creator_god') {
                            this.showConfirm("ì°½ì¡°ì‹  ê²©íŒŒ ë³´ë„ˆìŠ¤! ë¬¸ë²• í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ë½‘ê¸°ê¶Œ 3ì¥ íšë“)",
                                () => { // Yes
                                    let allQuizzes = [];
                                    GRAMMAR_DATA.forEach(lec => { allQuizzes = allQuizzes.concat(lec.quizzes); });
                                    let q = allQuizzes[Math.floor(Math.random() * allQuizzes.length)];

                                    this.startGrammarQuiz(q,
                                        () => { // Success
                                            this.state.tickets += 3;
                                            document.getElementById('ui-tickets').innerText = this.state.tickets;
                                            this.showAlert("ì •ë‹µ! ë“œë¡œìš°ê¶Œ 3ì¥ì„ ì¶”ê°€ë¡œ íšë“í–ˆìŠµë‹ˆë‹¤.");
                                            this.toMenu();
                                        },
                                        () => { // Fail
                                            this.showConfirm(`ì˜¤ë‹µì…ë‹ˆë‹¤... ê´€ë ¨ ë¬¸ë²• ê°•ì¢Œ(${q.lecture_id}ê°•)ë¥¼ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,
                                                () => { // Yes
                                                    this.showLecture(q.lecture_id, () => {
                                                        this.toMenu();
                                                    });
                                                },
                                                () => { // No
                                                    this.toMenu();
                                                }
                                            );
                                        }
                                    );
                                },
                                () => { // No
                                    this.toMenu();
                                }
                            );
                        } else {
                            this.showConfirm("ì¶”ê°€ ë³´ìƒì„ ìœ„í•œ í€´ì¦ˆì— ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì„±ê³µ ì‹œ ë“œë¡œìš°ê¶Œ 1ì¥ íšë“)",
                                () => {
                                    this.startQuiz((success) => {
                                        if (success) {
                                            this.state.tickets += 1;
                                            document.getElementById('ui-tickets').innerText = this.state.tickets;
                                            this.showAlert("ì •ë‹µ! ë“œë¡œìš°ê¶Œ 1ì¥ì„ ì¶”ê°€ë¡œ íšë“í–ˆìŠµë‹ˆë‹¤.");
                                        } else {
                                            this.showAlert("ì˜¤ë‹µì…ë‹ˆë‹¤... ë³´ìƒ ì—†ìŒ.");
                                        }
                                        this.toMenu();
                                    });
                                },
                                () => {
                                    this.toMenu();
                                }
                            );
                        }
                    } else {
                        this.toMenu();
                    }
                });
            },

            loseBattle() {
                let transMsg = this.cleanupTranscendenceCards();
                // No saveRecord here (User request: only on New Game)

                if (['chaos', 'draft'].includes(this.state.mode)) {
                    this.saveRecord();
                }

                if (this.state.mode === 'origin') {
                    this.global.pendingTranscendenceCards = [];
                    this.saveGlobalData();
                }

                if (['chaos', 'draft'].includes(this.state.mode)) {
                    Storage.remove(Storage.keys.SAVE);

                    let msg = "íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤...<br>ì´ ëª¨ë“œëŠ” íŒ¨ë°° ì‹œ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.";
                    this.openInfoModal("Game Over", msg, () => {
                        this.toTitle();
                    });
                    return;
                }

                // Reset Chaos Blessing
                this.state.chaosBlessingUses = 3;
                this.state.chaosBuffs = [];
                this.state.activeChaosBlessing = [];
                this.state.activeSageBlessing = [];

                let deadMsg = this.handlePermadeath(this.battle.players);
                let msg = "íŒ¨ë°°...";
                if (deadMsg) msg += "<br><br>" + deadMsg;
                if (transMsg) msg += transMsg;
                this.openInfoModal("ì „íˆ¬ ê²°ê³¼", msg, () => this.toMenu());
            },

            getEffectiveStats(char, fieldBuffs) {
                return Logic.calculateStats(char, fieldBuffs, this.state.mode, this.state.artifacts || []);
            },

            showBattleStat(side, idx) {
                let char;
                if (side === 'player') char = this.battle.players[idx];
                else char = this.battle.enemy;
                if (!char) return;

                let buffs = Object.keys(char.buffs).map(k => {
                    let name = BUFF_NAMES[k] || k;
                    let val = char.buffs[k];
                    if (val === true) return name;
                    return `${name}(${val})`;
                }).join(', ') || 'ì—†ìŒ';

                const eff = Logic.calculateStats(char, this.battle.fieldBuffs, this.state.mode, this.state.artifacts || []);

                // Use baseStatsWithoutBlessing if available to show Green for blessed stats
                const getBase = (key, fallback) => {
                    if (char.baseStatsWithoutBlessing && char.baseStatsWithoutBlessing[key] !== undefined) return char.baseStatsWithoutBlessing[key];
                    return fallback;
                };

                const colorize = (val, base) => {
                    if (val > base) return `<span style="color:#69f0ae">${val}</span>`;
                    if (val < base) return `<span style="color:#ff5252">${val}</span>`;
                    return `<span style="color:#eee">${val}</span>`;
                };

                let content = `<b>[${char.name}]</b><br>HP: ${char.hp}/${char.maxHp}<br>`;
                if (side === 'player') content += `MP: ${char.mp}<br>`;
                content += `ATK: ${colorize(eff.atk, getBase('atk', char.atk))} / MATK: ${colorize(eff.matk, getBase('matk', char.matk))}<br>`;
                content += `DEF: ${colorize(eff.def, getBase('def', char.def))} / MDEF: ${colorize(eff.mdef, getBase('mdef', char.mdef))}<br>`;
                content += `ì¹˜ëª…íƒ€ìœ¨: ${colorize(eff.crit, (char.baseCrit || 10))}% / íšŒí”¼ìœ¨: ${colorize(eff.evasion, (char.baseEva || 0) + 5)}%<br>`;
                content += `ìƒíƒœ: ${buffs}<br><br>`;

                if (side === 'player') {
                    content += `<b>[ìŠ¤í‚¬]</b><br>`;
                    (char.skills || char.proto.skills).forEach(s => {
                        let multText = s.val ? ` (x${s.val})` : '';
                        content += `- ${s.name}: ${s.desc}${multText}<br>`;
                    });
                } else {
                    content += `<b>[ìŠ¤í‚¬]</b><br>`;
                    char.skills.forEach(s => {
                        let multText = s.val ? ` (x${s.val})` : '';
                        content += `- ${s.name}: ${s.desc}${multText}<br>`;
                    });
                }
                this.openInfoModal(char.name, content);
            },

            showFieldBuffInfo() {
                if (this.battle.fieldBuffs.length === 0) return this.showAlert("í™œì„±í™”ëœ í•„ë“œ ë²„í”„ê°€ ì—†ìŠµë‹ˆë‹¤.");
                const buffInfo = {
                    'sun_bless': 'ë¬¼ê³µ/ë§ˆê³µ +30%, ì¹˜ëª…íƒ€ëŒ€ë¯¸ì§€ +60%',
                    'moon_bless': 'ë§ˆê³µ +30%, íšŒí”¼ìœ¨ +15%',
                    'sanctuary': 'ë§ˆê³µ +30%, ë§ˆë°© +30%',
                    'goddess_descent': 'ë¬¼ê³µ/ë§ˆê³µ +30%, ë°©ì–´/ë§ˆë°© +30%',
                    'earth_bless': 'ë¬¼ê³µ/ë§ˆê³µ +25%',
                    'twinkle_party': 'ë¬¼ê³µ +20%, ì¹˜ëª…íƒ€ìœ¨ +15%',
                    'star_powder': 'ë°©ì–´/ë§ˆë°© +40%',
                    'gale': 'ì¹˜ëª…íƒ€ìœ¨ +20%, íšŒí”¼ìœ¨ +20%',
                    'reaper_realm': 'ì¹˜ëª…íƒ€ìœ¨ +40%, ì¹˜ëª…íƒ€ëŒ€ë¯¸ì§€ +40%'
                };
                let msg = "";
                this.battle.fieldBuffs.forEach(b => {
                    msg += `<b>[${BUFF_NAMES[b.name]}]</b><br>${buffInfo[b.name] || ''}<br><br>`;
                });
                this.openInfoModal("í•„ë“œ ë²„í”„", msg);
            },

            openInfoModal(title, content, onClose = null) {
                document.getElementById('info-title').innerText = title;
                document.getElementById('info-content').innerHTML = content;
                document.getElementById('modal-info').classList.add('active');
                this.tempOnClose = onClose;
            },
            closeInfoModal() {
                document.getElementById('modal-info').classList.remove('active');
                const cb = this.tempOnClose;
                this.tempOnClose = null;
                if (cb) {
                    cb();
                }
            },

            showConfirm(msg, onYes, onNo) {
                document.getElementById('confirm-msg').innerHTML = msg;
                const modal = document.getElementById('modal-confirm');
                const btnYes = document.getElementById('confirm-yes');
                const btnNo = document.getElementById('confirm-no');
                const btnContainer = document.getElementById('confirm-btn-container');

                // Reset button order
                btnContainer.style.flexDirection = 'row';

                btnYes.onclick = () => {
                    modal.classList.remove('active');
                    if (onYes) onYes();
                };
                btnNo.onclick = () => {
                    modal.classList.remove('active');
                    if (onNo) onNo();
                };

                modal.classList.add('active');
            },

            showDoubleConfirm(msg1, msg2, onYes) {
                this.showConfirm(msg1, () => {
                    // Step 1 Yes -> Open Step 2
                    setTimeout(() => {
                        document.getElementById('confirm-msg').innerHTML = msg2;
                        const modal = document.getElementById('modal-confirm');
                        const btnYes = document.getElementById('confirm-yes');
                        const btnNo = document.getElementById('confirm-no');
                        const btnContainer = document.getElementById('confirm-btn-container');

                        // Swap buttons for safety
                        btnContainer.style.flexDirection = 'row-reverse';

                        btnYes.onclick = () => {
                            modal.classList.remove('active');
                            btnContainer.style.flexDirection = 'row'; // Reset
                            if (onYes) onYes();
                        };
                        btnNo.onclick = () => {
                            modal.classList.remove('active');
                            btnContainer.style.flexDirection = 'row'; // Reset
                        };

                        modal.classList.add('active');
                    }, 100);
                });
            },

            // --- Private Tutoring ---
            openApiSettings() {
                document.getElementById('modal-api-settings').classList.add('active');
                const key = Storage.getRaw(Storage.keys.API_KEY);
                if (key) document.getElementById('api-key-input').value = key;
            },

            closePrivateTutoring() {
                document.getElementById('modal-tutoring').classList.remove('active');
                document.getElementById('modal-library').classList.add('active');
            },

            closeMagicClass() {
                document.getElementById('modal-magic-class').classList.remove('active');
                document.getElementById('modal-library').classList.add('active');
            },

            closeWordbook() {
                document.getElementById('modal-wordbook').classList.remove('active');
                document.getElementById('modal-library').classList.add('active');
            },

            openPrivateTutoring() {
                const mode = this.state.mode;
                let list = (mode === 'chaos' || mode === 'draft') ? this.state.wrongCollocations : this.state.wrongWords;

                if (!list || list.length === 0) {
                    let msg = (mode === 'chaos' || mode === 'draft') ? "ì˜¤ë‹µë…¸íŠ¸ì— ë“±ë¡ëœ ìˆ™ì–´/êµ¬ë™ì‚¬ê°€ ì—†ìŠµë‹ˆë‹¤." : "ì˜¤ë‹µë…¸íŠ¸ì— ë“±ë¡ëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.";
                    return this.showAlert(msg);
                }

                document.getElementById('modal-library').classList.remove('active');
                document.getElementById('modal-tutoring').classList.add('active');

                // Reset UI
                document.getElementById('tutoring-content').innerText = "ìˆ˜ì—…ì„ ì‹œì‘í•˜ë ¤ë©´ 'ìˆ˜ì—… ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.";
                document.getElementById('btn-tutoring-quiz').style.display = 'none';
                this.currentTutoringItem = null;
            },

            saveApiKey() {
                const key = document.getElementById('api-key-input').value.trim();
                if (!key) return this.showAlert("API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                Storage.setRaw(Storage.keys.API_KEY, key);
                this.showAlert("API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
            },

            async startTutoringSession() {
                if (this.isApiLoading) return this.showAlert("ì´ì „ ìš”ì²­ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...");

                const key = Storage.getRaw(Storage.keys.API_KEY);
                if (!key) return this.showAlert("ë¨¼ì € API í‚¤ë¥¼ ì €ì¥í•´ì£¼ì„¸ìš”.");

                const mode = this.state.mode;
                const isCollocation = (mode === 'chaos' || mode === 'draft');
                let list = isCollocation ? this.state.wrongCollocations : this.state.wrongWords;

                if (!list || list.length === 0) return this.showAlert("í•™ìŠµí•  ì˜¤ë‹µ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.");

                // Pick Random
                const targetId = list[Math.floor(Math.random() * list.length)];
                let targetData = null;

                if (isCollocation) {
                    targetData = COLLOCATION_DATA.find(c => c.id === targetId);
                } else {
                    targetData = VOCAB_DATA.find(v => v.word === targetId);
                }

                if (!targetData) {
                    // Cleanup invalid data
                    if (isCollocation) {
                        this.state.wrongCollocations = this.state.wrongCollocations.filter(id => id !== targetId);
                        Storage.save(Storage.keys.COLLOCATION, this.state.wrongCollocations);
                    } else {
                        this.state.wrongWords = this.state.wrongWords.filter(w => w !== targetId);
                        Storage.save(Storage.keys.VOCAB, this.state.wrongWords);
                    }
                    return this.startTutoringSession(); // Retry
                }

                this.currentTutoringItem = { data: targetData, type: isCollocation ? 'collocation' : 'vocab' };

                // UI Loading
                this.isApiLoading = true;
                const contentBox = document.getElementById('tutoring-content');
                contentBox.innerHTML = "ë£¨ë¯¸ ì„ ìƒë‹˜ì´ ê°•ì˜ë¥¼ ì¤€ë¹„í•˜ê³  ìˆì–´ìš”...<br>(ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”)";

                try {
                    const text = await GameAPI.getTutoringContent(key, targetData, isCollocation ? 'collocation' : 'vocab');

                    // âœ… ì‘ë‹µ ë„ì°© í›„: ëª¨ë‹¬ì´ ì•„ì§ ì—´ë ¤ìˆëŠ”ì§€ í™•ì¸
                    const tutoringModal = document.getElementById('modal-tutoring');
                    if (!tutoringModal.classList.contains('active')) {
                        console.warn("ê³¼ì™¸ ëª¨ë‹¬ì´ ë‹«í˜€ìˆì–´ ê²°ê³¼ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤.");
                        return; // ì´ë¯¸ ë‹«í˜”ìœ¼ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
                    }

                    // Format simple markdown to HTML tags
                    let formatted = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
                    contentBox.innerHTML = formatted;

                    // Show Quiz Button
                    document.getElementById('btn-tutoring-quiz').style.display = 'block';

                } catch (e) {
                    console.error(e);
                    let msg = e.message || "";
                    let displayMsg = "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
                    if (msg.includes('key') || msg.includes('valid') || msg.includes('400') || msg.includes('403')) {
                        displayMsg = "API í‚¤ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šê±°ë‚˜ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.";
                    } else if (msg.includes('quota') || msg.includes('429')) {
                        displayMsg = "API ì‚¬ìš©ëŸ‰ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.";
                    } else if (msg.includes('safety') || msg.includes('blocked')) {
                        displayMsg = "ì•ˆì „ í•„í„°ì— ì˜í•´ ìƒì„±ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë‹¨ì–´ë¡œ ì‹œë„í•´ì£¼ì„¸ìš”.";
                    } else {
                        displayMsg = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + msg;
                    }
                    contentBox.innerHTML = `<div style="color:#ef5350; font-weight:bold;">${displayMsg}</div><div style="font-size:0.7rem; color:#777; margin-top:5px;">(${msg})</div>`;
                } finally {
                    this.isApiLoading = false;
                }
            },

            startTutoringQuiz() {
                if (!this.currentTutoringItem) return;

                const item = this.currentTutoringItem;
                const data = item.data;

                const onCorrect = () => {
                    // Add to tutored items list (Max 3, FIFO)
                    if (!this.state.tutoredItems) this.state.tutoredItems = [];
                    const itemId = item.type === 'collocation' ? data.id : data.word;
                    this.state.tutoredItems.push(itemId);
                    if (this.state.tutoredItems.length > 3) {
                        this.state.tutoredItems.shift();
                    }

                    if (item.type === 'collocation') {
                        this.state.wrongCollocations = this.state.wrongCollocations.filter(id => id !== data.id);
                        Storage.save(Storage.keys.COLLOCATION, this.state.wrongCollocations);
                    } else {
                        this.state.wrongWords = this.state.wrongWords.filter(w => w !== data.word);
                        Storage.save(Storage.keys.VOCAB, this.state.wrongWords);
                    }
                    document.getElementById('modal-tutoring').classList.remove('active');
                    this.toMenu();

                    // Rumi Surprise Gift Logic
                    this.state.rumiGiftCount = this.state.rumiGiftCount || 0;
                    if (this.state.rumiGiftCount < 3 && Math.random() < 0.3) {
                        this.state.rumiGiftCount++;
                        this.state.tickets = (this.state.tickets || 0) + 1;
                        if (document.getElementById('ui-tickets')) document.getElementById('ui-tickets').innerText = this.state.tickets;

                        this.openInfoModal("ë£¨ë¯¸ì˜ ê¹œì§ ì„ ë¬¼!",
                            `<div style="text-align:center;">
                                <div class="portrait" style="width:120px; height:160px; margin:0 auto 10px auto; border-color:#448af f;">
                                    <img src="ë£¨ë¯¸.png" onerror="this.src=''" alt="Rumi" style="width:100%; height:100%; object-fit:contain;">
                                </div>
                                í˜•ì•„! ê³µë¶€í•˜ëŠë¼ ê³ ìƒí–ˆì–´! (í—¤í—¤)<br>ì´ê±° ì¤„ê²Œ, ë°›ì•„!<br><br>
                                <b style="color:#ffd700; font-size:1.2rem;">[í‹°ì¼“ 1ì¥ íšë“]</b><br>
                                <span style="font-size:0.8rem; color:#aaa;">(ì˜¤ë‹µë…¸íŠ¸ì—ì„œë„ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤)</span>
                            </div>`,
                            () => { this.toMenu(); }
                        );
                    } else {
                        this.showAlert("í•™ìŠµ ì™„ë£Œ! ì˜¤ë‹µë…¸íŠ¸ì—ì„œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
                    }
                };

                const onWrong = () => {
                    // Stay on tutoring modal, user can retry
                };

                const config = QuizEngine.buildTutoringQuiz(item, onCorrect, onWrong);
                config.correctDelay = 1500;
                config.wrongDelay = 2000;
                QuizEngine.show(config);
            },

            // --- Artifact Helpers ---

            hasArtifact(id) {
                return (this.state.artifacts || []).includes(id);
            },

            openArtifactSelect() {
                const owned = this.state.artifacts || [];
                const available = ARTIFACT_LIST.filter(a => !owned.includes(a.id));
                if (available.length === 0) {
                    this.showAlert("íšë“ ê°€ëŠ¥í•œ ì•„í‹°íŒ©íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    this.toMenu();
                    return;
                }

                // Pick 3 random artifacts
                const shuffled = available.sort(() => Math.random() - 0.5);
                const choices = shuffled.slice(0, Math.min(3, shuffled.length));

                const list = document.getElementById('artifact-select-list');
                list.innerHTML = "";

                choices.forEach(art => {
                    const btn = document.createElement('button');
                    btn.className = 'menu-btn';
                    btn.style.borderColor = '#ffd700';
                    btn.style.color = '#ffd700';
                    btn.style.textAlign = 'left';
                    btn.style.padding = '15px';
                    btn.innerHTML = `<b>${art.name}</b><br><span style="font-size:0.8rem; color:#ccc; font-weight:normal;">${art.desc}</span>`;
                    btn.onclick = () => {
                        this.state.artifacts.push(art.id);
                        document.getElementById('modal-artifact-select').classList.remove('active');
                        this.showAlert(`ì•„í‹°íŒ©íŠ¸ íšë“: ${art.name}!\n${art.desc}`);
                        this.saveGame();
                        this.toMenu();
                    };
                    list.appendChild(btn);
                });

                document.getElementById('modal-artifact-select').classList.add('active');
            },

            openArtifactCheck() {
                const owned = this.state.artifacts || [];
                const list = document.getElementById('artifact-check-list');
                if (owned.length === 0) {
                    list.innerHTML = '<div style="color:#aaa; text-align:center;">ë³´ìœ í•œ ì•„í‹°íŒ©íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                } else {
                    list.innerHTML = owned.map(id => {
                        const art = ARTIFACT_LIST.find(a => a.id === id);
                        if (!art) return '';
                        return `<div style="margin-bottom:8px; padding:8px; background:#333; border-radius:5px; border-left: 3px solid #ffd700;">
                            <b style="color:#ffd700;">${art.name}</b><br>
                            <span style="color:#ccc;">${art.desc}</span>
                        </div>`;
                    }).join('');
                }
                document.getElementById('modal-artifact-check').classList.add('active');
            },

            showAlert(msg) {
                this.openInfoModal("ì•Œë¦¼", msg);
            },

            // --- TOEIC Practice ---
            openToeicMenu() {
                document.getElementById('modal-library').classList.remove('active');
                document.getElementById('modal-toeic-menu').classList.add('active');
            },

            resetToeicProgress() {
                this.showDoubleConfirm(
                    "ëª¨ë“  ì‹¤ì „ ì—°ìŠµ ê¸°ë¡ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                    "ì •ë§ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>ì™„ë£Œí•œ ë¬¸ì œ ì„¸íŠ¸ê°€ ë‹¤ì‹œ ë“±ì¥í•˜ê²Œ ë©ë‹ˆë‹¤.",
                    () => {
                        this.state.completedToeicSets = [];
                        this.saveGame();
                        this.showAlert("ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
                    }
                );
            },

            startToeicPractice() {
                if (!this.state.completedToeicSets) this.state.completedToeicSets = [];

                // Filter available sets
                const available = TOEIC_DATA.filter(set =>
                    !this.state.completedToeicSets.includes(set.id) &&
                    set.questions && set.questions.length > 0
                );

                if (available.length === 0) {
                    this.showConfirm(
                        "ëª¨ë“  ë¬¸ì œë¥¼ í•™ìŠµí–ˆìŠµë‹ˆë‹¤!<br>ê¸°ë¡ì„ ì´ˆê¸°í™”í•˜ê³  ë‹¤ì‹œ í•™ìŠµí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                        () => this.resetToeicProgress(),
                        () => { }
                    );
                    return;
                }

                // Pick random set
                const set = available[Math.floor(Math.random() * available.length)];

                // Build expanded question list
                let expandedQuestions = [];
                let expandedShuffled = [];

                // All Parts: single pass (Part 5 also 3 questions only)
                set.questions.forEach(q => {
                    expandedQuestions.push(q);
                    const opts = [...q.options];
                    opts.sort(() => Math.random() - 0.5);
                    expandedShuffled.push(opts);
                });

                // Prepare session
                this.state.currentToeicSession = {
                    set: set,
                    qIndex: 0,
                    expandedQuestions: expandedQuestions,
                    shuffledOptions: expandedShuffled,
                    results: [],
                    viewState: 'hub' // 'hub', 'passage', 'question'
                };

                document.getElementById('modal-toeic-menu').classList.remove('active');
                document.getElementById('modal-toeic-practice').classList.add('active');
                document.getElementById('modal-toeic-practice').classList.remove('is-review');

                this.renderToeicQuestion();
            },

            renderToeicQuestion() {
                const session = this.state.currentToeicSession;
                if (session.isAnswering) return;

                const set = session.set;
                const totalQ = session.expandedQuestions.length;
                const modalEl = document.getElementById('modal-toeic-practice');

                // Update title
                let typeName = "ë¬¸ì œ";
                if (set.type === 'part5') typeName = "íŒŒíŠ¸5 ë¬¸ì œ";
                else if (set.type === 'part6') typeName = "íŒŒíŠ¸6 ë¬¸ì œ";
                else if (set.type === 'part7') typeName = "íŒŒíŠ¸7 ë¬¸ì œ";

                document.getElementById('toeic-title').innerText = `${typeName} (${session.qIndex + 1}/${totalQ})`;

                // Hide all views first
                document.getElementById('toeic-hub').style.display = 'none';
                document.getElementById('toeic-passage-view').style.display = 'none';
                document.getElementById('toeic-question-view').style.display = 'none';
                document.getElementById('toeic-review-hub').style.display = 'none';
                document.getElementById('toeic-explanation-view').style.display = 'none';

                if (set.type === 'part5') {
                    // Part 5: show questions directly (standard quiz layout)
                    modalEl.classList.remove('is-part67');
                    modalEl.classList.add('is-part5');
                    document.getElementById('toeic-q-back-btn').style.display = 'none';
                    this._renderToeicQuestionContent();
                    document.getElementById('toeic-question-view').style.display = 'flex';
                } else {
                    // Part 6/7: show hub
                    modalEl.classList.remove('is-part5');
                    modalEl.classList.add('is-part67');

                    // Fill passage content
                    document.getElementById('toeic-passage-scroll').innerHTML =
                        set.passage ? set.passage.replace(/\n/g, '<br>') : '';

                    // Show hub
                    document.getElementById('toeic-hub').style.display = 'flex';
                }
            },

            _renderToeicQuestionContent() {
                const session = this.state.currentToeicSession;
                const q = session.expandedQuestions[session.qIndex];
                const opts = session.shuffledOptions[session.qIndex];

                document.getElementById('toeic-q-text').innerHTML = q.question.replace(/\n/g, '<br>');
                document.getElementById('toeic-feedback').innerText = "";

                const optContainer = document.getElementById('toeic-options');
                optContainer.innerHTML = "";

                opts.forEach(optText => {
                    const btn = document.createElement('button');
                    btn.className = 'menu-btn';
                    btn.style.textAlign = 'left';
                    btn.style.fontSize = '0.95rem';
                    btn.style.marginBottom = '0';
                    btn.style.padding = '14px';
                    btn.style.width = '100%';
                    btn.innerText = optText;
                    btn.onclick = () => this.checkToeicAnswer(btn, optText, q.answer);
                    optContainer.appendChild(btn);
                });
            },

            showToeicPassage() {
                const session = this.state.currentToeicSession;
                if (!session) return;

                // Check if we are in review mode
                if (['review_hub', 'review_q', 'review_passage', 'review_explanation'].includes(session.viewState)) {
                     session.viewState = 'review_passage';
                } else {
                     session.viewState = 'passage';
                }

                document.getElementById('toeic-hub').style.display = 'none';
                document.getElementById('toeic-review-hub').style.display = 'none'; // Ensure review hub is hidden
                document.getElementById('toeic-question-view').style.display = 'none';
                document.getElementById('toeic-passage-view').style.display = 'flex';

                // Scroll to top
                document.getElementById('toeic-passage-scroll').scrollTop = 0;
            },

            showToeicQuestions() {
                const session = this.state.currentToeicSession;
                if (!session) return;

                session.viewState = 'question';

                document.getElementById('toeic-hub').style.display = 'none';
                document.getElementById('toeic-passage-view').style.display = 'none';

                // Show back button for Part 6/7
                document.getElementById('toeic-q-back-btn').style.display = 'block';

                // Render current question content (preserves progress)
                this._renderToeicQuestionContent();
                document.getElementById('toeic-question-view').style.display = 'flex';
            },

            backToToeicHub() {
                const session = this.state.currentToeicSession;
                if (!session) return;

                document.getElementById('modal-toeic-practice').classList.remove('is-explanation');

                // Handle Review Mode Back
                if (['review_hub', 'review_q', 'review_passage', 'review_explanation'].includes(session.viewState)) {
                    session.viewState = 'review_hub';
                    this.renderToeicReviewHub();
                    return;
                }

                // Normal Practice Mode Back
                session.viewState = 'hub';

                document.getElementById('toeic-passage-view').style.display = 'none';
                document.getElementById('toeic-question-view').style.display = 'none';
                document.getElementById('toeic-explanation-view').style.display = 'none';
                document.getElementById('toeic-hub').style.display = 'flex';

                // Update title to reflect current progress
                const totalQ = session.expandedQuestions.length;
                let typeName = "ë¬¸ì œ";
                if (session.set.type === 'part5') typeName = "íŒŒíŠ¸5 ë¬¸ì œ";
                else if (session.set.type === 'part6') typeName = "íŒŒíŠ¸6 ë¬¸ì œ";
                else if (session.set.type === 'part7') typeName = "íŒŒíŠ¸7 ë¬¸ì œ";
                document.getElementById('toeic-title').innerText = `${typeName} (${session.qIndex + 1}/${totalQ})`;
            },

            checkToeicAnswer(btn, selected, correct) {
                const session = this.state.currentToeicSession;
                const opts = document.getElementById('toeic-options').children;
                for (let c of opts) c.disabled = true;

                // Disable back button during answer animation
                const backBtn = document.getElementById('toeic-q-back-btn');
                if (backBtn) backBtn.style.pointerEvents = 'none';

                session.isAnswering = true;

                const feedback = document.getElementById('toeic-feedback');
                const q = session.expandedQuestions[session.qIndex];

                const isCorrect = (selected === correct);
                session.results.push({
                    id: q.id,
                    question: q.question,
                    isCorrect: isCorrect,
                    userAnswer: selected,
                    correctAnswer: correct
                });

                if (isCorrect) {
                    btn.classList.add('correct');
                    feedback.innerHTML = "<span style='color:#4caf50'>ì •ë‹µ!</span>";
                } else {
                    btn.classList.add('wrong');
                    feedback.innerHTML = `<span style='color:#ef5350'>ì˜¤ë‹µ... ì •ë‹µ: ${correct}</span>`;
                    for (let c of opts) {
                        if (c.innerText === correct) c.classList.add('correct');
                    }
                }

                setTimeout(() => {
                    session.isAnswering = false;

                    // Re-enable back button
                    if (backBtn) backBtn.style.pointerEvents = 'auto';

                    session.qIndex++;
                    const totalQ = session.expandedQuestions.length;

                    if (session.qIndex >= totalQ) {
                        this.finishToeicSession();
                    } else if (session.set.type === 'part5') {
                        // Part 5: go directly to next question
                        this._renderToeicQuestionContent();
                        document.getElementById('toeic-title').innerText =
                            `íŒŒíŠ¸5 ë¬¸ì œ (${session.qIndex + 1}/${totalQ})`;
                    } else {
                        // Part 6/7: go back to hub for next question
                        this.backToToeicHub();
                    }
                }, 2000);
            },

            finishToeicSession() {
                const set = this.state.currentToeicSession.set;

                // Mark complete
                if (!this.state.completedToeicSets.includes(set.id)) {
                    this.state.completedToeicSets.push(set.id);
                }

                // Reset Sage Blessing
                this.state.greatSageBlessingUses = 3;
                if (document.getElementById('sage-uses')) document.getElementById('sage-uses').innerText = 3;

                this.saveGame();

                document.getElementById('modal-toeic-practice').classList.remove('active');

                const results = this.state.currentToeicSession.results || [];
                const correctCount = results.filter(r => r.isCorrect).length;
                const total = results.length;
                const wrongList = results.filter(r => !r.isCorrect);

                let msg = `ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!<br>'${set.title}' í•™ìŠµì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.<br><br>`;
                msg += `ì •ë‹µë¥ : ${correctCount}/${total} (${total > 0 ? ((correctCount / total) * 100).toFixed(0) : 0}%)<br><br>`;

                if (wrongList.length > 0) {
                    msg += `<b>[í‹€ë¦° ë¬¸ì œ]</b><br>`;
                    wrongList.forEach(w => {
                        msg += `- ${w.question.substring(0, 30)}... (ì •ë‹µ: ${w.correctAnswer})<br>`;
                    });
                    msg += `<br>`;
                }

                msg += `<b style="color:#00e676">ëŒ€í˜„ìì˜ ì¶•ë³µ íšŸìˆ˜ê°€ 3íšŒë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤!</b>`;

                // Open Result Modal instead of Info Modal
                document.getElementById('toeic-result-content').innerHTML = msg;
                document.getElementById('modal-toeic-result').classList.add('active');
            },

            openToeicReview() {
                document.getElementById('modal-toeic-result').classList.remove('active');
                const session = this.state.currentToeicSession;
                session.viewState = 'review_hub'; // New state

                document.getElementById('modal-toeic-practice').classList.add('active');
                document.getElementById('modal-toeic-practice').classList.add('is-review');
                this.renderToeicReviewHub();
            },

            renderToeicReviewHub() {
                const session = this.state.currentToeicSession;
                const set = session.set;

                document.getElementById('modal-toeic-practice').classList.remove('is-explanation');

                // Hide other views
                document.getElementById('toeic-hub').style.display = 'none';
                document.getElementById('toeic-passage-view').style.display = 'none';
                document.getElementById('toeic-question-view').style.display = 'none';
                document.getElementById('toeic-explanation-view').style.display = 'none';

                // Show Review Hub
                const hub = document.getElementById('toeic-review-hub');
                hub.innerHTML = '';
                hub.style.display = 'flex';
                hub.style.flexDirection = 'column'; // Vertical list as per request (Part 5 is 5 buttons)

                // Update Title
                let typeName = "ë¬¸ì œ";
                if (set.type === 'part5') typeName = "íŒŒíŠ¸5 ë¬¸ì œ";
                else if (set.type === 'part6') typeName = "íŒŒíŠ¸6 ë¬¸ì œ";
                else if (set.type === 'part7') typeName = "íŒŒíŠ¸7 ë¬¸ì œ";
                // Force simplified title for review, especially Part 5 as requested
                document.getElementById('toeic-title').innerText = `${typeName} (ë¦¬ë·°)`;

                // 1. Passage Button (Part 6/7 only)
                if (set.type !== 'part5' && set.passage) {
                    const btn = document.createElement('button');
                    btn.className = 'toeic-hub-btn';
                    btn.innerText = 'ì§€ë¬¸ ë³´ê¸°';
                    btn.onclick = () => this.showToeicPassage(); // Reuses existing logic, viewState handles back button
                    hub.appendChild(btn);
                }

                // 2. Question Buttons
                session.expandedQuestions.forEach((q, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'toeic-hub-btn';
                    btn.innerText = `ë¬¸ì œ ${idx + 1}`;

                    // Mark if wrong
                    const res = session.results.find(r => r.id === q.id);
                    if (res && !res.isCorrect) {
                        btn.style.borderColor = '#ef5350';
                        btn.style.color = '#ef5350';
                        btn.innerText += ' (ì˜¤ë‹µ)';
                    }

                    btn.onclick = () => this.showToeicReviewQuestion(idx);
                    hub.appendChild(btn);
                });

                // 3. Explanation Button
                const expBtn = document.createElement('button');
                expBtn.className = 'toeic-hub-btn';
                expBtn.style.borderColor = '#ffd700';
                expBtn.style.color = '#ffd700';
                expBtn.innerText = 'í•´ì„¤';
                expBtn.onclick = () => this.showToeicExplanation();
                hub.appendChild(expBtn);

                // 4. Close Button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'toeic-hub-btn';
                closeBtn.style.background = '#444';
                closeBtn.style.borderColor = '#666';
                closeBtn.style.color = '#fff';
                closeBtn.innerText = 'ë‹«ê¸°';
                closeBtn.onclick = () => {
                    document.getElementById('modal-toeic-practice').classList.remove('active');
                    this.toMenu();
                };
                hub.appendChild(closeBtn);
            },

            showToeicReviewQuestion(idx) {
                const session = this.state.currentToeicSession;
                session.viewState = 'review_q';

                document.getElementById('toeic-review-hub').style.display = 'none';

                const q = session.expandedQuestions[idx];
                const res = session.results.find(r => r.id === q.id);

                // Render Question (Read Only)
                document.getElementById('toeic-q-text').innerHTML = q.question.replace(/\n/g, '<br>');
                const feedback = document.getElementById('toeic-feedback');

                if (res && res.isCorrect) {
                     feedback.innerHTML = "<span style='color:#4caf50'>ì •ë‹µ!</span>";
                } else {
                     feedback.innerHTML = `<span style='color:#ef5350'>ì˜¤ë‹µ... (ì„ íƒ: ${res ? res.userAnswer : 'ì—†ìŒ'})</span>`;
                }

                const optContainer = document.getElementById('toeic-options');
                optContainer.innerHTML = "";

                // In review, we might want to show options in original order or stored shuffled order?
                // Stored shuffled order is better to match user experience.
                const opts = session.shuffledOptions[idx];

                opts.forEach(optText => {
                    const btn = document.createElement('button');
                    btn.className = 'menu-btn';
                    btn.style.textAlign = 'left';
                    btn.style.fontSize = '0.95rem';
                    btn.style.marginBottom = '0';
                    btn.style.padding = '14px';
                    btn.style.width = '100%';
                    btn.innerText = optText;
                    btn.disabled = true; // Read only

                    if (optText === q.answer) {
                        btn.classList.add('correct');
                    } else if (res && res.userAnswer === optText && !res.isCorrect) {
                        btn.classList.add('wrong');
                    }

                    optContainer.appendChild(btn);
                });

                // Show Back Button
                const backBtn = document.getElementById('toeic-q-back-btn');
                backBtn.style.display = 'block';
                backBtn.style.pointerEvents = 'auto';

                document.getElementById('toeic-question-view').style.display = 'flex';
            },

            showToeicExplanation() {
                 const session = this.state.currentToeicSession;
                 session.viewState = 'review_explanation';

                 document.getElementById('modal-toeic-practice').classList.add('is-explanation');
                 document.getElementById('toeic-review-hub').style.display = 'none';

                 const set = session.set;
                 const expText = (typeof TOEIC_EXPLANATIONS !== 'undefined' && TOEIC_EXPLANATIONS[set.id])
                                 ? TOEIC_EXPLANATIONS[set.id]
                                 : "í•´ì„¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.";

                 document.getElementById('toeic-explanation-scroll').innerHTML = expText.replace(/\n/g, '<br>');
                 document.getElementById('toeic-explanation-view').style.display = 'flex';
            },
        };

        // Use DOMContentLoaded instead of 'load' to avoid being blocked by
        // missing image resources (e.g., ë£¨ë¯¸.png). DOMContentLoaded fires after
        // HTML parsing and deferred scripts complete, but before images load.
        document.addEventListener('DOMContentLoaded', () => {
            RPG.waitForInitialDataLoad();
        });
    </script>
</body>

</html>
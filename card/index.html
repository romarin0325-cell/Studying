<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Card RPG</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<style>
    body { background-color: #121212; color: #e0e0e0; font-family: 'Noto Sans KR', sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; user-select: none; }
    .header { padding: 10px; text-align: center; background: #1f1f1f; border-bottom: 1px solid #333; font-size: 0.95rem; color: #bbb; font-weight: bold; flex-shrink: 0; }
    .container { flex: 1; display: flex; flex-direction: column; padding: 8px; overflow: hidden; gap: 8px; }
    .screen { display: none; flex-direction: column; height: 100%; }
    .screen.active { display: flex; }
    .menu-btn { background: #333; border: 1px solid #555; color: #eee; padding: 15px; border-radius: 8px; font-size: 1rem; cursor: pointer; margin-bottom: 10px; width: 100%; text-align: center; }
    .menu-btn:active { background: #555; transform: scale(0.98); }
    .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; overflow-y: auto; padding: 5px; flex: 1; }
    .card-item { background: #222; border: 2px solid #444; border-radius: 5px; padding: 5px; text-align: center; font-size: 0.8rem; cursor: pointer; position: relative; }
    .card-item.selected { border-color: #ffd700; box-shadow: 0 0 5px #ffd700; }
    .card-item.legend { border-color: #ff5252; color: #ff5252; }
    .card-item.epic { border-color: #e040fb; color: #e040fb; }
    .card-item.rare { border-color: #448aff; color: #448aff; }
    .card-item.normal { border-color: #bdbdbd; color: #bdbdbd; }

    .portrait {
        width: 100%; aspect-ratio: 3/4;
        border-radius: 6px;
        background: #000;
        border: 2px solid #555;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        margin-bottom: 3px;
    }
    .portrait img { width: 100%; height: 100%; object-fit: contain; }

    .battle-header { display: flex; justify-content: space-between; padding: 5px; background: #222; border-radius: 5px; font-size: 0.8rem; }
    .field-buffs { height: 20px; font-size: 0.7rem; color: #81d4fa; text-align: center; overflow: hidden; white-space: nowrap; cursor: pointer; }

    .visual-stage {
        flex: 1; position: relative;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 6px;
        display: flex; justify-content: space-around; align-items: center;
        padding: 5px;
        background-image: linear-gradient(to bottom, #2a2a2a, #121212);
        min-height: 200px;
        max-height: 40vh;
    }

    .battle-actor {
        width: 120px;
        text-align: center;
        position: relative;
        transition: all 0.2s;
        display: flex; flex-direction: column; align-items: center;
        cursor: pointer;
    }
    .battle-actor .portrait {
        width: 90px; height: 120px;
        border-color: #999;
    }
    .battle-actor.player .portrait { border-color: #4caf50; }
    .battle-actor.enemy .portrait { border-color: #ff5252; }
    .battle-actor.turn { transform: scale(1.05); z-index: 10; }
    .battle-actor.dead { opacity: 0.3; filter: grayscale(100%); }

    .actor-hp-bar { width: 100%; height: 6px; background: #333; margin-top: 4px; border-radius: 3px; overflow: hidden; }
    .actor-hp-fill { height: 100%; background: #ef5350; width: 100%; transition: width 0.3s; }
    .actor-mp-bar { width: 100%; height: 4px; background: #333; margin-top: 2px; border-radius: 2px; overflow: hidden; }
    .actor-mp-fill { height: 100%; background: #42a5f5; width: 100%; transition: width 0.3s; }
    .actor-buffs { font-size: 0.6rem; color: #ffd700; height: 12px; overflow: hidden; margin-top: 2px; }

    .log-container { height: 150px; background: #1a1a1a; border: 1px solid #333; border-radius: 5px; padding: 5px; overflow-y: auto; font-size: 0.75rem; margin-bottom: 5px; }
    .log-line { margin-bottom: 2px; border-bottom: 1px solid #252525; }
    .log-dmg { color: #ff5252; } .log-heal { color: #69f0ae; } .log-info { color: #4fc3f7; }

    .control-panel { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; height: 110px; margin-bottom: 60px; }
    .skill-btn { background: #333; border: 1px solid #555; color: #fff; border-radius: 5px; font-size: 0.8rem; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 5px; }
    .skill-btn:disabled { opacity: 0.5; background: #222; }
    .skill-btn span { pointer-events: none; }
    .skill-btn.phy { border-color: #9c27b0; color: #e1bee7; }
    .skill-btn.mag { border-color: #2196f3; color: #bbdefb; }
    .skill-btn.sup { border-color: #4caf50; color: #c8e6c9; }

    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
    .modal.active { display: flex; }
    .modal-content {
        background: #222; padding: 20px; border-radius: 12px; border: 1px solid #444;
        width: 320px; max-height: 80vh;
        display: flex; flex-direction: column;
        text-align: center;
        color: #e0e0e0;
    }
    .modal-scroll { flex: 1; overflow-y: auto; margin-bottom: 10px; }

    .deck-slot { width: 100%; height: 50px; background: #333; margin-bottom: 5px; border: 1px dashed #555; display: flex; align-items: center; justify-content: center; cursor: pointer; }
    .deck-slot.filled { border: 1px solid #4caf50; background: #1b5e20; }
</style>
</head>
<body>
<div class="header">Card RPG</div>
<div class="container">
    <div id="screen-title" class="screen active" style="justify-content: center; align-items: center;">
        <h1 style="color:#ffd700;">Card RPG</h1>
        <button class="menu-btn" onclick="startGame('new')">ìƒˆë¡œí•˜ê¸°</button>
        <button class="menu-btn" onclick="startGame('load')">ì´ì–´í•˜ê¸°</button>
    </div>
    <div id="screen-menu" class="screen">
        <div style="text-align:center; padding: 10px;">ë³´ìœ  í‹°ì¼“: <span id="ui-tickets" style="color:#ffd700">0</span>ì¥</div>
        <button class="menu-btn" onclick="openGacha()">ì¹´ë“œ ë½‘ê¸° (1ì¥ ì†Œëª¨)</button>
        <button class="menu-btn" onclick="openDeck()">ë± êµ¬ì„±</button>
        <button class="menu-btn" onclick="openCollection()">ì¹´ë“œ í™•ì¸</button>
        <button class="menu-btn" onclick="startBattleInit()" style="background:#b71c1c; border-color:#f44336;">ì „íˆ¬ ì§„ì…</button>
        <button class="menu-btn" onclick="saveGame()">ì €ì¥</button>
        <button class="menu-btn" onclick="toTitle()">íƒ€ì´í‹€ë¡œ</button>
    </div>
    <div id="screen-collection" class="screen">
        <div style="display:flex; justify-content:space-between; align-items:center;"><h3>ì¹´ë“œ ëª©ë¡</h3><button onclick="toMenu()" style="padding:5px;">ë’¤ë¡œ</button></div>
        <div id="collection-grid" class="card-grid"></div>
    </div>
    <div id="screen-deck" class="screen">
        <h3>ë± êµ¬ì„±</h3>
        <div style="margin-bottom:10px;">
            <div id="slot-0" class="deck-slot" onclick="selectDeckSlot(0)">ì„ ë´‰ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
            <div id="slot-1" class="deck-slot" onclick="selectDeckSlot(1)">ì¤‘ê²¬ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
            <div id="slot-2" class="deck-slot" onclick="selectDeckSlot(2)">ëŒ€ì¥ (í´ë¦­í•˜ì—¬ ì„ íƒ)</div>
        </div>
        <div style="flex:1; overflow-y:auto; border-top:1px solid #333;"><div id="deck-card-list" class="card-grid"></div></div>
        <button class="menu-btn" onclick="confirmDeck()" style="margin-bottom: 60px;">í™•ì¸</button>
    </div>
    <div id="screen-battle" class="screen">
        <div class="battle-header"><span>Turn: <span id="bt-turn">1</span></span><div id="field-buff-box" class="field-buffs" onclick="showFieldBuffInfo()"></div></div>
        <div class="visual-stage">
            <div id="player-actor-box" class="battle-actor player" onclick="showBattleStat('player', battleState.currentPlayerIdx)">
                <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="p-name">Player</div>
                <div class="portrait"><img id="p-img" src="" onerror="this.style.display='none'"></div>
                <div class="actor-hp-bar"><div id="p-hp-bar" class="actor-hp-fill"></div></div>
                <div class="actor-mp-bar"><div id="p-mp-bar" class="actor-mp-fill"></div></div>
                <div id="p-buffs" class="actor-buffs"></div>
            </div>

            <div style="color:#555; font-size:1.5rem; font-weight:bold;">VS</div>

            <div id="enemy-actor-box" class="battle-actor enemy" onclick="showBattleStat('enemy', 0)">
                <div style="font-size:0.7rem; color:#ccc; margin-bottom:2px;" id="e-name">Enemy</div>
                <div class="portrait"><img id="e-img" src="" onerror="this.style.display='none'"></div>
                <div class="actor-hp-bar"><div id="e-hp-bar" class="actor-hp-fill"></div></div>
                <div id="e-buffs" class="actor-buffs"></div>
            </div>
        </div>
        <div id="battle-log" class="log-container"></div>
        <div id="battle-controls" class="control-panel"></div>
    </div>
</div>

<div id="modal-card" class="modal">
    <div class="modal-content">
        <h3 id="md-name">Name</h3>
        <div class="modal-scroll">
            <div class="portrait" style="width:150px; height:200px; margin:0 auto;"><img id="md-img" src="" style="width:100%; height:100%; object-fit:contain;"></div>
            <p id="md-grade" style="font-size:0.8rem; margin:5px 0;">Grade</p>
            <div id="md-stats" style="font-size:0.8rem; text-align:left; background:#333; padding:5px; margin:5px 0;"></div>
            <div id="md-skills" style="font-size:0.8rem; text-align:left;"></div>
        </div>
        <button onclick="closeModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-info" class="modal">
    <div class="modal-content" style="height:auto;">
        <h3 id="info-title">ì •ë³´</h3>
        <div id="info-content" class="modal-scroll" style="text-align:left; font-size:0.85rem; line-height:1.4;"></div>
        <button onclick="closeInfoModal()" style="margin-top:10px; width:100%; padding:10px;">ë‹«ê¸°</button>
    </div>
</div>

<div id="modal-gacha" class="modal">
    <div class="modal-content" style="height:auto; min-height:300px;">
        <h2 id="gacha-title">íšë“!</h2>
        <div id="gacha-result"></div>
        <button onclick="closeGachaModal()" style="margin-top:10px; width:100%; padding:10px;">í™•ì¸</button>
    </div>
</div>
<script src="data.js"></script>
<script>
    let gameState = { tickets: 20, inventory: [], deck: [null, null, null], enemyScale: 0 };
    let battleState = { turn: 1, players: [], enemy: null, fieldBuffs: [], currentPlayerIdx: 0, phase: 'start', delayedEffects: [] };
    let selectedSlot = -1;

    const NORMAL_ATTACK = { name: 'ì¼ë°˜ ê³µê²©', type: 'phy', tier: 1, cost: 0, val: 1.0, desc: 'ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©' };

    function startGame(mode) {
        if(mode === 'load') {
            const save = localStorage.getItem('cardRpgSave');
            if(save) {
                 let loaded = JSON.parse(save);
                 gameState = { ...gameState, ...loaded };
                 alert("ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ");
            } else { alert("ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤."); initNewGame(); }
        } else { initNewGame(); }
        toMenu();
    }
    function initNewGame() { gameState = { tickets: 20, inventory: [], deck: [null, null, null], enemyScale: 0 }; }
    function toMenu() { showScreen('screen-menu'); document.getElementById('ui-tickets').innerText = gameState.tickets; }
    function toTitle() { showScreen('screen-title'); }
    function showScreen(id) { document.querySelectorAll('.screen').forEach(el => el.classList.remove('active')); document.getElementById(id).classList.add('active'); }
    function saveGame() { localStorage.setItem('cardRpgSave', JSON.stringify(gameState)); alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."); }

    function openGacha() {
        if(gameState.tickets < 1) return alert("í‹°ì¼“ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
        gameState.tickets--;
        document.getElementById('ui-tickets').innerText = gameState.tickets;
        let rand = Math.random(), grade = 'normal';
        if(rand < 0.10) grade = 'legend'; else if(rand < 0.30) grade = 'epic'; else if(rand < 0.60) grade = 'rare';
        const pool = CARDS.filter(c => c.grade === grade);
        const pick = pool[Math.floor(Math.random() * pool.length)];
        gameState.inventory.push(pick.id);
        const modal = document.getElementById('modal-gacha');
        const content = document.getElementById('gacha-result');
        let color = '#bdbdbd', title = "íšë“!";
        if(grade === 'legend') { color = '#ff5252'; title = "ğŸ‰ ëŒ€ë°•! ì „ì„¤ ì¹´ë“œ! ğŸ‰"; }
        else if(grade === 'epic') { color = '#e040fb'; title = "âœ¨ ì—í”½ ì¹´ë“œ! âœ¨"; }
        document.getElementById('gacha-title').innerText = title;
        content.innerHTML = `<div style="color:${color}; font-size:1.2rem; font-weight:bold; margin-bottom:10px;">[${pick.grade.toUpperCase()}] ${pick.name}</div>
            <div class="portrait" style="width:120px; height:160px; margin:0 auto;"><img src="${pick.name}.png" onerror="this.style.display='none'"></div><p>ìƒˆë¡œìš´ ë™ë£Œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤!</p>`;
        modal.classList.add('active');
    }
    function closeGachaModal() { document.getElementById('modal-gacha').classList.remove('active'); }

    function openCollection() { showScreen('screen-collection'); renderCardList('collection-grid', gameState.inventory, (id) => showCardInfo(id)); }
    function renderCardList(containerId, list, clickHandler) {
        const box = document.getElementById(containerId);
        box.innerHTML = "";
        let counts = {};
        list.forEach(id => { counts[id] = (counts[id] || 0) + 1; });
        for(let id in counts) {
            const data = CARDS.find(c => c.id === id);
            if(!data) continue;
            const el = document.createElement('div');
            el.className = `card-item ${data.grade}`;
            el.innerHTML = `<div class="portrait"><img src="${data.name}.png" onerror="this.style.display='none'"></div><div>${data.name} (x${counts[id]})</div>`;
            el.onclick = () => clickHandler(id);
            box.appendChild(el);
        }
    }
    function showCardInfo(id) {
        const data = CARDS.find(c => c.id === id);
        if(!data) return;
        document.getElementById('md-name').innerText = data.name;
        document.getElementById('md-img').src = `${data.name}.png`;
        document.getElementById('md-grade').className = data.grade;
        document.getElementById('md-grade').innerText = `${data.grade.toUpperCase()} / ${data.role} / ${data.element}`;
        document.getElementById('md-stats').innerHTML = `HP:${data.stats.hp} ATK:${data.stats.atk} MATK:${data.stats.matk}<br>DEF:${data.stats.def} MDEF:${data.stats.mdef}`;
        let skills = `<p style="color:#ffd700; margin:5px 0;">[íŠ¹ì„±] ${data.trait.desc}</p>`;
        skills += `<p style="margin:2px 0;">[ì¼ë°˜ ê³µê²©] (Tier 1) ê¸°ë³¸ ë¬¼ë¦¬ ê³µê²©</p>`;
        data.skills.forEach(s => {
            let multText = s.val ? ` (x${s.val})` : '';
            skills += `<p style="margin:2px 0;">[${s.name}] (Tier ${s.tier}, MP:${s.cost}) ${s.desc}${multText}</p>`;
        });
        document.getElementById('md-skills').innerHTML = skills;
        document.getElementById('modal-card').classList.add('active');
    }
    function closeModal() { document.getElementById('modal-card').classList.remove('active'); }

    function openDeck() {
        showScreen('screen-deck');
        updateDeckSlots();
        selectedSlot = -1;
        renderCardList('deck-card-list', gameState.inventory, (id) => {
            if(selectedSlot === -1) selectedSlot = gameState.deck.indexOf(null);
            if(selectedSlot === -1) return alert("ìŠ¬ë¡¯ì„ ë¨¼ì € ì„ íƒí•˜ê±°ë‚˜ ë¹ˆ ìŠ¬ë¡¯ì´ ì—†ìŠµë‹ˆë‹¤.");
            let total = gameState.inventory.filter(x => x === id).length;
            let used = gameState.deck.filter(x => x === id).length;
            if(gameState.deck[selectedSlot] === id) used--;
            if(total - used <= 0) return alert("ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            gameState.deck[selectedSlot] = id;
            updateDeckSlots();
        });
    }
    function selectDeckSlot(idx) { selectedSlot = idx; document.querySelectorAll('.deck-slot').forEach((el, i) => { el.style.borderColor = i === idx ? '#ffd700' : '#555'; }); }
    function updateDeckSlots() {
        ['ì„ ë´‰', 'ì¤‘ê²¬', 'ëŒ€ì¥'].forEach((role, i) => {
            const id = gameState.deck[i];
            const el = document.getElementById(`slot-${i}`);
            if(id) { const c = CARDS.find(x => x.id === id); el.innerText = `${role}: ${c.name}`; el.classList.add('filled'); }
            else { el.innerText = `${role} (ë¹„ì–´ìˆìŒ)`; el.classList.remove('filled'); }
        });
    }
    function confirmDeck() { if(gameState.deck.every(x => x === null)) return alert("ìµœì†Œ 1ì¥ì˜ ì¹´ë“œëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤."); toMenu(); }

    function startBattleInit() {
        if(gameState.deck.every(x => x === null)) return alert("ë±ì„ ì™„ì„±í•´ì£¼ì„¸ìš”.");
        showScreen('screen-battle');
        const enemyIdx = gameState.enemyScale % ENEMIES.length;
        const baseEnemy = ENEMIES[enemyIdx];
        let cycle = Math.floor(gameState.enemyScale / ENEMIES.length);
        let scale = 1.0 + (cycle * 0.2);

        battleState.enemy = {
            id: baseEnemy.id, name: baseEnemy.name,
            maxHp: Math.floor(baseEnemy.stats.hp * scale), hp: Math.floor(baseEnemy.stats.hp * scale),
            atk: Math.floor(baseEnemy.stats.atk * scale), matk: Math.floor(baseEnemy.stats.matk * scale),
            def: Math.floor(baseEnemy.stats.def * scale), mdef: Math.floor(baseEnemy.stats.mdef * scale),
            baseDef: Math.floor(baseEnemy.stats.def * scale), baseMdef: Math.floor(baseEnemy.stats.mdef * scale),
            skills: baseEnemy.skills, buffs: {}, element: baseEnemy.element,
            tookDamageThisTurn: false, lastHitType: null
        };
        if(baseEnemy.id === 'creator_god') battleState.enemy.chargeTurn = 0;

        battleState.players = gameState.deck.map((id, idx) => {
            if(!id) return null;
            const proto = CARDS.find(c => c.id === id);
            let p = { id: proto.id, proto: proto, name: proto.name, maxHp: proto.stats.hp, hp: proto.stats.hp, mp: 100, atk: proto.stats.atk, matk: proto.stats.matk, def: proto.stats.def, mdef: proto.stats.mdef, buffs: {}, pos: idx, isDead: false, baseCrit: 10 };
            if(proto.trait.type.startsWith('pos_')) {
                const t = proto.trait;
                let active = (t.type.includes('van') && idx===0) || (t.type.includes('mid') && idx===1) || (t.type.includes('rear') && idx===2);
                if(active) {
                    if(t.type.includes('atk')) p.atk = Math.floor(p.atk * (1 + t.val/100));
                    if(t.type.includes('matk')) p.matk = Math.floor(p.matk * (1 + t.val/100));
                    if(t.type.includes('def')) p.def = Math.floor(p.def * (1 + t.val/100));
                    if(t.type.includes('mdef')) p.mdef = Math.floor(p.mdef * (1 + t.val/100));
                }
            }
            return p;
        });
        const activePlayers = battleState.players.filter(p => p !== null);
        const elements = activePlayers.map(p => p.proto.element);

        activePlayers.forEach(p => {
             if(p.proto.trait.type.startsWith('syn_')) {
                 const t = p.proto.trait;
                 if(t.type === 'syn_nature_3_def' && elements.filter(e=>e==='nature').length===3) p.def = Math.floor(p.def * 1.5);
                 if(t.type === 'syn_water_3_atk' && elements.filter(e=>e==='water').length===3) p.atk = Math.floor(p.atk * 1.5);
                 if(t.type === 'syn_fire_3_crit' && elements.filter(e=>e==='fire').length===3) p.baseCrit += 20;
                 if(t.type === 'syn_dark_3_matk' && elements.filter(e=>e==='dark').length===3) p.matk = Math.floor(p.matk * 1.5);
                 if(t.type === 'syn_light_fire_atk' && elements.includes('light') && elements.includes('fire')) p.atk = Math.floor(p.atk * 1.2);
                 if(t.type === 'syn_water_light_mdef' && elements.includes('water') && elements.includes('light')) p.mdef = Math.floor(p.mdef * 1.5);
             }
        });
        battleState.fieldBuffs = [];
        battleState.delayedEffects = [];
        battleState.turn = 1;
        battleState.currentPlayerIdx = 0;

        while(battleState.currentPlayerIdx < 3 && battleState.players[battleState.currentPlayerIdx] === null) {
            battleState.currentPlayerIdx++;
        }

        document.getElementById('battle-log').innerHTML = "";
        log(`ì „íˆ¬ ê°œì‹œ! ì : ${battleState.enemy.name}`);
        renderBattlefield();
        startPlayerTurn();
    }
    function log(msg, type='info') { const box = document.getElementById('battle-log'); const div = document.createElement('div'); div.className = `log-line log-${type}`; div.innerHTML = msg; box.appendChild(div); box.scrollTop = box.scrollHeight; }

    function getBuffNameKR(key) {
        const map = {
            'darkness': 'ì•”í‘', 'corrosion': 'ë¶€ì‹', 'silence': 'ì¹¨ë¬µ', 'curse': 'ì €ì£¼', 'weak': 'ì•½í™”',
            'burn': 'ì‘ì—´', 'divine': 'ë””ë°”ì¸', 'stun': 'ê¸°ì ˆ', 'evasion': 'íšŒí”¼', 'barrier': 'ë°°ë¦¬ì–´',
            'magic_guard': 'ë§¤ì§ê°€ë“œ', 'guard': 'ê°€ë“œ',
            'defProtocolPhy': 'ë°©ì–´í”„ë¡œí† ì½œ(ë¬¼ë¦¬)', 'defProtocolMag': 'ë°©ì–´í”„ë¡œí† ì½œ(ë§ˆë²•)'
        };
        return map[key] || key;
    }

    function renderBattlefield() {
        const p = battleState.players[battleState.currentPlayerIdx];

        if(p && !p.isDead) {
            document.getElementById('p-name').innerText = p.name;
            const pImg = document.getElementById('p-img');
            pImg.src = `${p.name}.png`;
            pImg.style.display = 'block';

            let hpPct = (p.hp / p.maxHp) * 100;
            document.getElementById('p-hp-bar').style.width = `${Math.max(0, hpPct)}%`;
            let mpPct = (p.mp / 100) * 100;
            document.getElementById('p-mp-bar').style.width = `${Math.max(0, mpPct)}%`;

            let buffTxt = Object.keys(p.buffs).map(k=>getBuffNameKR(k)).join(',');
            document.getElementById('p-buffs').innerText = buffTxt;
            document.getElementById('player-actor-box').style.opacity = 1;
        } else {
             document.getElementById('player-actor-box').style.opacity = 0;
        }

        const e = battleState.enemy;
        let eHpPct = (e.hp / e.maxHp) * 100;
        document.getElementById('e-hp-bar').style.width = `${Math.max(0, eHpPct)}%`;
        document.getElementById('e-name').innerText = e.name;
        const eImg = document.getElementById('e-img');
        eImg.src = `${e.name}.png`;
        eImg.style.display = 'block';

        let eBuffTxt = Object.keys(e.buffs).map(k=>`${getBuffNameKR(k)}${e.buffs[k]>1?e.buffs[k]:''}`).join(' ');
        document.getElementById('e-buffs').innerText = eBuffTxt;

        document.getElementById('bt-turn').innerText = battleState.turn;
        document.getElementById('field-buff-box').innerHTML = battleState.fieldBuffs.map(b => `[${b.name}]`).join(" ");
    }

    function startPlayerTurn() {
        if(battleState.currentPlayerIdx >= 3) { loseBattle(); return; }

        if(battleState.currentPlayerIdx === 0) {
             log(`=== ${battleState.turn}í„´ ===`, 'info');
        }

        // Reset enemy lastHitType at the start of player turn to ensure logic works per turn
        if(battleState.enemy) battleState.enemy.lastHitType = null;

        let p = battleState.players[battleState.currentPlayerIdx];

        if(!p || p.isDead) {
            battleState.currentPlayerIdx++;
            startPlayerTurn();
            return;
        }

        for(let i = battleState.delayedEffects.length - 1; i >= 0; i--) {
            let effect = battleState.delayedEffects[i];
            if(effect.turn === battleState.turn) {
                battleState.delayedEffects.splice(i, 1);
                if(effect.source.isDead) {
                    log(`${effect.skill.name} ë°œë™ ì‹¤íŒ¨... (ì‹œì „ì ì‚¬ë§)`);
                } else {
                    log(`${effect.skill.name} ë°œë™!`);
                    executeSkillDamage(effect.source, effect.skill, true);
                }
            }
        }

        if(p.buffs.evasion) delete p.buffs.evasion;
        if(p.buffs.barrier) delete p.buffs.barrier;
        if(p.buffs.magic_guard) delete p.buffs.magic_guard;
        if(p.buffs.guard) delete p.buffs.guard;

        renderBattlefield();

        if(p.buffs.stun) {
            log(`${p.name} ê¸°ì ˆë¡œ ì¸í•´ í–‰ë™ ë¶ˆê°€.`);
            delete p.buffs.stun;
            setTimeout(startEnemyTurn, 500);
            return;
        }

        setupControls(p);
    }

    function setupControls(p) {
        const panel = document.getElementById('battle-controls');
        panel.innerHTML = "";

        const btn = document.createElement('button');
        btn.className = 'skill-btn phy';
        btn.innerHTML = `<span>ì¼ë°˜ê³µê²©</span><span style="color:#aaa">MP 0</span>`;
        btn.onclick = () => executeSkill(p, NORMAL_ATTACK);
        panel.appendChild(btn);

        p.proto.skills.forEach(s => {
            const btn = document.createElement('button');
            btn.className = `skill-btn ${s.type}`;
            btn.innerHTML = `<span>${s.name}</span><span style="color:#aaa">MP ${s.cost}</span>`;
            if(p.mp < s.cost) btn.disabled = true;
            else btn.onclick = () => executeSkill(p, s);
            panel.appendChild(btn);
        });
    }

    function getElementalMultiplier(atkEl, defEl) {
        if(atkEl === 'water' && defEl === 'fire') return 1.2;
        if(atkEl === 'fire' && defEl === 'nature') return 1.2;
        if(atkEl === 'nature' && defEl === 'water') return 1.2;
        if((atkEl === 'light' && defEl === 'dark') || (atkEl === 'dark' && defEl === 'light')) return 1.2;
        return 1.0;
    }

    function executeSkill(p, skill) {
        p.mp -= skill.cost;
        log(`<b>${p.name}</b>ì˜ <b>${skill.name}</b>!`);

        if(skill.desc.includes('3í„´ ë’¤')) {
            log(`ì¢…ì–¸ì˜ ì˜ˆê³ ê°€ ì‹œì‘ë©ë‹ˆë‹¤... (3í„´ ë’¤ ë°œë™)`);
            battleState.delayedEffects.push({ turn: battleState.turn + 3, source: p, skill: skill });
            setTimeout(startEnemyTurn, 500);
            return;
        }

        executeSkillDamage(p, skill);
    }

    function executeSkillDamage(p, skill, isDelayed=false) {
        let atkMult = 1.0, matkMult = 1.0, crit = p.baseCrit, critDmg = 150;
        battleState.fieldBuffs.forEach(fb => {
             if(fb.name === 'íƒœì–‘ì˜ì¶•ë³µ') { atkMult += 0.3; matkMult += 0.3; critDmg += 50; }
             if(fb.name === 'ë‹¬ì˜ì¶•ë³µ') { matkMult += 0.3; }
             if(fb.name === 'ì„±ì—­') { matkMult += 0.2; }
             if(fb.name === 'ì—¬ì‹ ê°•ë¦¼') { atkMult += 0.25; matkMult += 0.25; }
             if(fb.name === 'ëŒ€ì§€ì˜ì¶•ë³µ') { atkMult += 0.2; matkMult += 0.2; }
             if(fb.name === 'íŠ¸ìœ™í´íŒŒí‹°') { atkMult += 0.2; crit += 10; }
        });

        let atk = Math.floor(p.atk * atkMult);
        let matk = Math.floor(p.matk * matkMult);
        if(p.proto.trait.type === 'cond_twinkle_atk' && battleState.fieldBuffs.some(b=>b.name==='íŠ¸ìœ™í´íŒŒí‹°')) atk = Math.floor(atk * 1.4);

        const e = battleState.enemy;
        if(skill.type === 'phy' || skill.type === 'mag') {
            e.lastHitType = skill.type;

            let val = skill.type === 'phy' ? atk : matk;
            let mult = skill.val;
            let dmgBonus = 0.0;

            let enemyEl = e.element || 'dark';
            let elMult = getElementalMultiplier(p.proto.element, enemyEl);
            if(elMult > 1.0) log(`ìƒì„± ìš°ìœ„! ëŒ€ë¯¸ì§€ 20% ì¦ê°€.`);

            if(skill.desc.includes('ì•”í‘ ìƒíƒœì˜ ì ì—ê²Œ ëŒ€ë¯¸ì§€ 2ë°°') && e.buffs.darkness) mult *= 2;
            if(skill.desc.includes('ì•”í‘ ìƒíƒœ ì  2ë°°') && e.buffs.darkness) mult *= 2;

            if(skill.desc.includes('í•„ë“œë²„í”„ë¥¼ ì œê±°í•˜ê³ ')) {
                let count = battleState.fieldBuffs.length;
                if(count > 0) {
                    battleState.fieldBuffs = [];
                    mult += (count * 2.5);
                    log(`í•„ë“œ ë²„í”„ ${count}ê°œ ì œê±°! ìœ„ë ¥ ëŒ€í­ ìƒìŠ¹!`);
                }
            }
            if(skill.desc.includes('ì‘ì—´ìŠ¤íƒì„ ì „ë¶€ ì†Œëª¨')) {
                if(e.buffs.burn) {
                    let count = e.buffs.burn;
                    mult += (count * 1.5);
                    delete e.buffs.burn;
                    log(`ì‘ì—´ ${count}ìŠ¤íƒ ì†Œëª¨! ìœ„ë ¥ í­ë°œ!`);
                }
            }
            if(skill.desc.includes('ë””ë°”ì¸ìŠ¤íƒ ì „ë¶€ ì†Œëª¨')) {
                if(e.buffs.divine) {
                    let count = e.buffs.divine;
                    mult += (count * 2.0);
                    delete e.buffs.divine;
                    log(`ë””ë°”ì¸ ${count}ìŠ¤íƒ ì†Œëª¨! ì²œë‘¥ì´ ë‚´ë¦¬ì¹©ë‹ˆë‹¤!`);
                }
            }
            if(skill.desc.includes('1~5ë°°ìœ¨ ì‚¬ì´ë¡œ ëœë¤ê³µê²©')) {
                mult = 1.0 + (Math.floor(Math.random() * 5));
                log(`ë¬´ì‘ìœ„ ìœ„ë ¥! x${mult.toFixed(1)}`);
            }

            if(skill.desc.includes('ì‘ì—´ìŠ¤íƒë‹¹') && e.buffs.burn) mult += (e.buffs.burn * 0.5);
            if(skill.desc.includes('ë””ë²„í”„ 1ì¢…ë‹¹') || skill.desc.includes('ë””ë²„í”„ë‹¹')) {
                mult += (Object.keys(e.buffs).length * 0.5);
            }
            if(skill.desc.includes('ë””ë°”ì¸ 3ìŠ¤íƒ') && e.buffs.divine >= 3) mult *= 2;
            if(skill.desc.includes('ìƒëª…ë ¥ 50% ì•„ë˜') && (p.hp/p.maxHp) <= 0.5) mult *= 2;
            if((skill.desc.includes('ì•½í™”ì‹œ 2ë°°') || skill.desc.includes('ìƒëŒ€ê°€ ì•½í™”ì‹œ')) && e.buffs.weak) mult *= 2;
            if((skill.desc.includes('ì €ì£¼ì‹œ 2ë°°') || skill.desc.includes('ìƒëŒ€ê°€ ì €ì£¼ì‹œ')) && e.buffs.curse) mult *= 2;
            if(skill.desc.includes('ë‹¬ì˜ì¶•ë³µ ìƒíƒœì—ì„œ') && battleState.fieldBuffs.some(b=>b.name==='ë‹¬ì˜ì¶•ë³µ')) mult *= 2;
            if(skill.desc.includes('ì–´ë‘  ìƒíƒœì‹œ ì¶”ê°€ 0.5ë°°') && e.buffs.darkness) mult += 0.5;

            if(p.proto.trait.type === 'cond_silence_dmg' && e.buffs.silence) { dmgBonus += (p.proto.trait.val - 1.0); log(`[íŠ¹ì„±] ì¹¨ë¬µ ì¶”ëŒ!`); }
            if(p.proto.trait.type === 'cond_corrosion_dmg' && e.buffs.corrosion) { dmgBonus += (p.proto.trait.val - 1.0); log(`[íŠ¹ì„±] ë¶€ì‹ ì¶”ëŒ!`); }
            if(p.proto.trait.type === 'cond_debuff_3_dmg' && Object.keys(e.buffs).length >= 3) { dmgBonus += (p.proto.trait.val - 1.0); log(`[íŠ¹ì„±] ë””ë²„í”„ 3ê°œ ì´ìƒ ì¶”ëŒ!`); }
            if(p.proto.trait.type === 'cond_divine_3_dmg' && e.buffs.divine >= 3) { dmgBonus += (p.proto.trait.val - 1.0); log(`[íŠ¹ì„±] ë””ë°”ì¸ 3ìŠ¤íƒ ì´ìƒ ì¶”ëŒ!`); }

            let isCrit = Math.random() * 100 < crit;
            if(isCrit) val *= (critDmg / 100);

            let def = skill.type === 'phy' ? e.def : e.mdef;
            let defRed = 0.0;
            if(e.buffs.corrosion || e.buffs.darkness) defRed += 0.2;
            if(e.buffs.curse) defRed += 0.2;
            def = Math.floor(def * (1.0 - defRed));

            let finalMult = mult * elMult * (1.0 + dmgBonus);
            let dmg = val * finalMult * (100 / (100 + def));
            dmg = Math.floor(dmg);
            e.hp -= dmg;
            if(dmg > 0) e.tookDamageThisTurn = true;
            log(`${isCrit?'Critical! ':''}ì ì—ê²Œ <span class="log-dmg">${dmg}</span> í”¼í•´.`);
        }

        if(skill.desc.includes('í•„ë“œë²„í”„')) {
            let buffName = skill.desc.match(/í•„ë“œë²„í”„ (.+?) (ë°œë™|ë¶€ì—¬)/)[1];
            applyFieldBuff(buffName);
        }

        // Rumi Trait Logic
        if(p.proto.trait.type === 'syn_fire_water_nature' && skill.name === 'ë¬¸ë¼ì´íŠ¸ì„¸ë ˆë‚˜') {
             // Check deck elements
             const activePlayers = battleState.players.filter(pl => pl !== null && !pl.isDead);
             const elements = activePlayers.map(pl => pl.proto.element);
             if(elements.includes('fire') && elements.includes('water') && elements.includes('nature')) {
                  log("ë£¨ë¯¸ì˜ íŠ¹ì„± ë°œë™! íŠ¸ìœ™í´íŒŒí‹° ì¶”ê°€!");
                  applyFieldBuff('íŠ¸ìœ™í´íŒŒí‹°');
             }
        }
        if(skill.desc.includes('íšŒí”¼ìœ¨') || skill.desc.includes('íšŒí”¼íƒœì„¸')) p.buffs.evasion = true;
        if(skill.desc.includes('ë¬¼ë¦¬ê³µê²© ë¬´íš¨')) p.buffs.barrier = true;
        if(skill.desc.includes('ë§ˆë²•ê³µê²© ë¬´íš¨')) p.buffs.magic_guard = true;
        if(skill.desc.includes('ëŒ€ë¯¸ì§€ ë°˜ê°')) p.buffs.guard = true;

        if(skill.desc.includes('ì•”í‘ ë¶€ì—¬')) applyDebuff(e, 'darkness');
        if(skill.desc.includes('ë¶€ì‹ ë¶€ì—¬')) applyDebuff(e, 'corrosion');
        if(skill.desc.includes('ì¹¨ë¬µ ë¶€ì—¬') || skill.desc.includes('ì¹¨ë¬µ, ì‘ì—´ ë¶€ì—¬')) applyDebuff(e, 'silence');
        if(skill.desc.includes('ì €ì£¼ ë¶€ì—¬')) applyDebuff(e, 'curse');
        if(skill.desc.includes('ì•½í™” ë¶€ì—¬')) applyDebuff(e, 'weak');
        if(skill.desc.includes('ì‘ì—´ ë¶€ì—¬') || skill.desc.includes('ì‘ì—´ìŠ¤íƒ ë¶€ì—¬') || skill.desc.includes('ì¹¨ë¬µ, ì‘ì—´ ë¶€ì—¬')) applyDebuff(e, 'burn', true);
        if(skill.desc.includes('ì‘ì—´ìŠ¤íƒ ì¶”ê°€')) applyDebuff(e, 'burn', true);
        if((skill.desc.includes('ë””ë°”ì¸') && skill.desc.includes('ë¶€ì—¬')) || skill.desc.includes('ë””ë°”ì¸, ì•”í‘ ë¶€ì—¬')) applyDebuff(e, 'divine', true);
        if(skill.desc.includes('ë””ë°”ì¸, ì•”í‘ ë¶€ì—¬')) applyDebuff(e, 'darkness');

        if(skill.desc.includes('ëœë¤ ë””ë²„í”„ 2ì¢…') || skill.desc.includes('ëœë¤ 2ì¢… ë¶€ì—¬')) {
            let pool = ['darkness', 'corrosion', 'silence', 'curse', 'weak'];
            pool.sort(() => 0.5 - Math.random());
            applyDebuff(e, pool[0]);
            applyDebuff(e, pool[1]);
        }
        if(skill.desc.includes('ë¶€ì‹, ì¹¨ë¬µ, ì•½í™”, ì €ì£¼ ë¶€ì—¬')) {
            applyDebuff(e, 'corrosion'); applyDebuff(e, 'silence'); applyDebuff(e, 'weak'); applyDebuff(e, 'curse');
        }
        if(skill.desc.includes('ì €ì£¼, ì¹¨ë¬µ, ì•”í‘ ë¶€ì—¬')) {
            applyDebuff(e, 'curse'); applyDebuff(e, 'silence'); applyDebuff(e, 'darkness');
        }

        if(skill.desc.includes('ì´ ì¹´ë“œëŠ” ì‚¬ë§í•œë‹¤')) { p.hp = 0; p.isDead = true; log(`${p.name} ì‚¬ë§!`); }
        if(skill.desc.includes('ë‹¤ìŒ í„´ íœ´ì‹') || skill.desc.includes('í–‰ë™ ë¶ˆê°€') || skill.desc.includes('ë‹¤ìŒí„´ë¶ˆê°€')) p.buffs.stun = true;

        if(skill.desc.includes('ë””ë²„í”„ 5ê°œ ì´ìƒì‹œ ìŠ¤í„´') && Object.keys(e.buffs).length >= 5) {
             // Enemy stun logic? Enemy doesn't have 'stun' buff logic yet, but let's just log it or skip next turn.
             // We'll add a 'stun' flag to enemy and check in startEnemyTurn.
             e.buffs.stun = true;
             log(`ì ì—ê²Œ ê¸°ì ˆ ë¶€ì—¬!`);
        }

        if(e.hp <= 0) { winBattle(); return; }
        if(p.hp <= 0 && !p.isDead) { p.isDead = true; log(`${p.name} ì‚¬ë§!`); }

        if(!isDelayed) setTimeout(startEnemyTurn, 500);
    }

    function applyFieldBuff(name) {
        if(battleState.fieldBuffs.some(b => b.name === name)) return log(`í•„ë“œë²„í”„ [${name}]ëŠ” ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.`);
        if(battleState.fieldBuffs.length >= 3) { let removed = battleState.fieldBuffs.shift(); log(`í•„ë“œë²„í”„ [${removed.name}] ì†Œë©¸.`); }
        battleState.fieldBuffs.push({ name: name }); log(`í•„ë“œë²„í”„ [${name}] ë°œë™!`);
    }
    function applyDebuff(target, type, stackable=false) {
        let nameKR = getBuffNameKR(type);
        if(stackable) { target.buffs[type] = (target.buffs[type] || 0) + 1; target.buffs[type] = Math.min(3, target.buffs[type]); log(`ì ì—ê²Œ [${nameKR}] ${target.buffs[type]}ìŠ¤íƒ ë¶€ì—¬.`); }
        else { target.buffs[type] = 1; log(`ì ì—ê²Œ [${nameKR}] ë¶€ì—¬.`); }
    }

    function startEnemyTurn() {
        if(battleState.enemy.hp <= 0) { winBattle(); return; }

        log("--- ì  í„´ ---");
        const e = battleState.enemy;

        // Reset Boss Stats each turn to base, then apply passives/buffs
        e.def = e.baseDef; e.mdef = e.baseMdef;

        // Boss Passives / Logic
        if(e.id === 'artificial_demon_god') {
            // Clear previous protocols first
            if(e.buffs.defProtocolPhy) delete e.buffs.defProtocolPhy;
            if(e.buffs.defProtocolMag) delete e.buffs.defProtocolMag;

            // Detect hits from player turn and activate protocol for THIS enemy turn + NEXT player turn
            if(e.lastHitType === 'phy') { e.buffs.defProtocolPhy = 1; log("ë°©ì–´ í”„ë¡œí† ì½œ: ë¬¼ë¦¬ í”¼ê²© ê°ì§€."); }
            if(e.lastHitType === 'mag') { e.buffs.defProtocolMag = 1; log("ë°©ì–´ í”„ë¡œí† ì½œ: ë§ˆë²• í”¼ê²© ê°ì§€."); }

            if(e.buffs.defProtocolPhy) { e.def = Math.floor(e.def * 1.5); log("ë°©ì–´ë ¥ ì¦ê°€ ìƒíƒœ."); }
            if(e.buffs.defProtocolMag) { e.mdef = Math.floor(e.mdef * 1.5); log("ë§ˆë²•ë°©ì–´ë ¥ ì¦ê°€ ìƒíƒœ."); }
        }
        else if(e.id === 'demon_god') {
             if(battleState.turn % 2 === 0) { e.def = Math.floor(e.def * 1.5); log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: ì§ìˆ˜ í„´ ë°©ì–´ë ¥ ì¦ê°€."); }
             else { e.mdef = Math.floor(e.mdef * 1.5); log("ë§ˆì‹ ì˜ ê¶ŒëŠ¥: í™€ìˆ˜ í„´ ë§ˆë²•ë°©ì–´ë ¥ ì¦ê°€."); }
        }

        if(e.buffs.stun) {
            log(`${e.name} ê¸°ì ˆí•˜ì—¬ í–‰ë™ ë¶ˆê°€.`);
            delete e.buffs.stun;
            endEnemyTurn();
            return;
        }

        // Target Selection
        let target = battleState.players[battleState.currentPlayerIdx];
        if(!target || target.isDead) {
            let players = battleState.players.filter(p => p !== null);
            if(players.every(p => p.isDead)) { loseBattle(); return; }
            while(battleState.currentPlayerIdx < 3) {
                 battleState.currentPlayerIdx++;
                 target = battleState.players[battleState.currentPlayerIdx];
                 if(target && !target.isDead) break;
            }
            if(!target) { loseBattle(); return; }
        }

        let skill = null;

        // AI Skill Logic
        if(e.id === 'artificial_demon_god') {
            if(battleState.turn === 10) skill = e.skills.find(s => s.name === 'íŒŒê´´ì˜í˜•íƒœ');
            else if(Math.random() < 0.3) skill = e.skills.find(s => s.name === 'ì•„ì´ìŠ¤ë¹”');
            else skill = { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' }; // Fallback
        }
        else if(e.id === 'iris_love') {
            if(battleState.turn === 7) { skill = e.skills.find(s => s.name === 'ì†Œìš¸ë“œë ˆì¸'); target.mp = 0; log("ì†Œìš¸ë“œë ˆì¸! í”Œë ˆì´ì–´ ë§ˆë‚˜ ì†Œë©¸."); }
            else if(Math.random() < 0.1) skill = e.skills.find(s => s.name === 'ë”í™€ë¦¬');
            else if(Math.random() < 0.3) skill = e.skills.find(s => s.name === 'í™€ë¦¬ë ˆì´');
            else skill = { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' }; // Fallback
        }
        else if(e.id === 'iris_curse') {
            if(battleState.turn === 10) skill = e.skills.find(s => s.name === 'ì•„í¬ì¹¼ë¦½ìŠ¤');
            else if(Math.random() < 0.3) skill = e.skills.find(s => s.name === 'í”„ë ˆì„ìƒ·');
            else skill = { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' }; // Fallback
        }
        else if(e.id === 'pharaoh') {
            if(battleState.turn % 5 === 0) {
                skill = e.skills.find(s => s.name === 'ê³ ëŒ€ì˜ì €ì£¼');
                if(e.tookDamageThisTurn) { skill.val = 3.0; log("íŒŒë¼ì˜¤ê°€ ë¶„ë…¸í•©ë‹ˆë‹¤! ê³ ëŒ€ì˜ ì €ì£¼ ìœ„ë ¥ ìƒìŠ¹!"); } else skill.val = 1.0;
            }
            else if(Math.random() < 0.3) skill = e.skills.find(s => s.name === 'ê³ ëŒ€ì˜í˜');
        }
        else if(e.id === 'demon_god') {
            if(battleState.turn === 7 || battleState.turn === 14) skill = e.skills.find(s => s.name === 'ì œë…¸ì‚¬ì´ë“œ');
            else if(Math.random() < 0.2) skill = e.skills.find(s => s.name === 'ë‹¤í¬ë‹ˆìŠ¤');
        }
        else if(e.id === 'creator_god') {
            if(e.isCharging) {
                log("ì°½ì¡°ì‹ ì´ í˜ì„ ëª¨ìœ¼ê³  ìˆìŠµë‹ˆë‹¤...");
                skill = e.skills.find(s => s.name === 'ë””ë°”ì¸ë¸”ë ˆì´ë“œ');
                e.isCharging = false;
            }
            else if(battleState.turn === 2) skill = e.skills.find(s => s.name === 'ì €ì§€ë¨¼íŠ¸');
            else {
                let r = Math.random();
                if(battleState.turn > 15 && r < 0.2) skill = e.skills.find(s => s.name === 'ì €ì§€ë¨¼íŠ¸');
                else if(r < 0.2) skill = e.skills.find(s => s.name === 'í™€ë¦¬ë ˆì´');
                else if(r < 0.4) {
                    log("ì°½ì¡°ì‹ ì´ ìì„¸ë¥¼ ì¡ìŠµë‹ˆë‹¤ (ì°¨ì§€ì¤‘...)");
                    e.isCharging = true;
                    endEnemyTurn(); return;
                }
            }
        }

        if(!skill) {
             // Generic random skill or attack
             if(Math.random() < 0.3 && e.skills.length > 0) skill = e.skills[Math.min(e.skills.length-1, Math.floor(Math.random() * e.skills.length))];
             else skill = { type: 'phy', val: 1.0, name: 'ì¼ë°˜ ê³µê²©' };
        }

        let val = skill.type === 'phy' ? e.atk : e.matk;
        let mult = skill.val;
        if(e.buffs.weak && skill.type === 'phy') val *= 0.8; if(e.buffs.silence && skill.type === 'mag') val *= 0.8;

        let def = skill.type === 'phy' ? target.def : target.mdef;
        let fieldDef = 1.0, fieldMdef = 1.0;
        battleState.fieldBuffs.forEach(b => { if(b.name === 'ìŠ¤íƒ€íŒŒìš°ë”') { fieldDef += 0.2; fieldMdef += 0.2; } if(b.name === 'ì„±ì—­') { fieldMdef += 0.2; } if(b.name === 'ì—¬ì‹ ê°•ë¦¼') { fieldDef += 0.25; fieldMdef += 0.25; } });
        def = Math.floor(def * fieldDef);

        let eva = 5;
        battleState.fieldBuffs.forEach(fb => { if(fb.name === 'ë‹¬ì˜ì¶•ë³µ') eva += 10; });
        if(target.proto.trait.type === 'cond_no_field_buff_eva' && battleState.fieldBuffs.length === 0) eva += 30;

        if((target.buffs.evasion && Math.random() < 0.5) || (Math.random()*100 < eva)) { log(`${target.name} íšŒí”¼ ì„±ê³µ! (${skill.name} íšŒí”¼)`); endEnemyTurn(); return; }
        if(target.buffs.barrier && skill.type === 'phy') { log(`${target.name} ë°°ë¦¬ì–´ë¡œ ë°©ì–´!`); endEnemyTurn(); return; }
        if(target.buffs.magic_guard && skill.type === 'mag') { log(`${target.name} ë§¤ì§ê°€ë“œë¡œ ë°©ì–´!`); endEnemyTurn(); return; }

        let dmg = val * mult * (100 / (100 + def));
        if(target.buffs.guard) dmg *= 0.5;
        dmg = Math.floor(dmg); target.hp -= dmg;
        log(`${e.name}ì˜ ${skill.name}! <span class="log-dmg">${dmg}</span> í”¼í•´.`);

        if(target.hp <= 0) {
            target.isDead = true;
            target.hp = 0;
            log(`${target.name} ì“°ëŸ¬ì§!`);
            if(target.proto.trait.type === 'death_dmg_mag') {
                let dAtk = target.matk * 2.0;
                let dDmg = Math.floor(dAtk * (100 / (100 + e.mdef)));
                e.hp -= dDmg;
                log(`[íŠ¹ì„±] ì‚¬ë§ì‹œ ë°˜ê²©! ì ì—ê²Œ ${dDmg} í”¼í•´.`);
            }
            if(target.proto.trait.type === 'death_dmg_debuff') {
                 let dCount = Object.keys(e.buffs).length;
                 let dDmg = Math.floor(target.matk * dCount * 1.0); // 1.0 multiplier per debuff
                 e.hp -= dDmg;
                 log(`[íŠ¹ì„±] ì‚¬ë§ì‹œ ì €ì£¼! ì ì—ê²Œ ${dDmg} í”¼í•´.`);
            }
            if(target.proto.trait.type === 'death_field_sun') applyFieldBuff('íƒœì–‘ì˜ì¶•ë³µ');

            battleState.currentPlayerIdx++;
            let valid = false;
            while(battleState.currentPlayerIdx < 3) {
                 if(battleState.players[battleState.currentPlayerIdx] && !battleState.players[battleState.currentPlayerIdx].isDead) { valid=true; break; }
                 battleState.currentPlayerIdx++;
            }
            if(!valid) { loseBattle(); return; }
        }

        if(e.hp <= 0) winBattle(); else endEnemyTurn();
    }

    function endEnemyTurn() {
        battleState.turn++;
        battleState.enemy.tookDamageThisTurn = false;
        startPlayerTurn();
    }

    function handlePermadeath(players) {
        let deadNames = [];
        players.forEach(p => {
            if(p && p.isDead) {
                let idx = gameState.inventory.indexOf(p.id);
                if(idx > -1) gameState.inventory.splice(idx, 1);
                if(p.pos !== undefined) gameState.deck[p.pos] = null;
                deadNames.push(p.name);
            }
        });
        if(deadNames.length > 0) alert(`ì „ì‚¬ì ë°œìƒ: ${deadNames.join(', ')}\n(ì¹´ë“œê°€ ì†Œë©¸í–ˆìŠµë‹ˆë‹¤)`);
    }
    function winBattle() {
        handlePermadeath(battleState.players);
        alert("ìŠ¹ë¦¬!");
        let reward = 1;
        if(battleState.players.some(p => p && p.proto.trait.type === 'looter')) reward += 1;

        gameState.tickets += reward;
        gameState.enemyScale++;
        log(`ìŠ¹ë¦¬ ë³´ìƒ: ë½‘ê¸°ê¶Œ ${reward}ì¥ íšë“.`);
        toMenu();
    }
    function loseBattle() {
        handlePermadeath(battleState.players);
        alert("íŒ¨ë°°...");
        toMenu();
    }

    function showBattleStat(side, idx) {
        let char;
        if(side === 'player') char = battleState.players[idx];
        else char = battleState.enemy;
        if(!char) return;

        let buffs = Object.keys(char.buffs).map(k => {
            let name = getBuffNameKR(k);
            let val = char.buffs[k];
            if(val === true) return name;
            return `${name}(${val})`;
        }).join(', ') || 'ì—†ìŒ';

        let content = `<b>[${char.name}]</b><br>HP: ${char.hp}/${char.maxHp}<br>`;
        if(side === 'player') content += `MP: ${char.mp}<br>`;
        content += `ATK: ${char.atk} / MATK: ${char.matk}<br>`;
        content += `DEF: ${char.def} / MDEF: ${char.mdef}<br>`;
        content += `ìƒíƒœ: ${buffs}<br><br>`;

        if(side === 'player') {
             content += `<b>[ìŠ¤í‚¬]</b><br>`;
             char.proto.skills.forEach(s => {
                 let multText = s.val ? ` (x${s.val})` : '';
                 content += `- ${s.name}: ${s.desc}${multText}<br>`;
             });
        } else {
             content += `<b>[ìŠ¤í‚¬]</b><br>`;
             char.skills.forEach(s => {
                 let multText = s.val ? ` (x${s.val})` : '';
                 content += `- ${s.name}: ${s.desc}${multText}<br>`;
             });
        }

        openInfoModal(char.name, content);
    }

    function showFieldBuffInfo() {
        if(battleState.fieldBuffs.length === 0) return alert("í™œì„±í™”ëœ í•„ë“œ ë²„í”„ê°€ ì—†ìŠµë‹ˆë‹¤.");
        const buffInfo = {
            'íƒœì–‘ì˜ì¶•ë³µ': 'ë¬¼ê³µ/ë§ˆê³µ +30%, ì¹˜ëª…íƒ€ëŒ€ë¯¸ì§€ +50%',
            'ë‹¬ì˜ì¶•ë³µ': 'ë§ˆê³µ +30%, íšŒí”¼ìœ¨ +10%',
            'ì„±ì—­': 'ë§ˆê³µ +20%, ë§ˆë°© +20%',
            'ì—¬ì‹ ê°•ë¦¼': 'ë¬¼ê³µ/ë§ˆê³µ +25%, ë°©ì–´/ë§ˆë°© +25%',
            'ëŒ€ì§€ì˜ì¶•ë³µ': 'ë¬¼ê³µ/ë§ˆê³µ +20%',
            'íŠ¸ìœ™í´íŒŒí‹°': 'ë¬¼ê³µ +20%, ì¹˜ëª…íƒ€ìœ¨ +10%',
            'ìŠ¤íƒ€íŒŒìš°ë”': 'ë°©ì–´/ë§ˆë°© +20%'
        };
        let msg = "";
        battleState.fieldBuffs.forEach(b => {
             msg += `<b>[${b.name}]</b><br>${buffInfo[b.name] || ''}<br><br>`;
        });
        openInfoModal("í•„ë“œ ë²„í”„", msg);
    }

    function openInfoModal(title, content) {
        document.getElementById('info-title').innerText = title;
        document.getElementById('info-content').innerHTML = content;
        document.getElementById('modal-info').classList.add('active');
    }
    function closeInfoModal() { document.getElementById('modal-info').classList.remove('active'); }
</script>
</body>
</html>
